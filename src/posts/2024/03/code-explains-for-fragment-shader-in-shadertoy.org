#+title: ShaderToy常见代码解释 (收录中)
#+date: 2024-03-02
#+index: code-explains-for-fragment-shader
#+tags: GLSL
#+begin_abstract
在编程这一方面, 个人认同这一个观点: 要想实现某个东西最有效的办法是抄别人的代码, 并且要抄得明白.

不要看这句话看似很 =low=, 它里面其实有这么一些对应关系, "抄得明白"对应知道原理, "抄别人代码"对应实践.

对于 =ShaderToy= 也是一样的, 你想像那些前辈一样实现酷炫的效果, 就得脸皮厚一点去 *抄明白* 他们的代码, 大胆承认抄别人的代码.

#+begin_quote
抄的时候要明白代码的每一部分的含义: 对这部分代码修改会产生什么影响, 了解影响是怎么变化的, 以此建立起直观的理解.
#+end_quote

并且要多抄, 抄到不用看就能随手写出来, 知道每一处代码的作用能按照自己的意愿进行修改, 到了这种地步就说明知识已经被内化了.

这篇笔记就是用来记录"明白"这一过程.

另外, 这里建议有两点建议:

1. 参考一下 [[https://thebookofshaders.com/][The Book of Shaders]] 这本书(截止目前为止还没写完);

2. 如果在阅读其它人的代码时看到一些自己不理解的函数(=shader= 的函数基本上就是数学函数的翻译), 使用绘图工具绘制其函数图像来了解其行为.

   这里推荐 [[https://graphtoy.com][GraphToy]] 和 [[https://maxima.sourceforge.io/][Maxima]] (=Maxima= 是开源免费的, 有钱人可以选择像 =Mathematica= 或者 =MATLAB= 之类的商业软件).

   =GraphToy= 提供了 =GLSL= 内置函数定义, 专门用于 =Shader= 的编写辅助.

    和 =GraphToy= 不一样, =Maxima= 并不提供 =GLSL= 的内置函数定义, 它是一个代数计算系统, 专门解决数学计算问题, 也包括画图功能,

    想要在 =Maxima= 使用 =GLSL= 的内置函数需要自己定义(, =GLSL= 的内置函数的定义都很简单), 能够自定义函数则是推荐它的理由, 用来

    弥补 =GraphToy= 的不足. 这篇笔记会提供一些函数的 =Maxima= 定义.

#+end_abstract

# https://clauswilke.com/art/post/shaders

** 常见的 UV 计算
*** UV - 计算片元在屏幕上所对应的 UV 坐标

#+BEGIN_QUOTE
写于 2024/3/3
#+END_QUOTE

=OpenGL= 的 =UV= 坐标是一个左下角为原点, 向上为 $U$, 向右为 $V$, 且范围都是 $[0, 1]$ 的坐标系.

在 =ShaderToy= 中, 人们把整个画面看作是一张大贴图, 片元就是该大贴图上面的一个纹理像素(texel).

片元理所当然地有一个 =UV= 坐标, 可以通过片元坐标 $gl\_fragCoord$ 和屏幕分辨率 $iResolution$ 计算出来.

#+BEGIN_SRC glsl
  vec2 uv = gl_FragCoord.xy / iResolution.xy; // [0.0, 1.0]
#+END_SRC

当要注意的是, 为了方便作图, 片元的 =UV= 并非就要固定在 $[0.0, 1.0]$ 之间.

有时候为了实现某些目的, 需要对 =UV= 做一些列变换.

比如把纹理坐标空间的原点从左下角平移到中心,

#+BEGIN_SRC glsl
  vec2 uv = (gl_FragCoord.xy / iResolution.xy) - 0.5; // [-0.5, 0.5]
#+END_SRC

#+BEGIN_QUOTE
这一步开始已经把一个屏幕平均分成 4 份了.

$[-0.5, 0.5]$ 分别在 $u$ 和 $v$ 两个方向上分为 $[-0.5, 0]$ 和 $[0, 0.5]$ 两个区间.

因此, $2 \times 2 = 4$ 份.
#+END_QUOTE

把新的纹理坐标空间的范围拓展到 $[-1.0, 1.0]$,

#+BEGIN_SRC glsl
  vec2 uv = 2 * ((gl_FragCoord.xy / iResolution.xy) - 0.5); // [-1.0, 1.0]
  // 可简化成
  vec2 uv = 2 * (gl_FragCoord.xy / iResolution.xy) - 1;
#+END_SRC

到目前为止, 我们的 =UV= 计算都是针对屏幕分辨率比例是一比一的情况.

在非一比一情况下绘制个圆形会导致圆变椭圆, 这是因为 *$UV$ 两分量的范围比例和屏幕分辨率比例对不上*, 导致出现拉伸的情况.

解决方法很简单, 以屏幕分辨率比例为准, 对 $UV$ 长的那一方维度分量进行补偿, 使得 $UV$ 分量的范围比例和屏幕分辨率比例一致.

原本的 $UV$ 范围比例固定是 $\frac{x_{uv}}{y_{uv}} = 1$, 而屏幕分辨率比例是 $\frac{x_{iResolution}}{y_{iResolution}}$,

如果屏幕是 $X$ 轴比较长, 那么 $UV$ 就要针对 $x$ 分量进行补偿才能和屏幕分辨率一致: $\frac{x_{uv} \times \frac{x_{iResolution}}{y_{iResolution}}}{x_{uv}} = 1 \times \frac{x_{iResolution}}{y_{iResolution}} = \frac{x_{iResolution}}{y_{iResolution}}$,

如果屏幕是 $Y$ 轴比较长, 那么 $UV$ 就要针对 $y$ 分量进行补偿才能和屏幕分辨率一致: $\frac{x_{uv}}{y_{uv} \times \frac{y_{iResolution}}{x_{iResolution}}} = 1 \div \frac{y_{iResolution}}{x_{iResolution}} = \frac{x_{iResolution}}{y_{iResolution}}$.

#+begin_quote
你可能会问既然要保证两者比例一样, 为什么还要讨论哪根轴较长呢?

从公式上来看, 如果 $Y$ 比较长的话, 用 $1 \times \frac{x_{iResolution}}{y_{iResolution}}$ 来计算不也是一样可以保证两者比例一致吗?

但是别忘记了 $UV$ 本身就是依赖 $iResolution$ 计算出来的, 因此这个数字 $1$ 本身就依赖于 $iResolution$, 下面的代码可以证明这点.
#+end_quote

#+BEGIN_SRC glsl
  vec2 uv = 2 * (gl_FragCoord.xy / iResolution.xy) - 1; // [-1.0, 1.0]
  if (iResolution.x > iResolution.y) {
    // 如果屏幕的 X 轴比 Y 轴长
    uv.x *= iResolution.x / iResolution.y;
  } else {
    // 如果屏幕的 Y 轴比 X 轴长, 或两者相等
    uv.y *= iResolution.y / iResolution.x;
  }
#+END_SRC

到目前为止我相信大部分人都能看得懂, 但 =ShaderToy= 上的例子大部分都是把这段代码简化成一句的.

现在来逐个分析,

#+BEGIN_SRC glsl
  vec2 uv = 2 * (gl_FragCoord.xy / iResolution.xy) - 1;
  /*
    等同于

    uv = (2 * gl_FragCoord.xy) / iResolution.xy - iResolution.xy / iResolution.xy
    uv = (2 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy

    同时可以拆开来看

    uv.x = (2 * gl_FragCoord.x - iResolution.x) / iResolution.x
    uv.y = (2 * gl_FragCoord.y - iResolution.y) / iResolution.y
  ,*/

  if (iResolution.x > iResolution.y) {
    // 如果屏幕的 X 轴比 Y 轴长
    uv.x *= iResolution.x / iResolution.y;
    /*
      等同于
      uv.x = (2 * gl_FragCoord.x - iResolution.x) / iResolution.x * iResolution.x / iResolution.y
      uv.x = (2 * gl_FragCoord.x - iResolution.x) / iResolution.y

      如果和 y 分量合并一起计算, 那么就是
      uv = (2 * gl_FragCoord.xy - iResolution.xy) / iResolution.y
     ,*/
  } else {
    // 如果屏幕的 Y 轴比 X 轴长, 或两者相等
    uv.y *= iResolution.y / iResolution.x;
    /*
      等同于
      uv.y = (2 * gl_FragCoord.y - iResolution.y) / iResolution.y * iResolution.y / iResolution.x
      uv.y = (2 * gl_FragCoord.y - iResolution.y) / iResolution.x

      如果和 x 分量合并一起计算, 那么就是
      uv = (2 * gl_FragCoord.xy - iResolution.xy) / iResolution.x
     ,*/
  }
  /*
    综合两种情况来看就是
    uv = (2 * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y)
   ,*/
#+END_SRC

所以, =ShaderToy= 上有不少例子都是有这一句(或类似的).

#+BEGIN_SRC glsl
vec2 uv = (2 * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);
#+END_SRC

在大部分的 =ShaderToy= 例子中, =UV= 计算是基础且重要的东西, 这个小节所介绍的 =UV= 计算其实是 =UV= 补偿, 解决画面拉伸的问题.

还会介绍一些其它的 =UV= 计算来实现不同的效果.

*** UV计算 - 平铺(tiling)

这里的平铺就是和计算机的桌面壁纸里的平铺是一个概念: 当一张壁纸不能把桌面铺满, 那么就用重复若干张壁纸铺满桌面.

=Shader= 编程也可以平铺.

我们可以换个角度来思考, 默认情况下, 一个像素所对应 $UV$ 坐标是 =gl_FragCoord.xy / iResolution.xy=, 分量的范围是 $[0, 1]$, 这是针对与整个屏幕来说的.

想要平铺, 我们只要在屏幕的范围内复制多几个 $[0, 1]$ 范围的 $UV$ 坐标空间就好了.

#+CAPTION: 重复了 4 个 $[0, 1]$ 范围的 $UV$ 坐标空间
[[../../../files/uv-tiling.png]]

话虽如此, 具体应该怎么做呢? 虽然没有标准答案, 但还是有基本法的.

从原本映射关系来看是 $[x_{min}, x_{max}] \rightarrow [0, 1]$ 和 $[y_{min}, y_{max}] \rightarrow [0, 1]$,

想要在更小的屏幕范围内应该一个 $UV$ 空间, 只要改变 $x_{max}$ 和 $y_{max}$ 的值就可以了.

对于看左上角的 $UV$ 空间, 可以通过 =gl_FragCoord.xy / (iResolution.xy / 2)=, 这里就是把 $x_{max}$ 和 $y_{max}$ 分别改变为 =iResolution.x / 2= 和 =iResolution.y / 2=.

接下来的问题就是如何让构造出另外三个 $UV$ 空间呢?

因为当 =gl_FragCoord.x= 超出 =iResolution.x / 2= 时, =gl_FragCoord.x / (iResolution.x / 2)= 的值就是大于 1 的浮点数,

我们的目标是让其它三个 $UV$ 空间的分量范围为 $[0, 1]$, 方法很简单, =glsl= 的内置函数 =fract= 可以获取浮点数的小数部分,

比如 =fract(1.1)= 等于 0.1, =fract(2.1)= 也是等于 0.1, 从而形成一个以 0 到 0.999... (没到 1) 为一个周期的周期序列.

#+begin_quote
其实可以把第下一个周期头部的 0 看作是上一个周期的 1.

原因很简单, 假设现在经过划分得到两个周期, 那么 =fract(x)= 会得到这样的一个序列(, 以 0.1 为步长):

=[0, 0.1, 0.2, ..., 0.9], [0(1), 0.1, 0.2, ..., 0.9], 0(2)=
#+end_quote

这样就可以让其它 $UV$ 空间的分量范围也处于 $[0, 1)$ 之间,

综上所述, $UV$ 的计算方式就变成这样:

#+begin_src c
  int div_num = 2;
  vec2 uv = fract(gl_FragCoord.xy / (iResolution.xy / div_num));
  /*
    or

    vec2 uv = fract(gl_FragCoord.xy / iResolution.xy * div_num);
   ,*/
#+end_src

这并非唯一的方法, 事实上 *只要是周期函数都可以获取周期序列来进行平铺*, 比如 =cosine=, =sine= 和 =modulo=, 等等.

=cosine= 和 =sine= 的用法和 =fract= 差不多, 基本上把 =fract= 替换就可以了:

#+begin_src c
  int div_num = 2;
  // 别忘记控制好周期
  vec2 uv = cos(gl_FragCoord.xy / (iResolution.xy / div_num * 2 * PI));
  /*
    or

    vec2 uv = fract(gl_FragCoord.xy / iResolution.xy * div_num * 2 * PI);
   ,*/
#+end_src

模运算(modulo)有一点不同:

#+begin_src c
  int div_num = 2;
  float period = 1.0;
  vec2 uv = mod(gl_FragCoord.xy / (iResolution.xy / div_num), period);
  /*
    or

    vec2 uv = mod(gl_FragCoord.xy / iResolution.xy * div_num, period);
   ,*/
#+end_src

并且模运算的周期可以用来对 $UV$ 空间进行等比缩放, 如果把 =period= 定义为 2.0, 那么 $UV$ 的分量范围就是 $[0, 2]$.

** GLSL 内置函数
*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml][函数 - smoothstep]]

#+begin_quote
从这里开始的后面几个章节都会介绍一些常用(或者一些光看名字不知道做啥)的 =GLSL= [[https://gist.github.com/markknol/d06c0167c75ab5c6720fe9083e4319e1][内置函数]], 不过并不会介绍一些典型的数学函数, 比如 =sin/cos/atan= 这些,

这些直接去看数学书就好, 介绍它们会拉长笔记的篇幅.

这些内置函数均可用在 =Fragment Shader= 中.
#+end_quote

$smoothstep$ 函数的定义等价如下:

#+BEGIN_SRC glsl
  /*
    genType clamp(genType x, genType minValue, genType maxValue)

    equals

    min(max(x, minValue), maxValue)
   ,*/

  genType smoothstep(genType edge0, genType edge1, genType x) {
    genType t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
  }
#+END_SRC

$t$ 是从 $edge0$ 到 $edge1$ 的插值, 结果在 $[0, 1.0]$ 内.

#+caption: x, edge0 以及 edge1 三者的关系
[[../../../files/smoothstep-t.png]]

$smoothstep$ 的返回值 $f(t) = 3t^{2} - 2t^{3}$ 是一个最高次项为 3 的多项式函数,

其一阶导数为 $f^{'}(t) = 6t - 6t^{2} = 6t(1 - t)$, 令 $f^{'}(t) = 0$ 可以求得两个驻点的 $t$ 分量: $0$ 和 $1$.

再求出二阶导数 $f^{''}(t) = 6 - 12t$, 分别把驻点的 $t$ 分量分别代入到其中, 分别得到 $f^{''}(0) = 6 > 0$ 和 $f^{''}(1) = -6 < 0$.

也就是说函数 $f(t)$ 在 $t = 0$ 为极小值, 在 $t = 1$ 为极大值, $t$ 在 $[0, 1]$ 这个区间内是单调递增的.

又刚好 $t \in [0, 1.0]$, 因此, $f(t)$ 最小值为 $f(0) = 0$, 最大值为 $f(1) = 1$.

我们再令 $f^{''}(t) = 0$ 尝试求出函数 $f(t)$ 在 $[0, 1]$ 区间的拐点, 解得 $t = 0.5$.

把 $t = 0.5$ 代入原函数得到 $f(t=0.5) = 3 \times 0.5^{2} - 2 \times 0.5^{3} = 0.5$, 得到拐点 $(0.5, 0.5)$.

最后求该点处的切线: $k = f^{'}(0.5) = \frac{y - 0.5}{x - 0.5} = 1.5 \rightarrow y = 1.5x - 0.25$.

该切线的导数 $k^{'} = 1.5$, 表明了函数 $f(t)$ 在 $t = 0.5$ 处的斜率的变化率(也就是 $f^{''}(t)$)是在逐渐增加,

在 $t = 0.5$ 的左边 $f^{''}(t) > 0$ (函数图像 $f$ 在 $x = 0.5$ 左边为上凹), 在右边则是 $f^{''}(t) < 0$ (函数 $f$ 在 $x = 5$ 的右边为下凹). 因此, 点 $(0.5, 0.5)$ 的确是拐点.

因此, $smoothstep$ 是一个从 $[edge0, edge1]$ 到 $[0, 1]$ 的映射, 一条变化率为先增后减的曲线.

最终的函数图像如下:

[[iframe:width: 520px; height: 1060px; border: none; | https://graphtoy.com/?f1(x,t)=smoothstep(0.0,1,x)&v1=true&f2(x,t)=&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.4302807407932391,-0.05999176204044846,1.9620958899187213]]

#+begin_quote
如果仔细看文档的话你会发现一句: "Results are undefined if edge0 ≥ edge1".

然而实践发现: $edge0 \gt edge1$ 的时候, =GraphToy= 所绘制的 $smoothstep$ 函数图像表面依然是有结果的.

比如, 你可以尝试把上面的 $smoothstep(0.0, 1, x)$ 换成 $smoothstep(1, 0.0, x)$ 观察一下: 函数图像会镜像翻转, 从 1 到 0 之间进行插值.

经过搜索, 发现在 [[https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.10.pdf][GLSL 1.10]] 中 $smoothstep$ 是没有这一句的, 这一句是从 [[https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.20.pdf][GLSL 1.20]] 开始才有的.

目前不确定这一句是不是只对一些新版本的 =GLSL= 生效, 还是说有些 =GLSL= 的实现没有严格按照标准来.

其实在数学层面来看, $edge0 \ge edge1$ 不会导致函数 =undefined= 的, 目前实践下来也没有出现 =undefined= 的情况.
#+end_quote

**** [[https://thebookofshaders.com/glossary/?search=smoothstep][The Book Of Shaders 的 smoothstep 函数绘制 Shader 解析]]

#+BEGIN_SRC glsl
  #ifdef GL_ES
  precision mediump float;
  #endif

  #define PI 3.14159265359

  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_time;

  float plot(vec2 st, float pct) {
    return smoothstep(pct-0.02, pct, st.y) -
           smoothstep(pct, pct+0.02, st.y);
  }

  void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;

    // smooth interpolation between 0.1 and 0.9
    float y = smoothstep(0.1, 0.9, st.x);

    vec3 color = vec3(y);

    float pct = plot(st, y);
    color = (1.0 - pct) * color + pct * vec3(0.0, 1.0, 0.0);

    gl_FragColor = vec4(color, 1.0);
  }
#+END_SRC

这段 =shader= 的算法做的事情很简单: 绘制出 $smoothstep(0.1, 0.9, x)$ 的函数图.

做法很简单: 首先计算出 $st.x$ 经过 $smoothstep(0.1, 0.9, x)$ 映射后的值 $y$, 但这样的话所有 $x$ 分量相同的片元在经过映射后拥有相同的 $y$, 我们需要判断片元是否处于函数上.

$plot$ 函数就是判断片元是否在函数上的.

上面代码中的 $plot$ 函数其实是优化过了的, 先看未经优化的版本:

在计算出经过映射的 $y$ 后, 对片元的 $y$ 分量和映射 $y$ 进行对比, 如果两者相等就说明片元在函数上.

但由于它们两者都是浮点数, 没法直接判断是否相等, 因此只能认为当两者相差小于一个边界时为相等.

#+BEGIN_SRC glsl
  float plot(vec2 st, float pct) {
    return abs(pct - st.y) < 0.01 ? 1.0: 0.0;
    /* 或者使用 step 函数
       step(abs(pct - st.y), 0.01);

       type = float/vec2/vec3/vec4

       type step(type edge, type x)

       equals

       returnValue[i] = edge[i] > x[i] ? 0.0: 1.0;
     ,*/
    // return step(abs(pct - st.y), 0.01) ? 1.0: 0.0;
  }
#+END_SRC

*不过* 这样绘制出来的函数图像很生硬, 边界有锯齿, 过渡不够平滑(, 改节标题连接上面的代码可以修改看效果).

优化后的 $plot$ 函数就是为了解决过渡不平滑的问题而出现的:

$smoothstep(pct-0.02, pct, st.y)$ 的函数图像是 $smoothstep(0.02, pct+0.02, st.y)$ 图像的左平移, 在水平方向上两者相差 $0.02 \times 2$ 个距离.

在 $[ptc-0.02, pct+0.02]$ 区间的某一个位置上, 两个图像 *在垂直方向上* 相差的距离的变化规律是先增后减少, $0.02$ 决定着变化率, 越大变化越小, 线条越粗.

#+begin_quote
如果稍微了解过微积分的话, 你应该能感觉到 =plot= 函数像是一个求导函数, 事实上它就是.
#+end_quote

[[iframe:width: 520px; height: 1060px; border: none; | https://graphtoy.com/?f1(x,t)=smoothstep(0.1,0.9,x)&v1=true&f2(x,t)=smoothstep(0.1-0.5,0.9,x)&v2=true&f3(x,t)=smoothstep(0.1,0.9+0.5,x)&v3=true&f4(x,t)=smoothstep(0.1-0.5,0.9,x)-smoothstep(0.1,0.9+0.5,x)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=-0.07768258978845546,0.5049807710072313,4.205926793776948]]

#+BEGIN_QUOTE
我们也可以使用 =Maxima= 进行绘图, =Maxima= 是一个 =CAS= 软件, 除了能画图以外还能帮助你进行强大的数学运算.

个人十分推荐掌握这个工具.

#+BEGIN_SRC maxima
  /* 定义 smoothstep 函数 */
  smoothstep(l, u, x) := block(
    t: min(max((x - l) / (u - l), 0.0), 1.0),
    return (t * t * (3 - 2 * t))
  )$

  /* 绘图 */
  plot2d([smoothstep(0.1-0.5, 0.1, x), smoothstep(0.1, 0.1+0.5, x), smoothstep(0.1-0.5, 0.1, x) - smoothstep(0.1, 0.1+0.5, x) ], [x, -2, 2]);
#+END_SRC
#+END_QUOTE

通过 $smoothstep(0.1-0.5, 0.1, x) - smoothstep(0.1, 0.1+0.5, x)$ 的图像可以得知, 优化后的 $plot$ 的变化相对平滑一点.

回到优化后的 $plot$ 上, 它的作用就是让 $st.y$ 在 $[y-0.02, y+0.02]$ 范围内进行插值, 以先增后减的变化率返回 $[0, 1]$ 的值, 而不是像未优化版只返回 $0$ 或 $1$ 那样一刀切.

**** 编写 =Fragment Shader= 的思路

刚开始学习 =Fragment Shader= 时, 我只知道最终目的是为了设置片元的颜色, 然而并不知道如何绘制出自己想要的图像.

即便去学习别人的代码, 也只能在有参考的情况下写的出来, 完全不知道别人是如何想出来的, 也不知道所谓的阅读代码中学习要学什么内容.

相信很多经历过新手期的人都和我一样认为阅读别人的代码就是要学习其中的数学概念, 其实也没错, =Fragment Shader= 多少得涉及一些数学概念.

然而, 这解释不了为什么有些数学好的人也不能写出自己想要的效果.

在经过一定量的阅读以及大量的总结后, 发现了一个事实: 不管实现什么效果, 任何 =Fragment Shader= 在结构上都有一个固定的模式.

个人认为那些数学好的人没能实现自己想要的效果是因为不了解这个模式, 虽然没办法证明这个观点, 但相信你在看完这个模式后会认同我这个观点.

*开始吧*:

1. 确定好 =UV= 坐标系: 原点在哪, 范围在哪.

2. *时刻记住* 片元原本的 =UV= 坐标 $st_{0}$ 坐标是 =gl_FragCoord.xy / u_resolution=;

   *代码中的变量 $st$ 可以看作是片元的一个新属性*, 其初始值为 $st_{0}$ 的值, 但是 $st$ 可能会在经过计算后发生变化.

   因此, 在 =Fragment Shader= 里面, 一个片元包含始终有一个关系: $f(st_{0}) = st$.

   最后, =Fragment Shader= 绘图的关键在于如何根据 $st$ 来计算出片元的颜色, 粗略地讲就是 *位置决定颜色*.

   函数 $f$ 就是针对 $st$ 的计算, $f$ 可以由多个更小的一系列的函数构成, 比如:

   $f(st_{0}) = st$

   $\Downarrow$

   $f_{0}(st_{0}) = st_{1}$

   $f_{1}(st_{1}) = st_{2}$

   $\vdots$

   $f_{n}(st_{n}) = st$

   确定好每一个函数(每一步运算)的输入范围和计算结果范围, 并且要求对函数的变化规律有直观的理解.

   #+begin_quote
   这就是为什么开篇就推荐绘图工具, 可以帮助我们对函数变化有直观了解;

   这里再推荐掌握 [[https://en.wikipedia.org/wiki/Interval_arithmetic#Interval_operators][区间运算(interval arithmetic)]] 的应用, 在 =Shader= 编程中会经常遇到两个函数之间的算术运算,

   为了估算结果通常都是分别确定好两个函数的计算结果范围在对两者进行运算得到最终范围, 区间运算可以帮助我们快而准地估算出结果.
   #+end_quote

   在明白了这一点后, 关键点就在于: 怎么定义出一个可以实现自己想要效果的函数 $f$.

3. 思考如何定义函数 $f$.

   1. 正如前面说的, 位置决定了颜色, 所以, 我们要这么思考: *随着位置发生怎么样的变化, 颜色要如何变化呢?*

      举几个简单的例子来看看.

      *例子一*: 往 $y$ 方向增加, 颜色越亮, 往 $x$ 方向增加, 颜色越亮.

      #+begin_src c
        vec2 st = gl_FragCoord.xy / u_resolution;

        // f(st) = st.x + st.y
        // y 增加, color 增加
        // x 增加, color 增加
        float color = clamp((st.x + st.y) * 0.5, 0.0, 1.0);

        gl_FragColor = vec4(vec3(color), 1.0);
      #+end_src

      #+caption: 越往右下角方向越亮
      [[../../../files/how-to-think-of-fun-creation-in-shader.png]]

      *例子二*: 往 $y$ 方向增加, 颜色越亮.

      #+begin_src c
        vec2 st = gl_FragCoord.xy / u_resolution;

        // f(st) = st.y
        // y 增加, color 增加
        float color = st.y;

        gl_FragColor = vec4(vec3(color), 1.0);
      #+end_src

      #+caption: 越往下走越亮
      [[../../../files/how-to-think-of-fun-creation-in-shader-2.png]]

      *例子三*: 往 $x$ 方向增加, 颜色越亮.

      #+begin_src c
        vec2 st = gl_FragCoord.xy / u_resolution;

        // f(st) = st.x
        // x 增加, color 增加
        float color = st.x;

        gl_FragColor = vec4(vec3(color), 1.0);
      #+end_src

      #+caption: 越往右走越亮
      [[../../../files/how-to-think-of-fun-creation-in-shader-3.png]]

      *例子四*: 往 $y$ 方向增加, 颜色越亮; 往 $x$ 方向增加, 颜色越暗.

      #+begin_src c
        vec2 st = gl_FragCoord.xy / u_resolution;

        // f(st) = st.y + (1.0 - st.x)
        // y 增加, color 增加
        // x 增加, color 减小
        float color = clamp((st.y + 1.0 - st.x) * 0.5, 0.0, 1.0);

        gl_FragColor = vec4(vec3(color), 1.0);
      #+end_src

      #+caption: 越往左下角走越亮
      [[../../../files/how-to-think-of-fun-creation-in-shader-4.png]]

      *例子五*: 往 $y$ 方向增加, 颜色越亮; 往 $x$ 方向增加, 颜色越暗, 比上一个例子更明显.

      #+begin_src c
        vec2 st = gl_FragCoord.xy / u_resolution;
        // f(st) = (st.x + st.y) + (st.y - 2 * st.x) = 2 * st.y - st.x
        // y 增加, color 增加
        // x 增加, color 减小
        st += st.yx * vec2(1.0, -2.0);
        float color = clamp((st.x + st.y) * 0.5, 0.0, 1.0);

        gl_FragColor = vec4(vec3(color), 1.0);
      #+end_src

      #+caption: 越往左下角走越亮
      [[../../../files/how-to-think-of-fun-creation-in-shader-5.png]]

      这五个例子中的 $f$ 都是的线性函数, 凭想象来思考变化是比较轻松的.

      然而, 对于非线性函数来凭想象就不是那么容易了, 所以借助绘图软快速绘制等值曲线(contour curves)来了解变化是一个不错的手段.

      这里用 =Maxima= 来演示绘制 $f(x, y) = x^{2} - y^{2} - 10$ 在 $x,y \in [-1, 1]$ 的等值线图,

      #+begin_src maxima
        /* 曲面图 + 等值线图 */
        draw3d(
          xlabel = "x",
          ylabel = "y",
          zlabel = "z",
          contour = both,
          contour_levels = 15,
          surface_hide = true,
          enhanced3d = true,
          explicit(x^2 - y^2, x, -1, 1, y, -1, 1)
          )$
      #+end_src
      #+attr_html: :width 800px
      #+caption: =曲面图 + 等值线图=
      [[../../../files/x2-y2-10-contour-map-0.svg]]

      #+begin_src maxima
        /* 曲面图 + 等值线图 + 灰阶 */
        draw3d(
          xlabel = "x",
          ylabel = "y",
          zlabel = "z",
          contour = both,
          contour_levels = 15,
          surface_hide = true,
          enhanced3d = true,
          palette = gray,
          explicit(x^2 - y^2 - 10, x, -1, 1, y, -1, 1)
          )$
      #+end_src
      #+attr_html: :width 800px
      #+caption: =曲面图 + 等值线图 + 灰阶=
      [[../../../files/x2-y2-10-contour-map-1.svg]]

      #+begin_src maxima
        /* 在曲面上绘制等值线图 */
        draw3d(
          xlabel = "x",
          ylabel = "y",
          zlabel = "z",
          contour = both,
          contour_levels = 15,
          surface_hide = true,
          explicit(x^2 - y^2 - 10, x, -1, 1, y, -1, 1)
          )$
      #+end_src
      #+attr_html: :width 800px
      #+caption: =曲面图附加等值线 + 等值线图=
      [[../../../files/x2-y2-10-contour-map-3.svg]]

      #+begin_src maxima
        /* 等值线图 + 灰阶 (个人偏向用这个, 效果图如下) */
        draw3d(
          xlabel = "x",
          ylabel = "y",
          view = map,
          enhanced3d=true,
          palette = gray,
          explicit(x^2 - y^2 - 10, x, -1, 1, y, -1, 1)
          )$
      #+end_src
      #+attr_html: :width 800px
      #+caption: =等值线图 + 灰阶=
      [[../../../files/x2-y2-10-contour-map.svg]]

      关于 =Maxima= 更多的绘图选项请自行阅读[[https://maxima.sourceforge.io/docs/manual/maxima_250.html][文档]].

   2. 也可以这么想: 对于在函数 $f$ 上的片元应该赋予什么颜色, 在函数外的片元又该赋予什么颜色.

      这一点可以参考前面的函数 $plot$.

4. 正确思考 =Fragment Shader= 中的循环.

   *时刻记住*, =Fragment Shader= 的一切计算都是针对一个片元的, 对于一个片元的计算是不可能影响到另外一个片元的计算.

   记住这一条之后, 相信对于很多没有接触过 =Shader= 编程的开发人员来说初次接触 =Fragment Shader= 的一些迭代会很反直觉:

   既然只是针对一个片元, 为什么像下面的例子会绘制出 4 条直线而不是 1 条直线呢?

   #+begin_src c
     vec2 st = gl_FragCoord.xy / u_resolution;

     float color = 0.0;
     int iterations = 4;
     for (int i = 0; i < iterations; i++, st *= 2.0) {
       //  st.x + st.y - 1.0 <= 0.01 相当于函数 y = x
       color += float(abs(st.x + st.y - 1.0) <= 0.01); // float(true) => 1, float(false) => 0
     }

     gl_FragColor = vec4(vec3(color), 1.0);
   #+end_src

   #+caption: 输出结果
   [[../../../files/iteration-in-fragment-shader.png]]

   观察代码可知每个片元的 $color$ 要执行 4 轮计算, 每轮计算都 *试图* 让 $color$ 自增(我们这里约定能加到 1 才是成功自增), 并且让 $st$ 翻倍.

   我们知道这是在绘制直线 $y = x$, 但为什么会绘制出 4 条直线呢?

   *绘制过程* 是这样的:

   位于直线上的片元的 $color$ 在整个迭代中实际只能成功自增 1 次, 而不在直线上的片元则是 0 成功的自增.

   这里选第一长的直线 $l_{A}$ 和第二长的直线 $l_{B}$ 作为例子进行分析, 它们是同时绘制的,

   #+begin_quote
   这里其实没办法确认它们是否严格意义上的同时绘制, 但至少可以确认在执行顺序上两者不会相互影响.
   #+end_quote

   在 $l_{A}$ 上的片元 $p_{A}: (x_{0}, y_{0})$ 在整个迭代中的第 1 轮计算就成功自增, $l_{B}$ 上的片元 $p_{B}: (x_{1}, y_{1})$ 则是在第 2 轮计算才能成功自增.

   这是因为 $p_{A}$ 在第 1 轮计算中就符合 $abs(st.x + st.y - 1.0) \le 0.01$, 之后的 3 轮计算其实没有意义了;

   而 $p_{B}$ 则是满足 $2 \times (x_{1} + y_{1}) = x_{0} + y_{0}$, 所以在经过一轮的 $st$ 翻倍后使得 $p_{B} = (2 \times x_{1}, 2 \times y_{1})$, $p_{B}$ 才符合 $abs(st.x + st.y - 1.0) \le 0.01$.

   第三长的直线和最短的直线也是这个道理, 它们符合条件的轮次分别是第 3 和第 4 轮.

   这个其实就是一个很简单的绘制递归图案的例子, 我之所以选它是想对新人(我)说明一个事实: 在 =Fragment Shader= 中, *有时候* 迭代的每一轮计算更像是一次条件筛选, 整个迭代就是反复试验(=trial and error=).

   这算是 =Fragment Shader= 编程中比较常见的迭代用法了, 比起类似以累加/累积为目的的迭代用法特殊一点,

   它的特殊点在于 *为不同颜色赋予了不同的含义*: 白色为"有意义计算", 黑色为"无意义计算", 这就是如何为片元赋予颜色.


第 3 步需要运用大量的数学知识, 学习数学知识(主要是微积分)就是为了强化这一步: 根据自己的意愿定义出函数 $f$.

相信现在的你能够理解为什么数学好也不一定写好的 =Shader= 了: 不知道把数学用在何处.

只有在掌握整个模式后, "不断阅读其他人的代码并从中吸收所涉及的数学概念以及应用方法" 才是有用的.

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/mix.xhtml][函数 - mix]]

这个函数可能换个名字比较好理解一点: $lerp$, 全称 =linear interpolation=.

没错, 这个函数就是计算出线性插值的.

函数定义为 $mix(x, y, a) = x \times (1 - a) + y \times a$.

#+caption: $mix(x, y, a)$
[[../../../files/func-mix.png]]

#+begin_quote
这个函数的定义是这么来的,

从 $x$ 到 $y$ 的 *变化率是固定的* (也就是线性的), 并且整个变化间隔只占了 1 个单位, 因此变化率是 $k = \frac{y - x}{1}$.

现在想知道处于这个变化过程中的某一刻 $a$ ($0 <= a <= 1$) 时候的值是多少:

$x + k \times a = x + a \times (y - x) = x + a \times y - a \times x = x \times (1 - a) + y \times a$.

#+end_quote

看到这图你可能会联想到前面同样有插值行为的函数 $smoothstep(edge0, edge1, x)$.

它们之间有三点不同:

1. $mix$ 是线性插值; $smoothstep$ 是埃尔米特(Hermite)插值, 属于非线性插值.
2. $smoothstep(edge0, edge1, x)$ 的 $edge0$ 和 $edge1$ 要保证 $edge0 \lt edge1$ 的关系(, 甚至要求 $x$ 位于两者之间, 否则无法按预期插值).
   $mix(x, y, a)$ 中的 $x$ 和 $y$ 没有这个要求, 可以 $x \gt y$ 也可以 $x \lt y$, 甚至可以 $x = y$, $a$ 也没有大小限制.
3. $smoothstep(edge0, edge1, x)$ 要求 $x \in [edge0, edge1]$; $mix(x, y, a)$ 则没有这个要求, 当 $a \in [x, y]$ 时叫做内插(=interpolation=), 当 $a$ 位于 $[x, y]$ 之外时叫做外插/外推(=extrapolation=).
   因此, $smoothstep(edge0, edge1, x) \in [0, 1]$, 而 $mix(x, y, a) \in \mathbb{R}$.


[[iframe:width: 520px; height: 1060px; border: none; | https://graphtoy.com/?f1(x,t)=mix(2,4,x)&v1=true&f2(x,t)=smoothstep(2,4,x)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0,0,12]]

如你所见, 在 $mix(2, 4, x)$ 的图像中, $x = 0$ 时 $y = 2$, $x = 1$ 时 $y = 4$,

$mix(l, r, a)$ 的函数图像必定符合这个规律: $x = 0$ 时 $y = l$, $x = 1$ 时 $y = r$.


*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/dFdx.xhtml][函数 - dFdx/dFdy]]

要想理解 =dFdx/dFdy= 的作用, 得想知道 =GPU= 每次都是以 $2 \times 2$ 这样规模的片元方块作为单位进行处理的, 也就是每次同时调用 4 个 =Fragment Shaders=,

因此, 在一个 =Fragment Shader= 中, 对于 =GPU= 来说可以获取当前片元所在方块内的相邻片元的情况.

我们假设有一个函数 $p(x, y)$ 可以获取位于 $(x, y)$ 的片元的(在光栅化过程计算得到的)某个属性 $attr$: $attr = p(x, y)$,

那么当前片元在 $x$ 轴方向上的下一个相邻片元的属性值则是为 $attr_{x+1} = p(x + 1, y)$,

而在 $y$ 轴方向上的下一个相邻片元的属性值则是为 $attr_{y+1} = p(x, y + 1)$.

$dFdx(attr)$ 其实就是在求在当前片元的 $x$ 轴方向上的某个属性的 $attr$ 的偏导数(=partial derivative=),

虽然在直觉上上挺相似的, 但它并非人们所知的微积分中的偏导数, 其定义为:

$dFdx(attr) = \frac{p(x + 1, y) - p(x, y)}{(x + 1) - x} = attr_{x+1} - attr$.

$dFdy(attr)$ 同理, 只不过是在 $y$ 轴方向上的偏导数, 定义如下:

$dFdy(attr) = \frac{p(x, y + 1) - p(x, y)}{(y + 1) - y} = attr_{y+1} - attr$.

#+CAPTION: dFdx/dFdy
[[../../../files/Shader-Derivatives-1.png]]

比如下面这个例子在 =Fragment Shader= 中使用 $dFdx$ 和 $dFdy$ 根据片元的视点空间(view space)坐标计算出面法线.

#+BEGIN_SRC glsl
  /* vertex shader */
  #ifdef GL_ES
  precision mediump float;
  #endif

  uniform mat4 projectionMatrix;
  uniform mat4 modelViewMatrix;

  in vec3 position;
  out vec3 normalInterp;
  out vec3 pos;

  void main(){
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      vec4 pos4 = modelViewMatrix * vec4(position, 1.0);

      normalInterp = normalMatrix * normal;
      pos = vec3(pos4) / pos4.w;
  }
#+END_SRC

#+BEGIN_SRC glsl
  /* fragment shader */
  #ifdef GL_ES
  precision mediump float;
  #endif

  in vec3 pos;
  in vec3 normalInterp;

  out vec4 outColor;

  uniform float bFlat;

  const vec3 lightPos = vec3(200, 60, 100);
  const vec3 ambientColor = vec3(0.2, 0.0, 0.0);
  const vec3 diffuseColor = vec3(0.5, 0.0, 0.0);

  void main() {
    vec3 normal = mix(normalize(normalInterp),
                      normalize(cross(dFdx(pos), dFdy(pos))), /* 使用 dFdx 和 dFdy 求出片元所在平面的面法线 */
                      bFlat);
    vec3 lightDir = normalize(lightPos - pos);

    float lambertian = max(dot(lightDir, normal), 0.0);
    float specular = 0.0;

    if (lambertian > 0.0) {
      vec3 viewDir = normalize(-pos);
      vec3 halfDir = normalize(lightDir + viewDir);
      float specAngle = max(dot(halfDir, normal), 0.0);
      specular = pow(specAngle, 16.0);
    }

    outColor = vec4(ambientColor + lambertian * diffuseColor + specular * specColor, 1.0);
  }
#+END_SRC

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/fract.xhtml][函数 - fract]]

#+begin_quote
对这个函数进行笔记是因为本人在上面碰过壁, 对于 =GLSL= 里面的每个函数请一定要看它的定义, 并且使用绘图工具绘制一遍.
#+end_quote

=fract= 的官方定义是:

#+BEGIN_SRC maxima
  /* 定义 fract 函数 */
  fract(x) := x - floor(x)$

  /* 绘图 */
  plot2d(fract(x), [x, -2, 2]);
#+END_SRC

我一开始不理解 $x \to 0$ 时 $fract(x)$ 附近会是 1, 是因为无视了 $floor(x)$ 函数的定义: 返回小于或等于 $x$ 的最接近的整数.

在 $x \ge 0$ 时, $floor(x)$ 和 $trunc(x)$ 的作用是一样的: 直接返回整数部分.

但是根据定义, 对于 $x \lt 0$ 的时候就不一样了, 比如 $floor(-0.01) = -1$, 而不是返回 0, 因此 $fract(-0.01) = -0.01 + 1 = 0.99$.

[[iframe:width: 520px; height: 1060px; border: none; | https://graphtoy.com/?f1(x,t)=fract(x)&v1=true&f2(x,t)=floor(x)&v2=true&f3(x,t)=&v3=true&f4(x,t)=&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=true&grid=1&coords=0,0,12]]

#+begin_quote
既然提到了 $floor$ 函数, 我觉得还是有必要提一下 $ceil$ 函数以及 $round$ 函数.

它们三者的作用都是处理掉浮点数的小数部分, 但是处理方式是完全不一样的, 在特殊情况下导致的结果也是天差地别.

如果不是经常使用, 很容易会因为对它们的定义不熟悉而写出意料之外的 =shader code=, 又由于对它们的不熟悉导, 在找出问题时也很难怀疑到它们身上.

所以不要掉以轻心, 我写这个函数就是因为痛苦的经历.

$ceil(x)$ 函数定义就和 $floor(x)$ 的完全相反: 返回大于或等于 $x$ 的最接近整数. $ceil(x)$ 的作用看上去和 $trunc(x)$ 差很远, 所以就不过多解释.

$round(x)$ 就是"四舍五入", 当 $x$ 的小数部分大于或等于 $0.5$ 就进 $1$, 相信很多人都是在小学一/二年纪了解到这个概念, 但是那个时候是没有学负数的(, 学了负数后面好像也没有回顾"四舍五入"这个概念),

这个进 $1$ 是否就像正数那样给 $x$ 的整数部分加 $1$ 呢? 刚好相反, 对于负数而言进 $1$ 是减 $1$, 所以 $round(-1.5) = -2$, 而不是 $0$.
#+end_quote

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/faceforward.xhtml][函数 - faceforward]]

$faceforward(N, I, Nref)$ 函数用于判断入射向量 $I(ncident vector)$ 和表面法线向量 $Nref$ 是否一致朝向(指向同一个半球(hemisphere)/半圆(semicircle)的方向),

如果不是, 就要把法线向量 $N$ 反转($-1 \times N$)并把它作为结果返回, 否则直接返回 $N$.

通常 $Nref$ 的值是和 $N$ 是一样的,

所以这个函数一般是用来判断表面的面向是否为正面, 不是的话就进行纠正, 这就是函数名字的由来.

函数的定义:

#+begin_quote
如果 $dot(I, Nref) < 0$, 表明 $I$ 是从表面的正面进入, 返回 $N$;

如果 $dot(I, Nref) > 0$, 表明 $I$ 是从表面的背面进入, 返回 $-1 \times N$.
#+end_quote

#+BEGIN_SRC maxima
  /* 定义 faceforward 函数 */
  faceforward(n, i, nr) := block(
    return (-1 * signum(i . nr) * n)
  )$

  /* Test */
  /* faceforward([0, 1], [-4, 2], [0, 1]); */
  /* faceforward([1, 0], [-4, -2], [1, 0]); */
#+END_SRC

#+caption: faceforward
[[../../../files/func-faceforward.png]]

如果不理解的话可以看这图,

$dot(I, Nref) = |I||Nref|\cos(angle(I, Nref))$, 其中 $angle(I, Nref)$ 是向量 $I$ 和 向量 $Nref$ 之间的角度.

根据 $\cos$ 函数图像可以知道, 如果 $\frac{-\pi}{2} < angle(I, Nref) < \frac{\pi}{2}$, 那么 $dot(I, Nref) > 0$,

很明显, 图中的 $I1$ 符合这种情况: $dot(I1, Nref) > 0$;

如果 $\frac{-\pi}{2} > angle(I, Nref)$ 或 $\frac{\pi}{2} < angle(I, Nref)$, 那么 $dot(I, Nref) < 0$.

没错, $I0$ 符合这种情况(, 准确一点是满足 $\frac{-\pi}{2} > angle(I0, Nref)$), 因此 $dot(I0, Nref) < 0$.

如果还不理解的话, 可以看一下这个地址: [[https://blender.stackexchange.com/questions/279677/mathematically-what-does-faceforward-function-mean][mathematically-what-does-faceforward-fhunction-mean]].

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/reflect.xhtml][函数 - reflect]]

$reflect(I, N)$ 函数用于计算 $I$ 射入面向 $N$（需要确保被一般化) 的表面后的反射方向: $I - 2.0 \times dot(N, I) \times N$.

这个函数定义的推导过程可以看我[[../../2020/08/graphics-opengl-light-and-material.html#specular][以前的文章]], 这里不再赘述.

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/refract.xhtml][函数 - refract]]

$refract(I, N, eta)$ 函数用于计算出入射光线 $I$ 经过面向 $N$ 表面(surface)后的折射光线的向量, $eta$ 是表面的折射率比(ratio of indices of refraction).

想了解 $eta$ 的定义, 得先了解斯涅尔定律(=Snell's law=), 又叫折射定律.

#+attr_html: :width 800px
#+caption: [[https://www.youtube.com/watch?v=NcCSGtnUUpw&ab_channel=AndyMasley%27sIBPhysicsLectures][折射 & 斯涅尔定律(图来自 IB Physics)]]
[[../../../files/refraction-and-snells-law-from-physics-ib.jpg]]

根据定律, $eta = \frac{n_{1}}{n_{2}} = \frac{\sin\theta_{1}}{\sin\theta_{2}}$ 或者 $eta = \frac{n_{2}}{n_{1}} = \frac{\sin\theta_{2}}{\sin\theta_{1}}$? 究竟是哪个呢?

$refract$ 的文档并没有说明这一切, 于是我在 =StackOverflow= 上通过这一篇帖子找到了答案: [[https://stackoverflow.com/questions/20801561/glsl-refract-function-explanation-available][glsl refract function explanation available]].

#+begin_quote
我还在这篇帖子上收获了另外一个技巧: 在 [[https://books.google.com/][Google Books]] 里面检索一些较为专业的名词/概念, 比如 "refraction vector".

事实上很多这种专业的名词/概念很少会出现在搜索引擎上的, 通常只会出现在教材上, 所以这个技巧对自学者很重要.
#+end_quote

这篇帖子直接给出了折射向量的公式推导, 不过还是得写下自己的理解(, 因为要看懂它的推导还需要一些额外的概念补充, 以及添加额外说明使它更易懂).

#+caption: 折射向量推导
[[../../../files/calc-refraction-vector.png]]

图中的向量 $I$ / $N$ / $M$ 都是单位向量, $M$ 是垂直于 $N$ 的向量, 而向量 $T$ 是 $refract(I, N, eta)$ 的返回结果: 折射向量.

从图中可以看出, 求出 $T$ 的关键是求出向量 $M$.

其实, 向量 $H$ 的单位向量就是 $M$, 但两者的大小不一样, 它们的大小关系为: $\sin\theta_{i} = \frac{|H|}{|I|} = \frac{|H|}{|M|} = |H|$,

因此, $M = \frac{H}{\sin\theta_{i}}$.

现在可以计算出 $T = M \times \sin\theta_{t} - N \times \cos\theta_{t} = \frac{\sin\theta_{t}}{\sin\theta_{i}}(N \times \cos\theta_{i} - I) - N \times \cos\theta_{t} = (\frac{\sin\theta_{t}}{\sin\theta_{i}} \times \cos\theta_{i} - \cos\theta_{t}) \times N - \frac{\sin\theta_{t}}{\cos\theta_{i}} \times I$.

现在回过头来看 $eta$, 从计算 $T$ 的方程中, 选择 $eta = \frac{\sin\theta_{t}}{\sin\theta_{i}}$ 比较合适, 所以 $T = (eta \times \cos\theta_{i} - \cos\theta_{t}) \times N - eta \times I$.

现在 $I$ / $N$ / $eta$ / $T$ 这 4 者的关系已经理清了, 只差 $\cos\theta_{t}$ 和 $\sin\theta_{t}$ 的值就可以得出 $T$ 的值.

现在已经没办法从上面的图获得任何有用的线索了, 换个思路: 从答案出发找出线索来连接目前得到的结论.

是时候回头仔细看一下 $refract(I, N, eta)$ 的定义了:

#+begin_src c
  k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
  if (k < 0.0)
      R = genType(0.0);       // or genDType(0.0)
  else
      R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;
#+end_src

初看代码可能不知道 $k$ 的含义是什么, 相信我只要把 $eta$ 带入进去就明白了:

$k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I) = 1.0 - \frac{\sin^{2}\theta_{t}}{\sin^{2}\theta_{i}} * (1.0 - \cos^{2}\theta_{i}) = 1.0 - \frac{\sin^{2}\theta_{t}}{\sin^{2}\theta_{i}} * \sin^{2}\theta_{i} = \cos^{2}\theta_{t}$.

现在整个 $refract$ 的定义及其背后的含义已经全部解析完毕.

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/packUnorm.xhtml][函数 - packUnorm]] 和 [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml][函数 - unpackUnorm]]

这两个函数只是用来把数据打包和解包.

举个例子, 我们知道 =Fragment Shader= 里面的片元颜色是这么个结构: $(r, g, b, a)$, 每个分量的范围都是 $[0.0, 1.0]$.

但是在一些程序中的颜色结构中, 分量的范围就变成 $[0, 255]$, 比如浏览器中的 =#F2F1F0=, 这个其实就是 $242 \times 16^{4} + 241 \times 16^{2} + 240 \times 16^{0}$ 的 16 进制表示.

要完成从 $[0.0, 1.0]$ 到 $[0, 255]$ 的转换很简单, 针对分量进行这样的操作: $round(x * 255.0)$.

然而, 这样的话会很繁琐, 毕竟 =GLSL= 支持 =vec4=, 对一个 =vec4= 进行转换就得手写 4 条这样的操作,

因此, =GLSL= 提供了 $packUnorm$ 一套函数来减轻开发人员的负担, 另外还提供了 $unpackUnorm$ 一套函数来完成 "从 $[0, 255]$ 到 $[0.0, 1.0]$" 这样的逆操作.

这里就不再对函数的定义进行详细说明了, 写这个小节是因为初见该函数没了解到它是做什么的而已, 实际了解下来还是挺简单的.

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/modf.xhtml][函数 - modf]]

$modf(x, out\ i)$ 把浮点数 $x$ 分开整数和小数两部分, 整数部分(integer part)会储存在参数 $i$ 中, 小数部分(fractional part)则是作为函数的返回值.

#+begin_quote
不要和 $mod$ 函数搞混.
#+end_quote

#+BEGIN_SRC glsl
  float f;
  float i;

  f = modf(1.2, i);
  /* i = 1.0, f = 0.2 */

  vec2 fs;
  vec2 is;
  fs = modf(vec2(1.2, -3.4), is);
  /* fs = vec2(0.2, -0.4), is = ivec2(1.0, -3.0) */
#+END_SRC

*** [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/texture.xhtml][函数 - texture]]

$texture$ 函数从贴图 $tex$ 中获取指定纹理坐标 $texCoord$ 上的纹素(=texels=), 一般用法是 $texture(tex, texCoord)$.

#+begin_quote
贴图分 =1D=, =2D= 和 =3D= 贴图, 这里主要介绍 =2D= 贴图.
#+end_quote

现在有一个问题: 如果 $texCoord$ 的分量超出 $[0.0, 1.0]$ 的范围怎么办? 这就涉及贴图的一个属性 - 纹理环绕 (=texture wrapping=).

纹理环绕是指纹理坐标 $texCoord$ 的分量超出范围 $[0.0, 1.0]$ 时该如何处理这些超出的坐标, =OpenGL= 里面有 =4= 种选项给开发者进行选择:

1. =GL_REPEAT=: 默认模式, 使得贴图重复, 调用时效果如下:

   #+BEGIN_SRC glsl
     uniform sampler2D tex;
     uniform vec2 texCoord;

     // vec4 texel = texture(tex, texCoord); 等同以下
     vec4 texel = texture(tex, fract(texCoord));
   #+END_SRC

2. =GL_MIRRORED_REPEAT=: 类似 =GL_REPEAT=, 只不过是镜像重复, 调用时效果如下:

   #+BEGIN_SRC glsl
     uniform sampler2D tex;
     uniform vec2 texCoord;

     // vec4 texel = texture(tex, texCoord); 等同以下
     vec2 is;
     vec2 fs = modf(texCoord, is);
     float texCoordS = mod(is.x, 2) == 0 ? fs.s : 1 - fs.s;
     float texCoordT = mod(is.y, 2) == 0 ? fs.t : 1 - fs.t;
     vec4 texel = texture(tex, vec2(texCoordS, texCoordT));
   #+END_SRC

   也就是 =texCoord= 分量的整数 $i$ 部分为偶数时, 分量就被会被它自己的小数部分 $f$ 取代; 如果分量的整数部分 $i$ 为奇数, 分量就会被 $1 - f$ 取代.

3. =GL_CLAMP_TO_EDGE=: 把贴图坐标的分量限定在 $[0.0, 1.0]$ 的范围内, 调用效果如下:

   #+BEGIN_SRC glsl
     uniform sampler2D tex;
     uniform vec2 texCoord;

     // vec4 texel = texture(tex, texCoord); 等同以下
     vec4 texel = texture(tex, clamp(texCoord, 0.0, 1.0));
   #+END_SRC

4. =GL_CLAMP_TO_BORDER=: 类似 =GL_CLAMP_TO_EDGE=, 但当根据超出范围的贴图坐标获取纹素时, 该纹素的颜色为用户指定颜色,

   这个颜色要通过 =OpenGL= 的 =API= 去设置 =GL_TEXTURE_BORDER_COLOR= 这个贴图属性的值来进行指定, 调用效果如下:

   #+BEGIN_SRC glsl
     uniform sampler2D tex;
     uniform vec2 texCoord;
     uniform vec4 borderColor;       // 用户指定的颜色

     // vec4 texel = texture(tex, texCoord); 等同以下
     vec4 texel = (texCoord.s > 1 || texCoord.s < 0 || texCoord.t > 1 || texCoord.t < 0) ? borderColor : texture(tex, clamp(texCoord, 0.0, 1.0));
   #+END_SRC


#+caption: 贴图环绕的 4 种选择 (图片来自 LearnOpenGL)
[[../../../files/texture_wrapping.png]]

** 常用自定义函数
*** remap 函数

#+begin_quote
从这里开始会介绍一下 =GLSL= 没有内置但又常用的函数.
#+end_quote

$remap(value, low1, high1, low2, high2)$: 对 $value$ 从 $[low1, high1]$ 映射到 $[low2, high2]$ 上, 并返回经过重新映射后的 $value$.

因此, 函数的定义是: $low2 + \frac{value - low1}{high1 - low1} \times (high2 - low2)$.

*** 随机函数

#+begin_quote
参考资料如下:

https://thebookofshaders.com/10/

https://iquilezles.org/articles/sfrand/

在讨论随机函数前先了解一下什么是随机, 人们口中的随机一般是指数学中定义的随机: 不可预测(=unpredictable=)和不可重现.

可预测就意味着可以确定一个事件必定发生或不发生, 可重现意味着可以通过固定方法使得一个事件发生或不发生.

而计算机中的代码是死板且可以预测的, 那又是如何产生随机数呢?

对于计算机, 有两种随机, 分别如下:

*确定性随机 (=deterministic random=)*

用算法生成一个数列, 该数列的特性接近随机数列的特性, 然后根据参数从该数列获取一个数字作为随机数, 通过相同参数可以获得相同随机数,

这种随机可以通过算法和参数来预测随机数, 因此也被称为伪随机 (=pseudo-random=).

*非确定性随机 (=non-deterministic random=)*

这种随机是不可预测和不可重现的, 可以被认为是真随机(=truely random=), 它的随机数不是通过算法来生成的, 而是来源于物理现象, 比如电子噪声, 量子效应, 大气噪声和用户输入等等.

=Linux= 的 [[https://en.wikipedia.org/wiki//dev/random][/dev/random]] 就是从环境噪声获取随机数.

若感兴趣, 可以看一下这个[[https://www.bilibili.com/video/BV1rA411Z7eP/?spm_id_from=333.337.search-card.all.click&vd_source=9fdcd332c2d3e867a2fe257ff4f28e30][视频: 计算机如何生成(伪)随机]].
#+end_quote

=Shader= 里用的是确定性随机函数, 需要开发人员自己实现的, 通常是使用周期函数来实现, 比如 $\sin$, 并把它的值域限定在 $[0, 1]$ 上.

#+begin_src glsl
  float rand = fract(sin(x));  // 限制在 [0, 1] 的范围内
#+end_src

#+attr_html: :width 504px
[[../../../files/fract-sin.png]]

你可能觉得这个随机数看作不够随机, 那就让它们看起来更加混乱吧.

#+BEGIN_SRC glsl
  float rand = fract(sin(x) * 10000.0);
#+END_SRC

#+attr_html: :width 504px
[[../../../files/fract-sin-100000.png]]

即便它看着混乱, 但仍是确定性随机.

#+begin_quote
随机数的生成并不只有一种算法, 你可以充分使用自己的知识去创建随机函数.

比如, [[https://iquilezles.org/][Iquilezles]] 提供了一个[[https://iquilezles.org/articles/sfrand/][更好的随机数方案]], 有兴趣的可以看一下.
#+end_quote

一般来说, 编程语言中提供的随机函数都是像这个 $rand$ 一样服从均匀分布的.

在实际开发中偶尔想让随机函数服从特定分布, 想要控制随机数的分布, 根据均匀分布的普遍性, 可以对服从均匀分布的随机数 $X$ 进行变换成服从其它分布的随机数 $Y$, 这需要掌握一定的概率论知识, 这里不详细展开了.

另外, =Pixelero= 也发布了一片[[https://pixelero.wordpress.com/2008/04/24/various-functions-and-various-distributions-with-mathrandom/][文章]]来介绍服从一些分布的随机数函数.

**** 高维随机函数

在 =Shader= 开发中通常需要根据纹理坐标来生成随机数, 而上面介绍的 $rand$ 是一个 =1D= 随机函数, 并不能很好地满足需求, 这需要 =2D= 随机函数.

同理, 也存在 =3D= 和 =4D= 甚至更高维的随机函数.

假设高维随机函数 $f$ 是一个以 $n$ 维向量 $v \in \mathbb{R}^n$ 作为输入, 以标量 $r$ 作为输出: $r = f(v)$.

其实高维随机函数的实现思路其实和 =1D= 随机函数差不多, 只不过要对 $v$ 做计算, 其计算结果是一个标量 $i$ , 最后用 $i$ 作为 =1D= 随机函数 $g$ 的输入得出 $r = g(i)$.

把向量转换成标量的话, 首先想到的是点积运算, 来看一个例子:

#+BEGIN_SRC glsl
  float rand(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
  }
#+END_SRC

**** 向量函数形式的随机函数

这种随机函数是用来生成向量的, 在 =Shader= 开发中通常是用来根据坐标计算出对应片元的颜色, 这种函数既可以用标量, 也可以用向量作为输入, 最后以向量作为输出.

比如下面这个例子, 以 =3D= 向量作为输入和输出:

#+BEGIN_SRC glsl
  vec3 rand(vec3 v) {
    vec3 p = vec3(dot(v, vec3(127.1, 311.7, 74.7)), dot(v, vec3(269.5, 183.3, 246.1)), dot(v, vec3(113.5, 271.9, 124.6)));
    return fract(sin(p) * 43758.5453123)
  }
#+END_SRC

**** $\mathrm{fract(sin(dot(x)))}$ 方法的缺陷

在 =WebGL= 或 =OpenGL= 中, $\sin$ 的实现取决于机器, 这导致了同一段 =Shader= 代码在不同平台上的效果不一样.

=Iquilezles= 后来总结了一些算法来规避这个问题:

#+BEGIN_SRC glsl
  // https://www.shadertoy.com/view/llGSzw
  float hash11 ( uint n ) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;
    return float( n & uint(0x7fffffffU))/float(0x7fffffff);
  }

  vec3 hash13( uint n )
  {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;
    uvec3 k = n * uvec3(n,n*16807U,n*48271U);
    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);
  }

  // https://www.shadertoy.com/view/4tXyWN
  uint hash21( uvec2 p )
  {
    p *= uvec2(73333,7777);
    p ^= (uvec2(3333777777)>>(p>>28));
    uint n = p.x*p.y;
    return float(n^(n>>15)) * (1.0 / float(0xffffffffU));
  }

  // https://www.shadertoy.com/view/XlXcW4
  vec3 hash33( uvec3 p ) {
    const uint k = 1103515245U;    // GLIB C
    //const uint k = 134775813U;   // Delphi and Turbo Pascal
    //const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)
    //const uint k = 1664525U;     // Numerical Recipes
    p = ((p>>8U)^p.yzx) * k;
    p = ((p>>8U)^p.yzx) * k;
    p = ((x>>8U)^p.yzx) * k;

    return vec3(x) * (1.0 / float(0xffffffffU));
  }
#+END_SRC

*** 噪声函数

噪声 (=noise=) 也是一种随机, 但相比一般的随机, 噪声的过度显得更加平滑, 更自然, 适合用来生成丰富的视觉效果, 因此, 噪声也被成为平滑随机性 (=smooth randomness=).

先来感受一下, 随机函数和噪音函数之间的区别, 以下是分别是随机函数 $rand1(x)$, $rand2(x)$ 和噪声函数 $noise(x)$ 的 =Maxima= 的实现以及对应的函数图像:

#+BEGIN_SRC maxima
  fract(x) := x - floor(x)$
  mix(x, y, a) := x * (1 - a) + y * a$
  smoothstep(l, u, x) := block(
    t: min(max((x - l) / (u - l), 0.0), 1.0),
    return (t * t * (3 - 2 * t))
    )$

  rand(x) := fract(sin(x))$

  /* 随机算法以及它们的图像 */
  rand1(x) := rand(floor(x))$
  rand2(x) := mix(rand(floor(x)), rand(floor(x) + 1), fract(x))$
  noise(x) := mix(rand(floor(x)), rand(floor(x) + 1), smoothstep(0, 1, fract(x)))$

  plot2d([rand1(x), rand2(x), noise(x)], [x, -4, 4], [color, red, blue, green], [legend, "rand1", "rand2", "noise"])$
#+END_SRC

#+attr_html: :width 504px
[[../../../files/noise-functions.png]]

正如图片所示, 令 $z = floor(x)$, 从 $rand1$ 到 $rand2$, 为随机数 $rand1(z)$ 和 $rand1(z + 1.0)$ 之间引入了线性插值, 从 $rand2$ 到 $noise$, 为随机数 $rand1(z)$ 和 $rand1(z + 1.0)$ 之间引入了非线性插值, 函数图像变得越来越平滑.

$noise$ 的算法可以看作是在一条线上的两个点之间进行插值, 这个点是根据参数 $x$ 来决定的, 以 $[floor(x), floor(x) + 1]$ 作为插值范围来保证变化间隔为 1, 以 $x$ 的小数部分 $fract(x)$ 作为插值参数, 从而得出噪声值.

[[../../../files/value-noise-1d-lerp.png]]

#+begin_quote
在实际应用中, 可以根据自身需求替换插值方法, 比如想换函数 $g$ 来进行插值: $f(a, b, t) = (1 - g(t)) \cdot a - g(t) \cdot b$,

而 $noise$ 函数里面的 $g(t) = smoothstep(0, 1, t)$;

当 $g(t) = \frac{1 - \cos(\pi t)}{2}$ 时, $f$ 被叫做余弦插值 (=Cosine Interpolation=);

另外一个比较有名的插值函数是五次插值曲线: $g(t) = 6t^5 - 15t^4 + 10t^3$, 是 $smoothstep$ 的改进替代.
#+end_quote

=GLSL= 也提供了内置的噪音函数: [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/noise.xhtml][noise]], 但对于创意工作而言, 这个内置函数并不能完全满足创作者的需求, 所以基本上都是自己实现噪声函数.

噪声算法有很多, 很多艺术创作者会根据需求来选择合适的噪声算法来进行艺术创作, 比如柏林噪声算法(=Perlin Noise Algorithm=),

接下来会介绍三种比较基础的噪声算法: 值噪声, 梯度噪声以及单行噪声.

**** 值噪声

如上面的 =1D= 噪声所示, 可以看作是一线条上 $2^1$ 个点对应的随机数之间的插值, 而 =2D= 噪声可以看作是一个矩形上 $2^2$ 个角对应的随机数之间的插值, 如此类推, =3D= 噪声可以看作立方体上 $2^3$ 个角对应的随机数之间的插值.

这种对随机数进行插值得到噪声被称为值噪声 (=value noise=).

#+begin_quote

*双线性插值法 (=bilinear interpolation=)*

根据平面的 4 个角进行插值的技巧需要参考双线性插值法, 这种技巧也可以解决贴图在缩放显示时出现的纹理不平滑问题,

#+attr_html: :width 504px
[[../../../files/bilinear-texture-weights.png]]

如图所示, 想要计算出平面中 $C$ 的坐标, 可先从 $X$ 轴方向($TL \rightarrow TR$)进行插值,

首先计算出 $CT = (1 - f_x) \cdot TL + f_x \cdot TR$,

再计算出 $CB = (1 - f_x) \cdot BL + f_x \cdot BR$,

最后从 $Y$ 轴方向进行插值计算出 $C = (1 - f_y) \cdot CT + f_y \cdot CB$.

或者也可以先从 $Y$ 轴方向($TL \rightarrow BL$)进行插值, 最后再从 $X$ 轴方向进行插值, 结果都一样, 就不赘述了.

其 =GLSL= 如下:

#+begin_src glsl
  float ct = mix(tl, tr, fx);
  float cb = mix(bl, br, fx);
  float c = mix(ct, cb, fy);

  // 有时候你可能看到的插值实现可能是下面这样的
  /*
    ct = tl * (1 - fx) + tr * fx
    cb = bl * (1 - fx) + br * fx
    c = [tl * (1 - fx) + tr * fx] * (1 - fy) + [bl * (1 - fx) + br * fx] * fy
      = [tl * (1 - fx) + tr * fx] - [tl * (1 - fx) + tr * fx] * fy + [bl * (1 - fx) + br * fx] * fy
      = [tl * (1 - fx) + tr * fx] + [ bl * (1 - fx) + br * fx - tl * (1 - fx) - tr * fx ] * fy
      = [tl * (1 - fx) + tr * fx] + [(bl - tl) * (1 - fx) + (br - tr) * fx] * fy
      = mix(tl, tr, fx) + [(bl - tl) * (1 - fx) + (br - tr) * fx] * fy
   ,*/
#+end_src

*三线性插值法 (=trilinear interpolation=)*

根据立方体的 8 个角进行插值的技巧需要参考三线性插值法, 这种方法可以看作两个对立面的双线性插值随后加上一个线性插值.

#+attr_html: :width 504px
[[../../../files/trilinear-interpolation.png]]

需要注意的是, 这张图的 $Y$ 轴方向是 $c000 \rightarrow c010$, 其三线性插值的 =GLSL= 实现如下:

#+begin_src glsl
  // 平面 c000 - c100 - c110 - c010 的双线性插值
  float a = mix(c010, c110, tx);
  float b = mix(c000, c110, tx);
  float e = mix(b, a, ty);

  // 平面 c001 - c101 - c111 - c011 的双线性插值
  float c = mix(c001, c111, tx);
  float d = mix(c001, c101, tx);
  float f = mix(d, c, ty);

  // 对 e 和 f 进行线性插值
  float g = mix(e, f, tz);
#+end_src
#+end_quote

以 =2D= 噪声为例, 首先, 根据纹理坐标 $st$ 来确定其所处网格的 4 个角的坐标:

$(floor(st.x), floor(st.y))$

$(floor(st.x) + 1.0, floor(st.y))$

$(floor(st.x), floor(st.y) + 1.0)$

$(floor(st.x) + 1.0, floor(st.y) + 1.0)$

#+begin_quote
另外, $(fract(st.x), fract(st.y))$ 就是 $st$ 相对于网格的坐标.
#+end_quote

然后, 以这 4 个坐标作为随机函数的参数得到 4 个随机值,

最后, 根据这 4 个随机值进行双线性插值得到 $st$ 所对应的随机值.

#+begin_src glsl
  // 来自 https://thebookofshaders.com/11/
  float rand(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
  }

  float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile which is created according to st.
    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));

    // Smooth Interpolation

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);

    // Mix 4 coorners percentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
  }

  void main() {
    vec2 st = gl_FragCoord.xy/u_resolution.xy;

    // Scale the coordinate system to see
    // some noise in action
    vec2 pos = vec2(st * 5.0);

    // Use the noise function
    float n = noise(pos);

    gl_FragColor = vec4(vec3(n), 1.0);
  }
#+end_src

其效果如下:

#+caption: 2D 值噪声的效果
[[../../../files/2d-value-noise-stX5.png]]

# https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83

# 什么是随机: https://www.bilibili.com/video/BV1rA411Z7eP/?spm_id_from=333.337.search-card.all.click&vd_source=9fdcd332c2d3e867a2fe257ff4f28e30

# noise functions
# https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
# hash11: https://www.shadertoy.com/view/llGSzw

**** 梯度噪声

一般来说, 值噪声的效果就如上图所示的那样, 看起来一块一块的, 为了消除块状效果, =Ken Perlin= 在 =1985= 年开发出了另外一种噪声算法, 得到噪声的叫梯度噪声 (=Gradient Noise=), 这个算法也就是人们熟知的柏林函数.

和值噪声算法的区别在于, 梯度噪声的随机函数以方向(=vec2/vec3/vec4=)作为输出, 值噪声的随机函数以值(=float=)作为输出.

和值噪声的生成类似, 以 =2D= 梯度噪声为例, 通过随机函数为 4 个角生成梯度向量(需要归一化), 再通过点积运算把它们转换成 4 个标量, 之后的过程就与值噪声的计算一样.

在使用点积把梯度向量 $\nabla$ 转换成标量时, 还需要为每个角 $p$ 计算出它的角指向(也称为距离向量), 假设 $o$ 是网格内的坐标, 那么角指向为 $v = (o.x - p.x, o.y - p.y)$, 最后计算角指向和梯度向量之间的点积 $v \cdot \nabla$,

这个点积就是角指向 $\vec{op}$ 在梯度向量 $\nabla$ 的投影, 也就是 $\vec{op}$ 在 $\nabla$ 方向上的贡献值.

如下图所示, 绿色箭头为黄格字的梯度向量 $\nabla$, 黄点为 $o$, 蓝色箭头为角指向 $v$.

#+attr_html: :width 504px
[[../../../files/perlin-noise.png]]

按照该思路, 下面为 =GLSL= 的实现:

#+BEGIN_SRC glsl
  // 2D 向量函数形式的随机函数
  vec2 rand(vec2 st){
      st = vec2(dot(st, vec2(127.1,311.7)),
                dot(st, vec2(269.5,183.3)));
      return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);
      // 归一化
  }

  // 类似前面 2D 噪声的生成, 但是 4 个角的随机值需要一番点积运算
  float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    // vec2 u = f * f * (3.0 - 2.0 * f);
    vec2 u = smoothstep(vec2(0.0), vec2(1.0), f);

    vec2 a = rand(i);
    vec2 va = f - vec2(0.0, 0.0);
    vec2 b = rand(i + vec2(1.0, 0.0));
    vec2 vb = f - vec2(1.0, 0.0);
    vec2 c = rand(i + vec2(0.0, 1.0));
    vec2 vc = f - vec2(0.0, 1.0);
    vec2 d = rand(i + vec2(1.0, 1.0));
    vec2 vd = f - vec2(1.0, 1.0);

    float dotA = dot(a, va);
    float dotB = dot(b, vb);
    float dotC = dot(c, vc);
    float dotD = dot(d, vd);

    float ab = mix(dotA, dotB, u.x);
    float cd = mix(dotC, dotD, u.x);

    return mix(ab, cd, u.y);
  }
#+END_SRC

#+begin_quote
梯度的全称是梯度向量(=gradient vector=), 源于微积分中向量函数中的概念, 用来表示多元函数 $f$ 在各个分量上的变化率,

这个变化率就是梯度向量, 以二维向量为例: $\nabla f(x, y) = (\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y})$.

梯度向量 $\nabla f(x, y)$ 表示在所有方向中使得 $f$ 的方向导数最大的那一个方向, 而 $|\nabla f(x, y)|$ 表示最大方向导数的变化率大小.

方向导数 $D_u f(x, y)$ 表示 $f$ 在某点 $(x, y)$ 上往某方向 $u$ 的变化率:

$D_u f(x, y) = \nabla f(x, y) \cdot u = |\nabla f(x, y)||u| \cos_{\theta}$, 其中 $\theta$ 为 $\nabla f(x, y)$ 和 $u$ 之间的夹角.

当 $\theta = 0$ 时, 换而言之当 $\nabla f(x, y)$ 和 $u$ 方向相同时, $D_u f(x, y)$ 为最大.
#+end_quote

那么 =1D= 的梯度噪声呢? 一维空间是一条直线, 可以把直线上的点 $p$ (=p= 是标量)看作一个一维向量 $(p)$, 一维向量之间的点积就是标量之间的乘积,

根据这些信息, 就可以实现 =1D= 梯度噪声了:

#+begin_src glsl
  float rand(float p) {
    return fract(sin(p) * 43758.5453123);
  }

  float noise(float p) {
    float i = floor(p);
    float f = fract(p);
    float u = smoothstep(0.0, 1.0, f);

    // 这里的 rand(i) * 2.0 - 1.0 是要对梯度 rand(i) 进行归一化使其范围在 [-1, 1] 之间
    float a = rand(i) * 2.0 - 1.0;
    float va = f - 0.0;
    float b = rand(i + 1.0) * 2.0 - 1.0;
    float vb = f - 1.0;

    float dotA = a * va;
    float dotB = b * vb;

    return 2.4 * mix(dotA, dotB, u);
  }
#+end_src

这里给出 =1D= 梯度噪声的实现的目的是, 解释为什么梯度噪声可以消除块状, 具体解释可以参考 [[https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise.html][ScratchAPixel - Perlin Noise]] 的 =Why Is Perlin/Gradient Noise Better Than Value Noise= 部分.

首先要理解块状效果的成因, 这需要理解高频(=higher frequencies=)和低频(=lower frequencies=)的概念:

我们把连续红点之间的变化作为对比, 变化相对大的叫做高频, 变化相对小的叫做低频.

#+caption: 理想情况: 随机值关于 $x$ 轴良好地分布, 使得噪声函数的振荡在频率上是成规律的.
[[../../../files/noise-value-vs-perlin1.png]]

#+caption: 最坏情况: 一些随机值在 $x$ 轴的一定范围内连续出现多次, 也就是说噪声函数的频率分布是不成规律的.
[[../../../files/noise-value-vs-perlin2.png]]

理想的噪声函数是以高频为主, 所以它看起来随机且局部变化平滑, 但总体上呈现出相当均匀的外观(=homogeneous look=), 也就是由相似频率构成.

值噪声则是由高频和低频构成, 也就是类似上面最坏情况, 低频部分就是方块效果的成因, 在低频区域内的噪声大小非常接近, 高频和低频的过度区域则把大小接近的噪声给分割开了, 导致了块状效果.

在 =1D= 噪声函数中, 梯度噪声算法很好控制着 =1D= 噪声函数图像的形状, 并且让形状成规律.

#+caption: 1D梯度噪声的函数图像, 梯度向量控制着噪声函数形状 (图片来源: Stefan Gustavson - Simplex Noise Demystified)
[[../../../files/1d-perlin-noise-func-graph.png]]

这里借助 =1D= 梯度函数的实现来介绍一下它是如何控制函数图像的,

首先, $a$ 和 $b$ 分别是 $p$ 和 $p + 1$ 上的梯度: $\begin{equation*} \begin{cases} a = rand(floor(p)) \times 2 - 1 \\ b = rand(floor(p) + 1) \times 2 - 1 \end{cases} \end{equation*}$,

$f = \frac{p - floor(p)}{floor(p) + 1 - floor(p)} = p - floor(p) = fract(p)$, $f \in [0, 1]$.

从 $floor(p)$ 到 $p$ 的向量为 $f$, 从 $floor(p) + 1$ 到 $p$ 的向量为 $f - 1$,

所以在 $floor(p)$ 上的噪声值为 $a \cdot f$, 在 $floor(p) + 1$ 上的噪声值为 $b \cdot (f - 1)$,

以下是根据两个噪声值进行插值来得出 $p$ 上的噪声值的过程:

$u = 3f^2 - 2f^3$, 由于 $f \in [0, 1]$, 所以 $u \in [0, 1]$,

设 $P$ 是以 $f$ 为参数的噪声函数, 那么其定义为:

$\begin{equation*}\begin{aligned} P(f) &= a \cdot f \cdot (1 - u) + b \cdot (f - 1) \cdot u \\ &= a \cdot f + [(b - a) \cdot f - b] \cdot u \\ &= a \cdot f + (b - a) \cdot (3 f^3 - 2 f^4) - b \cdot (3 f^2 - 2 f^3) \end{aligned}\end{equation*}$

其一阶导数为: $P^{'}(f) = a + (b - a) \cdot (9 f^2 - 8 f^3) - b \cdot (6 f - 6 f^2)$.

根据函数定义, 函数图像在整数点上的值是 $P(0) = P(1) = 0$.

根据导数定义, 函数图像的整数点上的斜率就是它们对应的梯度: $P^{'}(0) = a$ 以及 $P^{'}(1) = b$.

由于 $P$ 是一个一元四次函数且具备周期性, 因此函数图由多个抛物线组成, 使得梯度噪声相比值噪声减少低频, 消除了块状效果.

#+begin_quote
一元偶次函数的图像就是抛物线.
#+end_quote

**** 单形噪声

#+begin_quote
以下内容参考以下论文进行总结:

[[../../../files/simplexnoise.pdf][Stefan Gustavson - Simplex Noise Demystified]]

[[../../../files/efficient-computational-noise-in-GLSL.pdf][Ian McEwan, Stefan Gustavson - Efficient Computational Noise In GLSL, 2012]]

[[../../../files/simplex_noise_skew_factor.pdf][Kristian Nielsen - Understanding skew factors in Simplex/Improved Perlin Noise, 2015]]

[[../../../files/tiling-simplex-noise-and-flow-noise-in-two-and-three-dimensions.pdf][Ian McEwan, Stefan Gustavson  - Tiling Simplex Noise and Flow Noise in Two and Three Dimensions, 2022]]
#+end_quote

在 =2001= 年, =Ken Perlin= 开发出了另一种名为单形噪声(=simplex noise=)的噪声算法, 相比前面的算法, 单形噪声算法有以下优点:

- 拥有更低的计算复杂性和更少的乘法运算
- 能以低计算成本拓展到更高维度的噪声
- 没有明显方向性的人工痕迹
- 拥有计算简单且明确的连续梯度
- 在硬件上更容易实现


***** 单形

在可视化空间时, 会用选择一种几何图形来重复地对空间进行填充, 或说, 选择一种几何图形对空间进行细分(=tesselation=), 从而形成坐标网格.

#+begin_quote
为了方便说明, 这里把正交空间上的网格叫做正交网格, 单形空间上的网格叫做单形网格.
#+end_quote

*在细分一些空间时, 几何图形的选择会有很多种, 而几何结构最简单的那一种选择就叫做单形(=simplex shape=), 也可以理解为空间的单位.*

一维空间的单形是等长的线段(一维空间只有这种选择).

对于二维空间, 通常会用正方形对它进行细分, 但正方形本身就能够划分成两个三角形.

因此, 三角形才是二维空间的单形, 二维空间的最优单形是等边三角形, 这意味着要把正方形沿着主对角线 $y = x$ 错切成菱形, 使得划分所得的三角形等边, 2 个等边三角形可以组合成一个菱形.

#+attr_html: :width 504px
#+caption: 等边三角形作为单形, 填充二维空间
[[../../../files/2d-simplex-shape.png]]

对于三维空间, 它的单形是四面体(=tetrahedron=), 正式来说应该是正四面体, 可通过把对立方体沿着主对角线 $x = y = z$ 进行错切, 再根据对角线划分得到 6 个正四面体.

#+attr_html: :width 504px
#+caption: 正四面体作为单形, 填充三维空间
[[../../../files/3d-simplex-shape.png]]

对于四维空间, 它的单形很难可视化, 不过它有 5 个角, 并且 24 个单形可以组合成一个错切的四维超立方体(=hypercube=).

总的来说, $N$ 维空间的单形有 $N + 1$ 个角, $N!$ 个单形可以填充完一个有着 $2^{N}$ 个角的错切 $N$ 维超立方体.

在传统噪声算法中, 随着走向更高维度, 为每个角计算随机梯度是一个复杂度为 $O(2^{N})$ 的问题,

如果是对单形的每个角度计算随机梯度, 那么计算复杂度会变成 $O(N^2)$, 这就是单形的好处.

***** 用求和替代插值

随着维度走高, 传统噪声函数除了计算复杂度变高外, 噪声函数的解析导数也会越来越难求解, 噪声函数的解析导数有很多用处:

包括凹凸贴图(=bump mapping=), 位移贴图(=displacement mapping=), 解析抗锯齿(=analytical antialiasing=)以及使用旋度噪声(=curl nosie=)的粒子动画.

为了解决这个问题, 单形噪声不再像柏林噪声那样根据两角的贡献值进行插值, 而是对每个角的贡献值进行求和作为噪声值.

#+attr_html: :width 504px
[[../../../files/2d-simplex-summation-2.png]]

在单形噪声中, 角的贡献值的计算过程如下:

$[\max(0, r^2 - |\vec{d}|^2)]^4 \times \vec{d} \cdot \vec{g}$, 其中 $\vec{d}$ 是角指向, $\vec{g}$ 是梯度值, $\max(0, r^2 - |\vec{d}|^2)$ 是衰减函数, $|\vec{d}|^2$ 是角指向的模长.

衰减函数让贡献值随着点与角之间的距离增大而减少, 通常 $r^2 = 0.5$, 也就是以角为圆心且半径为 $\sqrt{0.5} \approx 0.7$ 的圆,

一般来说不会让这个圆覆盖同一个单形里的其它单形角, 因此, 半径 $r$ 应该设定为等边三角形的高, 而不是等边三角形的边长.

在后面的实现二维单形噪声时会详细说明为什么是 $r^2 = 0.5$.

#+attr_html: :width 504px
[[../../../files/2d-simplex-summation.png]]

***** 决定点所处的单形, 并且决定角的遍历顺序

在传统噪声算法中需要判断点处于哪个网格中, 在单形噪声算法中则需要判断点处于哪个单形中.

二维空间的单行是由菱形划分的等边三角形, 分上三角形和下三角形, 判断点在那个单形也就是判断它在上三角形还是下三角形.

#+attr_html: :width 504px
[[../../../files/2d-simplex-selecting-traversing-order.png]]

在二维空间上, 如果点 $(x ,y)$ 满足 $x \gt y$, 那么点处在下三角形中; 反之, 点处在上三角形中.

如果点处于下三角形中, 那么它的单形角的遍历顺序为 $(0, 0)$, $(1, 0)$ 和 $(1, 1)$.

如果点处于上三角形中, 那么它的单形角的遍历顺序为 $(0, 0)$, $(0, 1)$ 和 $(1, 1)$.

决定这个顺序很简单, 为了说明, 这里采用 $(i, j)$ 来作为单形的相对角坐标:

要对点 $(x, y)$ 的分量进行从大到小排序, 这个顺序决定了角相对坐标分量加 1 的顺序.

如果点的分量顺序是 $x \gt y$, 那么是对上一个角相对坐标 $a$ 的 $i$ 分量先加 1, 得到角相对坐标 $b$, 然后相对 $b$ 的 $j$ 分量加 1, 得到角相对坐标 $c$:

$a = (i, j), b = (i + 1, j), c = (i + 1, j + 1)$.

如果点的分量顺序是 $y \gt z$, 那么是对上一个角相对坐标 $a$ 的 $j$ 分量先加 1, 得到角相对坐标 $b$, 然后相对 $b$ 的 $i$ 分量加 1, 得到角相对坐标 $c$:

$a = (i, j), b = (i, j + 1), c = (i + 1, j + 1)$.

对于更高空间的点 $(x, y, \dots)$ 和角相对坐标 $(x, y, \dots)$ 同理.

下图是三维空间中判断所处单形的方法.

#+attr_html: :width 504px
[[../../../files/3d-simplex-selecting-traversing-order.png]]

***** 2D 单形噪声实现

这里是解读 =Simplex Noise Demystified= 原文中 =2D Simplex Noise= 的实现:

#+begin_src java
  // 2D simplex noise
  public static double noise(double xin, double yin) {
      double n0, n1, n2; // Noise contributions from the three corners
      // Skew the input space to determine which simplex cell we're in
      final double F2 = 0.5*(Math.sqrt(3.0)-1.0);
      double s = (xin+yin)*F2; // Hairy factor for 2D
      int i = fastfloor(xin+s);
      int j = fastfloor(yin+s);

      final double G2 = (3.0-Math.sqrt(3.0))/6.0;
      double t = (i+j)*G2;
      double X0 = i-t; // Unskew the cell origin back to (x,y) space
      double Y0 = j-t;
      double x0 = xin-X0; // The x,y distances from the cell origin
      double y0 = yin-Y0;

      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {i1=0; j1=1;}
      // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6

      double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      double y1 = y0 - j1 + G2;
      double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      double y2 = y0 - 1.0 + 2.0 * G2;

      // Work out the hashed gradient indices of the three simplex corners
      int ii = i & 255;
      int jj = j & 255;
      int gi0 = perm[ii+perm[jj]] % 12;
      int gi1 = perm[ii+i1+perm[jj+j1]] % 12;
      int gi2 = perm[ii+1+perm[jj+1]] % 12;

      // Calculate the contribution from the three corners
      double t0 = 0.5 - x0*x0-y0*y0;
      if(t0<0) n0 = 0.0;
      else {
          t0 *= t0;
          n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
      }
      double t1 = 0.5 - x1*x1-y1*y1;
      if(t1<0) n1 = 0.0;
      else {
          t1 *= t1;
          n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
      }double t2 = 0.5 - x2*x2-y2*y2;
      if(t2<0) n2 = 0.0;
      else {
          t2 *= t2;
          n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
  }
#+end_src

这段代码远没有作者口中的那么可读, 很多细节都没有说明, 不过确实如他所说的很方便的移植到其它语言上.

不过也不能怪作者, 因为原本 =Ken Perlin= 的实现就很难理解了.

****** 把正交网格变换成单形网格

在实现单形噪声时, 可以 *自由* 选择使用任何单形网格, 这里选择了 =Simplex Noise Demystified= 里的单形网格, 如下图:

#+attr_html: :width 504px
[[../../../files/2d-simplex-grid-choice.png]]

这个单形网格是这么得到的:

把 $x$ 轴 $\left( \begin{array}{c} 1 \\ 0 \end{array} \right)$ 往逆时针方向旋转 $15^{\circ}$ 得到 $u$ 轴, 再把 $y$ 轴 $\left( \begin{array}{c} 0 \\ 1 \end{array} \right)$ 往顺时针方向选择 $15^{\circ}$ 得到 $v$ 轴, 使得 $u$ 和 $v$ 两轴之间的夹角为 $60^{\circ}$; 最后对 $u$ 和 $v$ 两轴进行统一伸缩.

这个结论是通过 =Simplex Noise Demystified= 以下代码反推的, 原文没有明确说明如何得到的单形网格, 因此, 结论可能有误.

#+BEGIN_SRC java
  final double F2 = 0.5*(Math.sqrt(3.0)-1.0);
  double s = (xin+yin)*F2; // Hairy factor for 2D
  int i = fastfloor(xin+s);
  int j = fastfloor(yin+s);

  final double G2 = (3.0-Math.sqrt(3.0))/6.0;
  double t = (i+j)*G2;
  double X0 = i-t; // Unskew the cell origin back to (x,y) space
  double Y0 = j-t;
  double x0 = xin-X0; // The x,y distances from the cell origin
  double y0 = yin-Y0;
#+END_SRC

为了方便讨论, 假设 $\vec{u} = \left( \begin{array}{c} a \\ c \end{array} \right)$ 和 $\vec{v} = \left( \begin{array}{c} b \\ d \end{array} \right)$ 就是旋转得到的 $u$ 和 $v$ 轴, 并且都是单位向量.

接下来计算得出 $u$ 和 $v$ 的矩阵:

$\cos \frac{\pi}{12} = \cos(\frac{\pi}{4} - \frac{\pi}{6}) = \cos\frac{\pi}{4} \cos\frac{\pi}{6} + \sin\frac{\pi}{4} \sin\frac{\pi}{6} = \frac{\sqrt{3}}{2 \sqrt{2}} + \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} + 1)$

$\cos (-\frac{\pi}{12}) = \cos(\frac{\pi}{6} - \frac{\pi}{4}) = \cos\frac{\pi}{6}\cos\frac{\pi}{4} + \sin\frac{\pi}{6}\sin\frac{\pi}{4} = \frac{\sqrt{3}}{2 \sqrt{2}} + \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} + 1)$

$\sin \frac{\pi}{12} = \sin(\frac{\pi}{4} - \frac{\pi}{6}) = \sin\frac{\pi}{4} \cos\frac{\pi}{6} - \cos\frac{\pi}{4} \sin\frac{\pi}{6} = \frac{\sqrt{3}}{2 \sqrt{2}} - \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} - 1)$

$\sin (-\frac{\pi}{12}) = \sin(\frac{\pi}{6} - \frac{\pi}{4}) = \sin\frac{\pi}{6} \cos\frac{\pi}{4} - \cos\frac{\pi}{6} \sin\frac{\pi}{4} = \frac{1}{2 \sqrt{2}} - \frac{\sqrt{3}}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(1 - \sqrt{3})$

$R(\frac{\pi}{12}) = \left( \begin{array}{c} \cos(\frac{\pi}{12}) & -\sin(\frac{\pi}{12}) \\ \sin(\frac{\pi}{12}) & \cos(\frac{\pi}{12}) \end{array} \right) = \frac{1}{2 \sqrt{2}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ \sqrt{3} - 1 & \sqrt{3} + 1 \end{array} \right)$

$R(-\frac{\pi}{12}) = R(\frac{\pi}{12})^{-1} = R(\frac{\pi}{12})^{T}$

$\vec{x}$ 轴变换得到 $\vec{u}$ 轴: $\vec{u} = R(\frac{\pi}{12}) \left( \begin{array}{c} 1 \\ 0 \end{array} \right) = \frac{1}{2\sqrt{2}}\left( \begin{array}{c} \sqrt{3} + 1 \\ \sqrt{3} - 1 \end{array} \right)$.

$\vec{y}$ 轴变换得到 $\vec{v}$ 轴: $\vec{v} = R(-\frac{\pi}{12}) \left( \begin{array}{c} 0 \\ 1 \end{array} \right) = \frac{1}{2\sqrt{2}} \left(\begin{array}{c} \sqrt{3} - 1 \\ \sqrt{3} + 1 \end{array} \right)$.

所以, 可以得出 $\begin{equation*} \begin{cases} a = d = \frac{1}{2\sqrt{2}}(\sqrt{3} + 1) \\ b = c = \frac{1}{2\sqrt{2}}(\sqrt{3} - 1) \\ \end{cases} \end{equation*}$, 这个变换可以用矩阵 $M_{r} = \frac{1}{2\sqrt{2}} \left( \begin{array}{c} \sqrt{3} + 1 & \sqrt{3} - 1 \\ \sqrt{3} - 1 & \sqrt{3} + 1 \end{array} \right)$ 表示.

仅凭这些是没办法看出与代码有什么关系, 这是因为文中代码做了性能优化, 非常感谢 =Kristian Nielse= 的贡献, 不然破头也想不出来.

先来看一下从 $xy$ 到 $uv$ 之间变换: $\begin{equation*} \begin{cases} u = ax + by \\ v = cx + dy \end{cases} \end{equation*}$, 因为 $a = d$ 并且 $b = c$, 所以该关系可以写成 $\begin{equation*} \begin{cases} u = ax + by \\ v = bx + ay \end{cases} \end{equation*}$.

整个变换需要 4 次乘法, 文中引入 "Fancy version of zero" 对变换进行重组得到: $\begin{equation*} \begin{cases} u = ax - bx + bx  + by = (a - b)x + b(x + y) \\ v = bx - by + by + ay = (a - b)y + b(x + y) \end{cases} \end{equation*}$,

其中 $b(x + y)$ 是重复运算, 可以减少 1 次乘法运算, 再使得 $a - b = 1$, 则可以再去掉 2 次乘法运算, 那么整个变换只需要 1 次乘法运算.

因为 $a - b = \frac{\sqrt{2}}{2}$, 所以只要让 $a$ 和 $b$ 同时除以 $\frac{\sqrt{2}}{2}$ 或乘以 $\sqrt{2}$ 即可, 对应了开头说的统一缩放变换,

可以用矩阵 $M_{s} = \sqrt{2} \left( \begin{array}{c} 1 & 0 \\ 0 & 1 \end{array} \right)$ 表示.

同时说明了最终的单形网格空间的基底向量并非单位向量: $\begin{equation*} \begin{cases} \sqrt{2} \times \frac{1}{2\sqrt{2}} = \frac{1}{2} \\ a_{1} = d_{1} = \frac{1}{2}(\sqrt{3} + 1) \\ b_{1} = c_{1} = \frac{1}{2}(\sqrt{3} - 1) \end{cases} \end{equation*}$.

再回过头来对比整个变换过程 $M = M_{s}M_{r}$ 和上面的代码, 其中 $b_{1}(x + y)$ 对应 $\mathrm{(xin + yin) * F2}$, 并且 $b_{1} = \mathrm{F2} = \frac{\sqrt{3} - 1}{2}$.

把单形网格空间上的点还原到正交网格上, 就是求 $M$ 的逆矩阵 $M^{-1} = M_{r}^{-1}M_{s}^{-1} = \left( \begin{array}{c} a_2 & b_2 \\ c_2 & d_2 \end{array} \right)$,

该变换也可以像上面那样写成: $\begin{equation*} \begin{cases} x = a_{2}u - b_{2}u + b_{2}u  + b_{2}v = (a_{2} - b_{2})u + b_{2}(u + v) \\ y = b_{2}u - b_{2}v + b_{2}v + a_{2}v = (a_{2} - b_{2})v + b_{2}(u + v) \end{cases} \end{equation*}$.

$M_{s}^{-1} = \frac{\sqrt{2}}{2} \left( \begin{array}{c} 1 & 0 \\ 0 & 1 \end{array} \right)$

$M_{r}^{-1} = \frac{1}{ad - bc} \left( \begin{array}{c} d & -c \\ -b & a \end{array} \right) = \frac{1}{\sqrt{6}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right)$

$M^{-1} = M_{r}^{-1}M_{s}^{-1} = \frac{\sqrt{2}}{2} \times \frac{1}{\sqrt{6}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right) = \frac{1}{2\sqrt{3}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right)$

所以, 得出 $\begin{equation*} \begin{cases} a_{2} = d_{2} = \frac{\sqrt{3} + 1}{2\sqrt{3}} = \frac{3 + \sqrt{3}}{6} \\ b_{2} = c_{2} = \frac{1 - \sqrt{3}}{2 \sqrt{3}} = \frac{\sqrt{3} - 3}{6} \end{cases} \end{equation*}$, 对比代码中的 $\mathrm{(i + j) * G2}$ 可发现 $-b_2 = \mathrm{G2} = \frac{3 - \sqrt{3}}{6}$,

为什么是转负, 因为代码的上下文是这样的:

#+begin_src java
  double t = (i + j) * G2;
  double X0 = i - t;
  double Y0 = j - t;
#+end_src

$i$ 和 $j$ 是单形中第一个被遍历到的角相对坐标 $(0, 0)$ 的分量, $(\mathrm{X0}, \mathrm{Y0})$ 是该单形角对应的正交网格空间坐标, $(\mathrm{x0}, \mathrm{y0})$ 是单形角正交网格空间中上的角指向, 同时是点在单形中的相对坐标.

到了这里就开始进入下一个环节了: 遍历单形角.

#+begin_quote
=Ian McEwan= 和 =Stefan Gustavson= 后来又写了 =Tiling Simplex Noise and Flow Noise in Two and Three Dimensons=, 里面采用了另一种方便计算的二维单形网格, 不过它的单形并非等边的等腰三角形:

#+attr_html: :width 504px
[[../../../files/2d-simplex-grid-efficient-choice.png]]

这个单形也提高了后续遍历单形角的计算效率.
#+end_quote

****** 遍历单形角并求和贡献值

#+begin_src java
  // For the 2D case, the simplex shape is an equilateral triangle.
  // Determine which simplex we are in.
  int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
  if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
  else {i1=0; j1=1;}
  // upper triangle, YX order: (0,0)->(0,1)->(1,1)
  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
  // c = (3-sqrt(3))/6
  double x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
  double y1 = y0 - j1 + G2;
  double x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
  double y2 = y0 - 1.0 + 2.0 * G2;
#+end_src

首先是判断点位于哪个单形中, 这里通过点 $\mathrm{(x0, y0)}$ 在正交网格空间的分量进行判断,

如果 $\mathrm{x0} \gt \mathrm{y0}$ 就是菱形的下三角形, 否则就是上三角形.

因为第二个单形角的相对坐标是 $(0, 1)$ 或 $(1, 0)$, 代码中的 $\mathrm{x1 = x0 - i1 + G2}$ 完整写法是 $\mathrm{x0 - [i1 - (1 + 0) \times G2]}$,

表示第二个单形角在正交网格空间上的角指向 $x$ 分量, 同理, $\mathrm{y1}$ 表示对应的 $y$ 分量.

因此, $(\mathrm{x1}, \mathrm{y1})$ 是第二个单形角在正交网格空间上的角指向.

第三个单形角的相对坐标是 $(1, 1)$ 代码中的 $\mathrm{x2 = x0 - 1 + 2 \times G2}$ 完整写法是 $\mathrm{x2 = x0 - [1 - (1 + 1) \times G2]}$,

其中 $\mathrm{1 - (1 + 1) \times G2}$ 是该单形角的 $x$ 分量, 所以 $\mathrm{x2}$ 表示第三个单形角在正交网格空间上的角指向 $x$ 分量; 同理, $\mathrm{y2}$ 是对应的 $y$ 分量.

因此, $(\mathrm{x2}, \mathrm{y2})$ 是第三个单形角在正交网格空间上的角指向.

在计算出所有角指向后, 可以开始计算每个角的贡献值了, 下面是原文中的参考代码:

#+begin_src java
  // Calculate the contribution from the three corners
  double t0 = 0.5 - x0*x0-y0*y0;
  if(t0<0) n0 = 0.0;
  else {
      t0 *= t0;
      n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
  }

  double t1 = 0.5 - x1*x1-y1*y1;
  if(t1<0) n1 = 0.0;
  else {
      t1 *= t1;
      n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
  }

  double t2 = 0.5 - x2*x2-y2*y2;
  if(t2<0) n2 = 0.0;
  else {
      t2 *= t2;
      n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
  }

  // Add contributions from each corner to get the final noise value.
  // The result is scaled to return values in the interval [-1,1].
  return 70.0 * (n0 + n1 + n2);
#+end_src

这里的 $\mathrm{n0}$ 正式第一个单形角的贡献值, $\mathrm{t0}$ 的 4 次方是衰减系数.

这个衰减系数是用在正交网格空间上的, 正如之前所说的, 衰减函数也代表着一个圆, 它半径为 $r = \sqrt{0.5}$.

这个值是如何得到的呢?

首先在单形网格上求得第一个单形角到它对面边的垂直线, 由于单形是等边三角形, 所以垂直线与对面边的交点正好是对面边的中点, 这样可以确定该边上中点的相对坐标为 $(1, \frac{1}{2})$ 或 $(\frac{1}{2}, 1)$.

#+begin_quote
以下三角形为例, 从第一个单形角开始, 往 $\vec{u}$ 方向增加一个单位, 往 $\vec{v}$ 方向增加 $\frac{1}{2}$ 个单位, 最终到达的角相对坐标为 $(1, \frac{1}{2})$.

如果是上三角形, 最终到达的角相对坐标为 $(\frac{1}{2}, 1)$. 不管哪种情况, 都不影响后续的计算.

这里以第一个单形角对面边的中点作为例子, 是因为第一个单形角的相对坐标为 $(0, 0)$, 该边中点 $m_{uv}$ 等于垂直线的向量 $\vec{m_{uv}} = m_{uv} - (0, 0)$, 垂直线的长度等于 $|m_{uv}|$.
#+end_quote

这里以下三角形为例, 中点为 $m_{uv} = (1, \frac{1}{2})$, 接下来把他转换到正交网格空间上, 得到点 $m_{xy}$:

$(1 + \frac{1}{2}) \times \mathrm{G2} = \frac{3}{2} \times \frac{3 - \sqrt{3}}{6} = \frac{3 - \sqrt{3}}{4}$

$m_{xy} = (1 - \frac{3 - \sqrt{3}}{4}, \frac{1}{2} - \frac{3 - \sqrt{3}}{4}) = (\frac{1 + \sqrt{3}}{4}, \frac{\sqrt{3} - 1}{4})$

最后得到它模长的平方: $|m_{xy}|^2 = (\frac{1}{4})^2 [(\sqrt{3} + 1)^2 + (\sqrt{3} - 1)^2] = \frac{1}{2}$, 正好就是 $r^2 = 0.5 = \frac{1}{2}$.

所以, $r^2 = 0.5$ 就是单形网格上等边三角形的高在正交网格空间上的长度的平方.

$\mathrm{grad3[gi0]}$ 是从预计算好的梯度表格中获取梯度:

#+BEGIN_SRC java
  int grad3[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},
                   {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},
                   {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};
#+END_SRC

原文中的二维单形噪声的梯度是三维向量, 而我们在实现时可以完全参考柏林噪声中的梯度计算生成二维梯度向量:

$\mathrm{dot(grad3[gi0], x0, y0)}$ 就是梯度的 $xy$ 分量和角指向之间的点积, $\mathrm{n1}$ 和 $\mathrm{n2}$ 的贡献值计算同理.

#+begin_src java
  private static double dot(int g[], double x, double y) {
      return g[0]*x + g[1]*y;
  }
#+end_src

代码中 $\mathrm{70 \times (n0 + n1 + n2)}$ 就是单形噪声值, 正如代码的注释所示, $70$ 是用来把结果归一化成 $[-1, 1]$ 的.

为什么是 $70$, 这需要讨论 $\mathrm{n0 + n1 + n2}$ 的最大值是多少.

$\sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 \vec{g_{i}}\vec{d_{i}} = \sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 |\vec{g_{i}}||\vec{d_{i}}|\cos\theta$

想让 $\vec{g_{i}} \cdot \vec{d_{i}}$ 最大, 要满足两个条件:

1. $\vec{g_{i}}$ 和 $\vec{d_{i}}$ 之间的夹角 $\theta$ 为 0, 换而言之满足这样的关系: $\vec{g_{i}} = \lambda \vec{d_{i}}$, 其中 $\lambda \gt 0$;
2. 两者的模长达到各自的最大值. 由于梯度向量 $\vec{g}$ 是预设的, 所以可以确定它的最大模长为 $\sqrt{2}$.


假设同时满足这两个条件, 上面的等式可以写成 $\sqrt{2} \sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 |\vec{d_{i}}|$.

分别讨论三种情况: 输入点位于任意单形角, 位于等边三角形中心以及位于任意边中点.

#+begin_quote
这个问题没法直接用费马点(=Fermat point=)来解决.

所谓费马点是位于三角形内的一个点, 这个点到三个顶点的距离之和比从其它点算起都要小, 每个三角形只有一个费马点.

假设三角形的三个顶点分别为 $A, B, C$, 费马点为 $P$, 那么距离之和为 $|\vec{PA}| + |\vec{PB}| + |\vec{PC}|$.

因为 $f(x) = (0.5 - x^2)^4 x$ 不是线性关系, 所以 $\sqrt{2}[f(|\vec{PA}|) + f(|\vec{PB}|) + f(|\vec{PC}|)] \ne \sqrt{2}f(|\vec{PA}| + |\vec{PB}| + |\vec{PC}|)$.
#+end_quote

#+attr_html: :width 504px
[[../../../files/2d-simplex-summation.png]]

从图中可得知:

当点处于其中一个角上, 点与对应角的距离为 0, 其贡献值为 $\sqrt{2} (0.5 - 0)^4 \times 0 = 0$ 其它两个角的贡献值也同样为 0,

所以 $\mathrm{n0 + n1 + n2} = 0$;

当点处于等边三角形的中心, 点到每个角的距离都相等, 中点正好是其高的三等分点, 点到角的距离为 $\frac{2}{3} \sqrt{\frac{1}{2}} = \frac{\sqrt{2}}{3}$,

所以 $\mathrm{n0 + n1 + n2 = 3 \times \sqrt{2}(0.5 - (\frac{\sqrt{2}}{3})^2)^4 \frac{\sqrt{2}}{3}} = 2 (\frac{5}{18})^4 = \frac{625}{52488} \approx \frac{1}{84}$;

当点处于任意边的中点, 点距离每个角的距离分别为 $\sqrt{\frac{1}{2}}$, $\sqrt{\frac{1}{6}}$ 以及 $\sqrt{\frac{1}{6}}$,

所以 $\mathrm{n0 + n1 + n2} = \sqrt{2} [(0.5 - \frac{1}{2})^4 \sqrt{\frac{1}{2}} + (0.5 - \frac{1}{6})^4 \sqrt{\frac{1}{6}} + (0.5 - \frac{1}{6})^4 \sqrt{\frac{1}{6}}] = 2 \sqrt{2} \times \frac{1}{3}^4 \sqrt{\frac{1}{6}} = \frac{2}{81}\sqrt{\frac{1}{3}} \approx \frac{1}{70}$.

#+begin_quote
这三个距离中, $\sqrt{\frac{1}{2}}$ 已经在求 $m_{xy}$ 时得到了, 另外两个可以根据等边三角形和三角函数得到,

又或者通过单形网格空间上 $(1, 0)$ 或 $(0, 1)$ 变换到正交网格空间上再进行求模长得出单形的边长, 再除以 2 得到, 这里就不详细说了.
#+end_quote

在对比之下发现, 点处于等边三角形边的中心时贡献值最大.

然而, 该归一化系数 $70$ 并不严谨, 目前没找到关于"点处于等边三角形边的中心时贡献值最大"的数学证明, 该结论是通过实验得到的, 后面会提到这个问题.

***** 更高维度的单形噪声

从 =2D= 单噪声的实现中可以看到里面涉及了大量复杂的推导, 那么对于更高维度的单形噪声是不是也要这样呢?

可以不用, 因为上面推导结果基本上可以在[[https://polytope.miraheze.org/wiki/Simplex][正单形(regular simplex)性质]]找到.

这里只讨论几个东西: $\mathrm{F2}$ 的高维版本 $F_N$, $\mathrm{G2}$ 的高维版本 $G_N$, 正单形的边长 $L$, 正单形的高 $H$, 以及更高维度的归一化系数 $NF$ 如何得到.

在 $N$ 维空间上:

$F_N = \frac{\sqrt{N + 1} - 1}{N}$

$G_N = \frac{(N + 1) - \sqrt{N+1}}{N^2 + N} = \frac{1 - \frac{1}{\sqrt{N + 1}}}{N}$;

$L = \frac{N}{\sqrt{N^2 + N}} = \sqrt{\frac{N}{N + 1}}$;

#+begin_quote
这个公式是从 [[../../../files/constructing-a-regular-n-simplex.pdf][Constructing a regular n-simplex]] 里面得到的.
#+end_quote

$H = \sqrt{\frac{N + 1}{2N}} \cdot L = \sqrt{\frac{N + 1}{2N}} \cdot \sqrt{\frac{N}{N + 1}} = \frac{\sqrt{2}}{2}$;

$NF(d, r, m, n) = \frac{1}{2m(r^2 - d^2)^n}$, 其中:

$d$ 是角指向的模;

$r$ 是衰减函数里的半径, 通常是单形角到对边/面的垂直距离;

$m$ 是梯度向量的最大模, 为 $\sqrt{N}$;

$n$ 是衰减函数的幂.

这里的归一化系数的计算方式是基于这个结论得到的: 当点处于单形中的一条边上的中点时, 贡献值达到最大.

目前我没有找到该支撑该结论的数学证明, 该结论是[[http://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36][Sharpe 通过实验得到的 (在评论区里面)]]得到的.

需要注意是, =Sharpe= 计算方式和这里的有些出入, 这里的考虑上了梯度向量的模长不为 1.

还有, 不管用 =Sharpe= 的还是说这里的计算方式, 高维 $NF$ 的计算结果与 =Simplex Noise Demystified= 的有出入, 考虑到原文中就有不少错误, 因此这里我决定相信 =Sharpe=.

这里附上 $S_N$ 的 =Maxima= 实现:

#+begin_src maxima
  NF(x, r, m, n) := 1 / ((r^2 - x^2)^n * x * m * 2.0);
#+end_src

另外, 为了防止链接失效, 这里还是备份一下评论的内容:

#+begin_quote
The way to work out the normalization factor is to think of what the maximum possible value would be generated if given the right conditions. So this would be by taking some sample within the simplex triangle, while having all gradient vectors pointing at that sample. To generate the maximum value it turns out that this sample is halfway along any one of the triangle edges. ( so this means the equal combination of two surflets )

In 2D, half the edge length of a simplex triangle is…

x = ( sqrt( 0.5 )/sqrt( 0.75 ) ) * 0.5

So our 2D normalization factor becomes…

2DNF = 1.0 / ( x * ( ( 0.5 – x*x ) ^ 4 ) * 2.0 ) = ~99.2043345….

In 3D, half the edge length of a simplex tetrahedron is…

x = sqrt( 0.75 ) * 0.5

So our 3D normalization factor becomes…

3DNF = 1.0 / ( x * ( ( 0.5 – x*x ) ^ 3 ) * 2.0 ) = ~37.8372272…..

Something to note: 2D simplex triangles ( as generated by perlins skew/unskew method ) are equilateral. But the 3D simplex tetrahedrons are NOT. They’re slightly skewed…. So the 3D math I’m using here starts to deviate ever so slightly from the actual results. But because it is so minor and to keep math simplicity+sanity, I’ve chosen to ignore this issue.
#+end_quote

(PS: 归一化系数应该是单形噪声中最不严谨的部分了, 在网上找了好几天的相关解释, 发现每个实现的 $NF$ 都不一样, 着实心累, 考虑到实现中用上近似了, 就不太纠结准确性了.)

*** 调色板生成

参考资料: https://offscreencanvas.com/issues/generative-shader-color-palettes/

** 其它软件的内置函数

大部分软件的 =Shader Language= 在语法上并不会相差太多, 甚至连内置函数也是差不多.

这一章节主要是对一些 =GLSL= 上没有但在其它软件存在的内置函数, 在了解这些内置函数的作用后你就可以看明白其它软件的 =Shader Code=, 以学习思路.

*** Unreal Engine: rcp

#+begin_quote
来源: https://forums.unrealengine.com/t/q-what-is-does-the-rcp-function-perform-in-the-shader-code/28068/2
#+end_quote

快速计算/近似 $x$ 的倒数: $rcp(x) = \frac{1}{x}$.

** 分形 (Fractal)

*** 谢尔宾斯基三角形 (Sierpiński Triangle)
*** 分形布朗运动 (Fractal Brownian Motion)

概念参考资料: https://thebookofshaders.com/13/

#+begin_quote
- Experiment by changing the frequency and amplitude for the additional waves.

  pass

- Is it possible to make two waves cancel each other out? What will that look like?

  是的.

  使得两个正弦波的频率(=frequency=)和振幅(=amplitude=)保持一直, 两者偏移(offset)相差 $PI$.

  #+begin_src c
    float amplitude = 4.5;
    float frequency = 2.1;
    float offset = PI;
    float y = sin(x*frequency + t)*amplitude;
    y += sin(x*frequency + t + PI)*amplitude;
  #+end_src

- Is it possible to add waves in such a way that they will amplify each other?

  是的.

  有三种方法:

  1. 相位一致性: 确保 $frequency$ 和 $offset$ 保持一致.

  2. 频率匹配: 确保 $frequency$ 保持一致, $offset$ 之差不能超过 $PI$.

  3. 多波叠加: 使用多种波形的组合, 比如方波, 不过这超出我们的讨论范围了.

- Progressively change the number of octaves to iterate from 1 to 2, 4, 8 and 10. See what happens.

  线条的总体形状不发生改变, 只是会一直添加细节, 当 =octaves= 增加大于 8 时, 细节的增加也不明显了.

- When you have more than 4 octaves, try changing the lacunarity value.

  线条的周期会明显缩小, 振幅稍微扩大.

- Also with >4 octaves, change the gain value and see what happens.

  线条的振幅明显扩大.
#+end_quote

*** madelbrot set
*** voronoi diagram

** 图像处理

*** 图像边缘检测 (Edge detection)

=Sobel=.
