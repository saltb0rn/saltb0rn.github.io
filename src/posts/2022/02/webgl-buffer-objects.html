<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-08 Mon 22:07 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shader 编程自救指南</title>
<meta name="author" content="saltb0rn" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="/home/saltb0rn/.emacs.d/assets/mathjax/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Shader 编程自救指南</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#how-gl-works">1. Shader 是如何工作的</a>
<ul>
<li><a href="#org4028745">1.1. Vertex Shader</a></li>
<li><a href="#org7b83479">1.2. Vertex Shader 之后, Fragment Shader 之前</a></li>
<li><a href="#orgdf3cf42">1.3. Fragment Shader</a></li>
<li><a href="#org3ae6fa5">1.4. Fragment Shader 之后 - Per-Sample Processing</a></li>
</ul>
</li>
<li><a href="#org5ed2b70">2. 一个简单而完整的 Shader 程序</a>
<ul>
<li><a href="#how-cpu-upload-data">2.1. CPU 如何上传数据给 GPU</a></li>
<li><a href="#how-gl-use-data">2.2. GPU 如何从缓冲读取数据</a></li>
<li><a href="#org274cd2e">2.3. 如何使用缓冲的数据进行绘制</a></li>
<li><a href="#glsl-type-qualifier-overview">2.4. GLSL 变量修饰符(Variable Qualifiers / Type Qualifiers)</a>
<ul>
<li><a href="#org2955eda">2.4.1. attribute</a></li>
<li><a href="#org57a8d00">2.4.2. uniform</a></li>
</ul>
</li>
<li><a href="#orge9be2b8">2.5. GLSL 内置变量</a></li>
<li><a href="#orgb7a842a">2.6. 其它常见问题</a></li>
</ul>
</li>
<li><a href="#org19e4f77">3. WebGL 的 API 概览</a>
<ul>
<li><a href="#org937ab7f">3.1. 缓冲 (Buffer)</a></li>
<li><a href="#org47c1e51">3.2. 贴图 (Texture)</a></li>
<li><a href="#org923f98e">3.3. 帧缓冲 (FrameBuffer)</a></li>
</ul>
</li>
<li><a href="#org41591e4">4. 搭建自己的 Shadertoy</a></li>
<li><a href="#org56a810d">5. 学习使用 Three.js 进行实践</a>
<ul>
<li><a href="#org785d4cc">5.1. 如何搭建基础项目</a></li>
<li><a href="#org2fea439">5.2. 如何把 <code>Shader</code> 应用到物体上</a></li>
<li><a href="#orge52208c">5.3. 如何进行后处理</a></li>
<li><a href="#orga0d913d">5.4. 项目结构推荐</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract" id="orgb8b2d0f">
<p>
由于去年换了工作, 生活变得充实起来了, 这里的充实并非反话, 我在这段时间调整了心态和目标, 学习了一些新的知识;
</p>

<p>
为了学习游戏开发, 定制了新的学习目标, 包括音乐, 编剧, 使用 <code>Blender</code> 建模以及 <code>Godot</code> 的使用等等;
</p>

<p>
同时由于工作繁忙的原因, 图形学学习计划搁置了一年, 当时就停留在贴图映射的阶段.
</p>

<p>
另外搁置搁置还有一个原因, 那就是当时在学习贴图映射时所在的参考书有点不太易懂,
</p>

<p>
所以需要找一本更易读的书, 我找到了 <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/">Computer Graphics from Scratch</a>, 但这本书当前还没完成编写 (其实 21 年就写完了), 因此决定等它出版了再继续学.
</p>

<p>
虽然这篇文章名字叫做 <code>Shader</code> 编程自救指南, 但主要是介绍 <code>Shader</code> 程序是如何工作的, 主要涉及渲染管线的一些细节以及 <code>OpenGL/WebGL</code> 的概念和 <code>API</code>.
</p>

<p>
与 <code>Shader</code> 编程本身没有太大的关系, 有点类似与学习编程语言和学习编程之间的区别, <code>Shader</code> 编程的重点是图形学内容和数学技巧, 之后会单独写一片文章来介绍这一块.
</p>

<hr />

<p>
PS: 现在是 2023 年 12 月, 从今年的 6 月份才发现这本书已经写完了, 于是平时抽空一点一点地读了半年, 终于读完这本书, 期间使用 <code>C</code> 语言按照书上的伪代码实践了一遍.
</p>

<p>
个人感觉等待这本书的完成是一个正确的选择, 它指导了我编写两个完整的渲染器, 简单易懂地解释了图形学里面一些较为复杂的算法.
</p>

<p>
我本人在读这本书之前就已经较为深入地学习了一些 <a href="../..//2020/06/graphics-geometric-transformation.html">数学细节</a> 以及 <a href="../../2020/06/graphics-opengl-transformation.html">OpenGL的渲染管线</a>,
</p>

<p>
在跟着书本实践时特地找出这些知识和实践的对应之处, 学习效果非常地好.
</p>

<p>
这本书清晰了我在学习渲染管线时的一些迷糊之处, 而之前所学的数学细节以及渲染管线知识又很好地弥补了这本书在这方面的空缺.
</p>

<p>
现在回过头来看 <code>Shader</code> 程序如何运作时, 很多东西都豁然开朗了.
</p>

</div>
<div id="outline-container-how-gl-works" class="outline-2">
<h2 id="how-gl-works"><span class="section-number-2">1.</span> Shader 是如何工作的</h2>
<div class="outline-text-2" id="text-how-gl-works">
<p>
为了了解 <code>Shader</code> 是如何工作的, 我们将从最简单的 <code>WebGL</code> 开始上手,
</p>

<p>
<code>WebGL</code> 和 <code>OpenGL</code> 的工作方式基本上是一致的, 主要区别在于对工具的要求上,
</p>

<p>
<code>WebGL</code> 只要求掌握一点 <code>JavaScript/HTML</code> 就可以了;
</p>

<p>
而对于 <code>OpenGL</code>, 很多教程都是要求读者使用 <code>C/C++</code> 来完成的, 而使用 <code>C/C++</code> 又掌握如何使用编译器以及 <code>makefile/cmake</code> 这样控制编译连接的工具的使用, 不是简单的事情.
</p>

<p>
要想了解 <code>Shader</code> 如何工作什么的, 其实和了解 <code>OpenGL</code> 是一样的, 离不开对渲染流程的了解.
</p>

<p>
开发人员所关心的 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 就是整个渲染流程里其中的两个环节.
</p>

<p>
我一开始是找了关于这块不错的教程来进行学习:
</p>

<p>
<a href="https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL Fundamentals 的 WebGL是如何工作的</a>
</p>

<p>
<a href="https://webgl2fundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL2 Fundamentals 的 WebGL是如何工作的</a>
</p>

<p>
但很快就发现一个问题: 初学者只看这两个阶段的话其实就是在断章取义, 是难以理解它们是如何工作的,
</p>

<p>
特别是 <code>Fragment Shader</code>, 看别人的 <code>Shader</code> 还是一头雾水.
</p>

<p>
回过头去看官方的 <a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">渲染流程概览</a>, 又发现里面的内容不太好理解, 于是乎决定把它们结合在一起进行理解, 接下来就是个人理解了.
</p>

<p>
在这之前要了解一件事情, 随着 <code>OpenGL</code> 版本的变化, 渲染流程时会发生变化的, <code>WebGL</code> 也是一样.
</p>

<p>
因此, 这篇文章里面的例子只关注特定版本的 <code>WebGL</code>: <code>WebGL 1.0</code>, 它对应的 <code>GLSL</code> 版本是 <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.20.pdf">1.20</a>.
</p>

<blockquote>
<p>
由于历史原因, <code>OpenGL/OpenGL ES/WebGL</code> 和 <code>GLSL</code> 之间的版本对应关系挺混乱的, 幸好维基百科上有列出<a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions">对应关系</a>.
</p>

<p>
如果不了解这一块, 你将无法知道 <code>Shader</code> 程序能够运行在什么环境上的.
</p>
</blockquote>

<p>
接下来着重介绍 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 及其前后的几个阶段.
</p>
</div>
<div id="outline-container-org4028745" class="outline-3">
<h3 id="org4028745"><span class="section-number-3">1.1.</span> Vertex Shader</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<code>Vertex Shader</code> 根据几何数据(geometry data)计算出裁剪空间(clip space)的顶点坐标, 也就是投影坐标.
</p>

<p>
所谓的几何数据就是指顶点数据, 这些数据来自于 <code>CPU</code> 程序的上传(后面会详细介绍), 每当接收一个几何数据, <code>Vertex Shader</code> 就运行一遍,
</p>

<p>
如下图所示:
</p>


<div id="org077602e" class="figure">
<p><img src="../../../files/vertex-shader-anim.gif" alt="vertex-shader-anim.gif" />
</p>
<p><span class="figure-number">Figure 1: </span>Vertex Shader 对顶点数据进行处理 (图片来源于上述链接)</p>
</div>

<p>
由于 <code>Vertex Shader</code> 可以自定义, 所以该计算过程不是固定的.
</p>

<p>
一个顶点数据并非只有一个顶点坐标, 还可能有顶点颜色, 顶点法线以及顶点贴图坐标等等.
</p>

<p>
<code>Vertex Shader</code> 要做的事情只有两件:
</p>

<ol class="org-ol">
<li>把 <code>gl_Position</code> 的值设置为裁剪坐标, 以次把裁剪坐标传递到后面的流程中</li>
<li>定义 <code>varying</code> 类型变量, 给 <code>varying</code> 变量的值设置为可选数据, 以此把可选数据传递到后面的流程中</li>
</ol>
</div>
</div>
<div id="outline-container-org7b83479" class="outline-3">
<h3 id="org7b83479"><span class="section-number-3">1.2.</span> Vertex Shader 之后, Fragment Shader 之前</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 <code>Vertex Shader</code> 之后并非马上就到 <code>Fragment Shader</code> 了, 这期间会发生一切其他事情.
</p>

<p>
<b>图元组装 (Primitive Assembly)</b>
</p>

<p>
在通过 <code>Vertex Shader</code> 处理完所有输入的顶点数据之后, <code>OpenGL</code> 会按照一定规律把输出的顶点组合在一起形成一个几何对象,
</p>

<p>
几何对象可能会很复杂, 在计算机里面, 这种复杂的几何对象必定是由最简单的图形单位构成的,
</p>

<p>
这种最简单的图形单位被叫做图元, 可以被 <code>GPU</code> 直接处理和绘制. 常见的图元包括:
</p>

<p>
点 (<code>GL_POINTS</code>), 直线 (<code>GL_LINES</code>), 三角形 (<code>GL_TRIANGLES</code>) 以及它们的派生, 具体可以看 <a href="https://www.khronos.org/opengl/wiki/Geometry_Shader#Primitive_in.2Fout_specification">OpenGL 图元规范</a>.
</p>

<p>
有时候图元也被叫做基础图元(<code>base primitive</code>). 在不同语境下, 图元有不同的含义,
</p>

<p>
对于人来说, 可以理解为最简单的几何图形; 对于 <code>OpenGL</code> 来说, 就是一个可解析的顶点流(<code>vertex stream</code>).
</p>

<p>
比如说接收到一个长度为 12 的有序顶点列表, 以每 2 个顶点为一组构成 1 条线段, 最后可以获得 11 条线段,
</p>

<p>
这 11 条线段就是 11 个直线图元, 这 11 个直线图元也被称为图元流(<code>primitive stream</code>).
</p>

<p>
图元装配这个阶段的工作就是完成从顶点流到图元流的解析.
</p>

<p>
实际上, 在 <code>OpenGL</code> 里面, 图元装配之前还有两个阶段: <b><a href="https://www.khronos.org/opengl/wiki/Tessellation">曲面细分 (Tessellation)</a></b> 和 <b><a href="https://www.khronos.org/opengl/wiki/Geometry_Shader">几何着色器 (Geometry Shader)</a></b>.
</p>

<p>
因为它们不存在于 <code>WebGL</code> 的渲染流程中, 所以不是本文重点.
</p>

<p>
不过, 几何着色器还是值得关注: 几何着色器以一个图元作为输入, 以零个或多个图元作为输出.
</p>

<p>
使用几何着色器的主要目的之一是: 在不改变渲染目标(<code>renderTarget</code>)绑定的前提下, 把一个图元渲染到多张图片中.
</p>

<p>
所谓渲染目标就是接收渲染结果的对象, 比如显示图像的屏幕, 后面的帧缓冲会详细说明.
</p>

<p>
比如生成位置光源的阴影贴图, 开发者可以在几何着色器中一次渲染出 6 张 <code>2D</code> 贴图来组成一个立方贴图.
</p>

<p>
这样既提高了开发效率和也优化了运行效率.
</p>

<p>
<b>裁剪 (Cliping)</b>
</p>

<p>
<code>OpenGL/WebGL</code> 会把超出视野的图元或图元部分进行裁剪, 就像人一样, 看不了视野以外的东西.
</p>

<p>
这一步会对裁剪坐标进行透视除法得到 <code>NDC</code> 坐标, 再对 <code>NDC</code> 坐标进行视口变换得到屏幕空间(<code>screen space</code>)上的坐标.
</p>

<p>
<b>面剔除 (Face Culling)</b>
</p>

<p>
<code>OpenGL/WebGL</code> 可以检测得到图元面向是正面还是背面观察者(viewer)的, 就如我们生活中看到的物体一样,
</p>

<p>
一个时间点内只能在一个角度看到它, 看得到就是正面, 看不到的就是背面, 那么背面也是在视野之外的.
</p>

<p>
<code>OpenGL/WebGL</code> 可以让开发者决定是否取消对物体背面的渲染.
</p>

<p>
<b>光栅化 (Rasterization)</b>
</p>

<p>
在阶段会把一个图元拆分成若干个片元(<code>fragments</code>), 所谓片元就是一种类像素数据(<code>pixel-like data</code>),
</p>

<p>
我们可以先把像素(pixel)定义为显示在屏幕上的一个小方块, 该小方块可以显示某个颜色.
</p>

<p>
片元可以记录小方块在画面上的位置以及颜色, 也可能和有一些与之关联的可选数据,
</p>

<p>
这些可选数据是根据 <code>Vertex Shader</code> 定义的 <code>varying</code> 变量所传递的可选数据计算得来.
</p>


<div id="org40e3d03" class="figure">
<p><img src="../../../files/opengl-rasterization.gif" alt="opengl-rasterization.gif" />
</p>
</div>

<p>
比如动画中的这个过程就是对一个三角形图元进行采样(sampling)得到一个由方块组成的近似三角形, 这些方块就是片元.
</p>

<blockquote>
<p>
你可以把采样理解为从一个连续对象上抽取若干个数据形成一个不连续的序列, 该序列和连续对象近似乎;
</p>

<p>
我们把这些抽出来的数据叫做样本(samples), 样本数量越多, 得到的序列就和连续对象越像.
</p>
</blockquote>

<p>
然而, <code>OpenGL/WebGL</code> 是如何在只知道顶点的信息的情况下把中间部分的点给补全呢?
</p>

<p>
首先, 在前面的裁剪步骤中已经根据顶点的裁剪坐标计算出屏幕坐标了, 也就是顶点对应的片元坐标;
</p>

<p>
再根据这些片元坐标通过线性插值(interpolation)来补充缺失的片元, 从而构造出由方块组成的近似三角形.
</p>


<div id="orgbb8d0a6" class="figure">
<p><img src="../../../files/trianglerast_f1_joshbeam.png" alt="trianglerast_f1_joshbeam.png" />
</p>
<p><span class="figure-number">Figure 2: </span>三个顶点所对应的片元坐标</p>
</div>

<p>
线性插值的原理很简单, 就是 \(y = y_{0} + \frac{y_{1} - y_{0}}{x_{1} - x_{0}} \times t(x_{1} - x_{0}),\ \mathrm{where}\ 0 \le t \le 1\).
</p>

<p>
也可以这么表述: \(y = y_{0} + \frac{y_{1} - y_{0}}{x_{1} - x_{0}} \times (x - x_{0}),\ \mathrm{where}\ \min(x_{0}, x_{1}) \le x \le\ \max(x_{0}, x_{1})\).
</p>

<p>
再换句话说就是找出 \((x_{0}, y_{0})\) 和 \((x_{1}, y_{1})\) 两点线段上的一个点 \((x, y)\), 这个点就是缺失片元的坐标.
</p>

<p>
由于片元是一格一格的, 因此两个相邻的片元必定在 \(x\) 轴/\(y\) 轴/同时在 \(x\) 和 \(y\) 轴方向上相差一个单位.
</p>

<p>
所以我们的插值代码如下:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  i0: int
  i1: int

  d0: decimal
  d1: decimal
</span><span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">interpolate</span>(<span style="color: #eedd82;">i0</span>, <span style="color: #eedd82;">d0</span>, <span style="color: #eedd82;">i1</span>, <span style="color: #eedd82;">d1</span>) {
  <span style="color: #00ffff;">if</span> (i0 == i1) {
    <span style="color: #00ffff;">return</span> [d0];
  }

  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">values</span> = [];
  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">a</span> = (d1 - d0) / (i1 - i0);
  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">d</span> = d0;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">incrementing i by 1 is because the difference between each two adjacent pixels is 1
</span>  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">i</span> = i0; i &lt;= i1; i++) {
    values.push(d);
    d += a;
  }

  <span style="color: #00ffff;">return</span> values;
}
</pre>
</div>

<p>
在传参时, 可以选择两个点的 \(x\) 分量来作为 \(i0\) 和 \(i1\), 让 \(y\) 分量作为 \(d0\) 和 \(d1\);
</p>

<p>
也可以选择 \(y\) 分量作为 \(i0\) 和 \(i1\), 让 \(x\) 分量作为 \(d0\) 和 \(d1\).
</p>

<p>
这取决于 \(\left|x1 - x0\right|\) 和 \(\left|y1 - y0\right|\) 两者之间哪个大.
</p>

<p>
观察代码, 如果 \(\left|i1 - i0\right|\) 比 \(\left|d1 - d0\right|\) 要小, 那么 \(\left|a\right|\) 就要大于 1,
</p>

<p>
因为函数 <code>interprolate</code> 的参数是坐标分量, 所以 \(\left|a\right|\) 大于 1 表示这坐标之间相差两个单位, 与相邻片元相差一个单位矛盾.
</p>

<p>
比如, 以 \(x\) 分量作为 \(i0\) 和 \(i1\), 并且 \(a = 2\), 那么 \((10, 20)\) 的下一个插值坐标是 \((11, 22)\);
</p>

<p>
但如果以 \(y\) 作为 \(i0\) 和 \(i1\), 那么 \(a = \frac{1}{2}\), 那么 \((10, 20)\) 的下一个插值坐标是 \((11, \lfloor 20.5 \rfloor)\), 这种情况片元就是相邻的.
</p>

<p>
使用 <code>interpolate</code> 函数很容易就能画出一个三角形边线框.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;, p0 p1 p2 &#19977;&#20010;&#22352;&#26631;&#30340;&#20998;&#37327;&#26159; decimal &#31867;&#22411;, &#36825;&#26159;&#20174;&#35009;&#21098;&#31354;&#38388;&#36716;&#25442;&#21040;&#23631;&#24149;&#31354;&#38388;&#24471;&#21040;&#30340;&#32467;&#26524;;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32780;&#23631;&#24149;&#31354;&#38388;&#19978;&#30340;&#20687;&#32032;&#20998;&#37327;&#26159; int &#31867;&#22411;, &#22240;&#27492;&#25105;&#20204;&#38656;&#35201;&#22312;&#20851;&#38190;&#26102;&#20505;&#23545;&#20998;&#37327;&#36827;&#34892;&#21462;&#25972;,
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#20801;&#35768;&#30340;&#35805;,&#26368;&#22909;&#22312;&#35745;&#31639;&#36807;&#31243;&#30340;&#26368;&#21518;&#19968;&#27493;&#32473;&#35745;&#31639;&#32467;&#26524;&#21462;&#25972;&#26469;&#20445;&#35777;&#32467;&#26524;&#23613;&#37327;&#31934;&#30830;.
</span>
<span style="color: #00ffff;">if</span> (Math.abs(p1.x - p0.x) &gt; Math.abs(p1.y - p0.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys01</span> = interpolate(p0.x | 0, p0.y, p1.x | 0, p1.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p0.x; x &lt;= p1.x; x++) {
    putPixel(x | 0, ys01[(x - p0.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs01</span> = interpolate(p0.y | 0, p0.x, p1.y | 0, p1.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p1.y; y++) {
    putPixel(xs01[(y - p0.y) | 0] | 0, y | 0);
  }
}

<span style="color: #00ffff;">if</span> (Math.abs(p2.x - p1.x) &gt; Math.abs(p2.y - p1.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys12</span> = interpolate(p1.x | 0, p1.y, p2.x | 0, p2.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p1.x; x &lt;= p2.x; x++) {
    putPixel(x | 0, ys12[(x - p1.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs12</span> = interpolate(p1.y | 0, p1.x, p2.y | 0, p2.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p1.y; y &lt;= p2.y; y++) {
    putPixel(xs12[(y - p1.y) | 0] | 0, y | 0);
  }
}

<span style="color: #00ffff;">if</span> (Math.abs(p2.x - p0.x) &gt; Math.abs(p2.y - p0.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys02</span> = interpolate(p0.x | 0, p0.y, p2.x | 0, p2.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p0.x; x &lt;= p2.x; x++) {
    putPixel(x | 0, ys02[(x - p0.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs02</span> = interpolate(p0.y | 0, p0.x, p2.y | 0, p2.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
    putPixel(xs02[(y - p0.y) | 0] | 0, y | 0);
  }
}
</pre>
</div>


<div id="org1a4e297" class="figure">
<p><img src="../../../files/trianglerast_f2_joshbeam.png" alt="trianglerast_f2_joshbeam.png" />
</p>
<p><span class="figure-number">Figure 3: </span>三角形线框</p>
</div>

<p>
绘制填充三角形则复杂一点, 不过很好理解, 它 <code>OpenGL/WebGL</code> 绘制图形的重点.
</p>

<p>
可以把一个三角形看作一个由多层横线组成的的图形, 每一层的高度为一个像素;
</p>

<p>
计算出每一层的两个端点, 再根据每层的两端点进行插值绘制出直线, 这些直线构成的就是目标三角形.
</p>


<div id="orgb5bd6cf" class="figure">
<p><img src="../../../files/trianglerast_f3_joshbeam_aux.png" alt="trianglerast_f3_joshbeam_aux.png" />
</p>
<p><span class="figure-number">Figure 4: </span>实心三角形</p>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#39318;&#20808;&#38656;&#35201;&#23545; p0 p1 p2 &#19977;&#20010;&#29255;&#20803;&#22352;&#26631;&#26681;&#25454; $y$ &#20998;&#37327;&#36827;&#34892;&#20132;&#25442;&#25490;&#24207;, &#27604;&#22914;&#20174;&#23567;&#21040;&#22823;&#36827;&#34892;&#25490;&#24207;: p0.y &lt;= p1.y &lt;= p2.y
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36825;&#26679;&#21487;&#20197;&#36991;&#20813;&#35752;&#35770;&#21738;&#20010;&#28857;&#26368;&#39640;,&#21738;&#20010;&#28857;&#26368;&#20302;
</span><span style="color: #00ffff;">if</span> (p1.y &lt; p0.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p0;
  p0 = p1;
  p1 = temp;
}

<span style="color: #00ffff;">if</span> (p2.y &lt; p0.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p0;
  p0 = p2;
  p2 = temp;
}

<span style="color: #00ffff;">if</span> (p2.y &lt; p1.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p1;
  p1 = p2;
  p2 = temp;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#19977;&#35282;&#24418;&#26368;&#39640;&#30340;&#19968;&#26465;&#36793;&#30475;&#20316;&#26159;&#19968;&#20010;&#31471;&#28857;&#38598;&#21512;, &#25226;&#21478;&#22806;&#20004;&#26465;&#36793;&#30340;&#38598;&#21512;&#30475;&#20316;&#21478;&#22806;&#19968;&#20010;&#31471;&#28857;&#38598;&#21512;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#27880;&#24847;, &#36825;&#37324;&#30340;&#26368;&#39640;&#36793;&#26159; p0 &#36830;&#25509; p2 &#30340;&#36793;, &#21478;&#22806;&#20004;&#26465;&#36793;&#20998;&#21035;&#26159; p0 &#36830;&#25509; p1 &#21644; p1 &#36830;&#25509; p2
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312;&#24050;&#30693;&#29255;&#20803;&#30340; y &#20998;&#37327;&#26102;, &#21487;&#20197;&#25554;&#20540;&#20986;&#29255;&#20803;&#23545;&#24212;&#30340; x &#20998;&#37327;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x01</span> = interpolate(p0.y | 0, p0.x, p1.y | 0, p1.x);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x12</span> = interpolate(p1.y | 0, p1.x, p2.y | 0, p2.x);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x02</span> = interpolate(p0.y | 0, p0.x, p2.y | 0, p2.x);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23454;&#38469;&#19978;, p0-p2 &#30340;&#36793;&#39640;&#24230;&#26159;&#19982; p0-p1 + p1-p2 &#30340;&#39640;&#24230;&#26159;&#19968;&#26679;&#30340;, &#21487;&#20197;&#25226; p0-p1-p2 &#21333;&#29420;&#30475;&#20316;&#26159;&#19968;&#26465;&#36793;
</span>x01.pop(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x01 &#30340;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#21644; x12 &#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#37325;&#22797;&#23454;&#38469;&#19978;&#26159;&#21516;&#19968;&#20010;&#29255;&#20803;&#30340; x &#20998;&#37327;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x012</span> = x01.concat(x12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25509;&#19979;&#26469;&#21482;&#35201;&#21306;&#20998; p0-p2 &#21644; p0-p1-p2 &#21738;&#20010;&#26159;&#24038;&#36793;&#21738;&#20010;&#26159;&#21491;&#36793;, &#20877;&#36827;&#34892;&#36880;&#34892;&#25554;&#20540;&#23601;&#21487;&#20197;&#32472;&#21046;&#20986;&#19977;&#35282;&#24418;&#20102;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21306;&#20998;&#24038;&#21491;&#36793;&#30340;&#26041;&#27861;&#24456;&#31616;&#21333;, &#20998;&#21035;&#21462;&#20004;&#36793;&#30340;&#20013;&#38388;&#28857;&#30340; x &#20998;&#37327;&#36827;&#34892;&#23545;&#27604;&#21363;&#21487;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">m</span> = Math.floor(x02.length / 2);
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x_left</span>, <span style="color: #eedd82;">x_right</span>;
<span style="color: #00ffff;">if</span> (x02[m] &lt; x012[m]) {
  x_left = x02;
  x_right = x012;
} <span style="color: #00ffff;">else</span> {
  x_left = x012;
  x_right = x02;
}

<span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
以上就是 <code>OpenGL/WebGL</code> 绘制实心三角形的大致原理.
</p>

<p>
基于该过程, 还可以插值出之前说的可选数据, 只要在计算 <code>x01/x12/x02</code> 时进行类似插值就可以:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#31446;&#21521;&#36827;&#34892;&#25554;&#20540;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h01</span> = interpolate(p0.y | 0, p0.h, p1.y | 0, p1.h);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h12</span> = interpolate(p1.y | 0, p1.h, p2.y | 0, p2.h);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h02</span> = interpolate(p0.y | 0, p0.h, p2.y | 0, p2.h);
h01.pop();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h012</span> = h01.concat(h12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">h_left</span>, <span style="color: #eedd82;">h_right</span>;
<span style="color: #00ffff;">if</span> (x02[m]  &lt; x012[m]) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>  h_left = h02;
  h_right = h012;
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>  h_left = h012;
  h_right = h02;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];

  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hl</span> = h_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hr</span> = h_right[(y - p0.y) | 0];

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#27178;&#21521;&#36827;&#34892;&#25554;&#20540;
</span>  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hs</span> = interpolate(xl, hl, xr, hr);

  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#33719;&#21462;&#24403;&#21069;&#29255;&#20803;&#25152;&#23545;&#24212;&#30340;&#21487;&#36873;&#25968;&#25454; h, &#29992;&#22312;&#20043;&#21518;&#30340; fragment shader &#38454;&#27573;&#20013;
</span>    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h</span> = hs[x - xl];
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
到止, 光栅化基本完成, <code>OpenGL/WebGL</code> 会把片元逐个输出到下一个阶段 <b>Fragment Shader</b>.
</p>

<blockquote>
<p>
实际上 <code>GPU</code> 是并行计算架构, 并非逐个片元这样传递, 我们这里只是为了方便理解才这么说是 <b>逐个传递</b> 的.
</p>

<p>
实情是每次以 \(2 \times 2\) 的片元作为单位进行传递的, 也就是一次要同时调用 4 个 <code>Fragment Shaders</code>.
</p>
</blockquote>

<p>
<code>OpenGL/WebGL</code> 会使用一些变量来传递片元数据, 比如 <code>gl_FragCoord</code> 会把片元对应的 \(x\) 和 \(y\) 分量一并传回;
</p>

<p>
<code>gl_FragCoord</code> 的类型是 <code>vec4</code>, 值是 \(\left(x, y, z, 1/w\right)\), 其中 \(x\) 和 \(y\) 就是片元对应的 \(x\) 和 \(y\) 分量,
</p>

<p>
上面的代码没有针对 \(z\) 分量进行插值, 因为它和 \(x\) 和 \(y\) 分量的插值略微不一样, 顶点之间的 \(z\) 分量并不存在线性关系, 无法直接插值,
</p>

<p>
反而是 \(\frac{1}{z}\) 之间成线性关系, 所以根据两个顶点的 \(z\) 分量的倒数 \(\frac{1}{z}\) 进行插值, 最后再倒回去:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#31446;&#21521;&#36827;&#34892;&#25554;&#20540;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz01</span> = interpolate(p0.y | 0, 1 / p0.z, p1.y | 0, 1 / p1.z);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz12</span> = interpolate(p1.y | 0, 1 / p1.z, p2.y | 0, 1 / p2.z);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz02</span> = interpolate(p0.y | 0, 1 / p0.z, p2.y | 0, 1 / p2.z);
iz01.pop();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz012</span> = iz01.concat(iz12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">iz_left</span>, <span style="color: #eedd82;">iz_right</span>;
<span style="color: #00ffff;">if</span> (x02[m]  &lt; x012[m]) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>  iz_left = iz02;
  iz_right = iz012;
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>  iz_left = iz012;
  iz_right = iz02;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span><span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];

  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izl</span> = iz_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izr</span> = iz_right[(y - p0.y) | 0];

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#27178;&#21521;&#36827;&#34892;&#25554;&#20540;
</span>  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izs</span> = interpolate(xl, izl, xr, izr);

  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz</span> = izs[x - xl];
    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">z</span> = 1 / iz;
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
同理, \(1/w\) 是根据顶点插值得到的 \(w\) 分量的倒数.
</p>

<p>
<code>gl_FragCoord</code> 这种是 <code>OpenGL/WebGL</code> 的内置变量, 用来传递特定用途的数据, 后面会介绍更多这一类的内置变量, 因为它们可能会在 <code>Shader</code> 程序中用得上.
</p>

<p>
而可选数据 \(h\) 则需要开发人员自定义 <code>varying</code> 类型或 <code>out</code> 类型变量进行传递, 我们马上就知道具体该怎么做.
</p>
</div>
</div>
<div id="outline-container-orgdf3cf42" class="outline-3">
<h3 id="orgdf3cf42"><span class="section-number-3">1.3.</span> Fragment Shader</h3>
<div class="outline-text-3" id="text-1-3">
<p>
在得到片元后, <code>OpenGL/WebGL</code> 就开始对它们进行处理, 这就是 <code>Fragment Shader</code> <b>主要</b> 要做的事情了:
</p>

<p>
每次接受一个片元作为输入, 为片元设置颜色(设置 <code>gl_FragColor</code>), 以此把处理后的片元输出到下一个阶段中.
</p>

<p>
如果该片元最终能够呈现在屏幕上, 那么该颜色就作为像素的颜色.
</p>

<p>
为了了解具体是怎么实现的, 我们来看一个例子(基于 <code>WebGL 1.0/GLSL 1.20</code> 版本).
</p>

<blockquote>
<p>
在下面的绘制三角形的例子里面, <code>Vertex Shader</code> 根据三角形的顶点数据的坐标为它们定义颜色(, 这样每个顶点的颜色就不一样了);
</p>

<p>
<code>Vertex Shader</code> 中的 <code>vColor</code> 则是作为与 <code>gl_Position</code> 关联的可选数据.
</p>

<p>
在光栅化的过程中 <code>OpenGL/WebGL</code> 会根据 <code>Vertex Shader</code> 传递过来的 <code>gl_Position</code> 以及可选数据 <code>vColor</code> 进行插值, 得到片元坐标以及与之相关的可选数据.
</p>

<p>
片元的坐标会被保存在 <code>gl_FragCoord</code> 中; 对于可选数据 <code>vColor</code>, 会被保存到 <code>Fragment Shader</code> 的同名同类型的 <code>vColor</code> 变量上.
</p>

<p>
再次强调, 虽然在 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 上都有 <code>vColor</code>, 但是它们附属的对象是不一样的,
</p>

<p>
<code>Vertex Shader</code> 的 <code>vColor</code> 是属于顶点的, <code>Fragment Shader</code> 的 <code>vColor</code> 是属于片元的.
</p>

<p>
这样 <code>Fragment Shader</code> 就接受了一个片元以及其相关的可选数据, 根据开发人员的自身要求设置 <code>gl_FragColor</code>.
</p>

<p>
该例子里面的 <code>Fragment Shader</code> 把与片元关联的 <code>vColor</code> 设置为自己的颜色, 最后得到一个颜色渐变的三角形.
</p>

<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="../../../examples/fragment-shader-example.html"></iframe>
</p>
</blockquote>

<p>
<code>Fragment Shader</code> <a href="https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_inputs">输入</a>和<a href="https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_outputs">输出</a>的片元数据结构是不一样的, 从这里开始我们进行一个约定: 在没有特别声明的情况下, 片元就是指 <code>Fragment Shader</code> 输出的片元.
</p>

<p>
相比于像素而言, 片元除了有 <code>RGBA</code> 格式的色值以外, 还有模板值(stencil value)和<a href="https://blog.darksalt.me/docs/posts/2020/06/graphics-opengl-transformation.html#text-depth-buffer">深度值</a>(depth value)这些信息.
</p>

<p>
需要知道这些数据的含义, 或者说理解片元, 那么得先了解 <code>Fragment Shader</code> 后面的 <code>Per-Sample Processing</code> 阶段做了什么.
</p>
</div>
</div>
<div id="outline-container-org3ae6fa5" class="outline-3">
<h3 id="org3ae6fa5"><span class="section-number-3">1.4.</span> Fragment Shader 之后 - Per-Sample Processing</h3>
<div class="outline-text-3" id="text-1-4">
<p>
该阶段会使用上片元的这些额外值来进行<a href="https://www.khronos.org/opengl/wiki/Per-Sample_Processing">一系列的测试</a>, 来决定是否把该片元的色值输出到屏幕上成为像素,
</p>

<p>
这里就讨论剪裁测试(scissor test), 模板测试(stencil test) 以及深度测试(depth test) 这三个测试(这里是它们的先后顺序).
</p>

<p>
其中剪裁测试以及深度测试都比较好理解, 前者是丢弃剪裁框范围外的片元, 后者是丢弃那些被其它片元挡住的片元, 留下没被遮挡住的片元;
</p>

<p>
而模板测试你可以理解为位屏蔽(bit masking)的类似, 使用一个模板缓冲(stencil buffer)作为遮罩层, 把模板值不符合条件的片元都丢弃,
</p>

<p>
为了更直观地理解, 我直接从 <a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">LearnOpenGL</a> 上把图给扒下来, 来看看模板测试以及模板缓冲是怎么样的:
</p>


<div id="orgb443f5d" class="figure">
<p><img src="../../../files/stencil_test.png" alt="stencil_test.png" />
</p>
<p><span class="figure-number">Figure 5: </span>模板测试</p>
</div>

<p>
可以看到上模板缓冲就是一张模板图片, 该图片每一个像素都是 8 位大小的数据, 也就是每一个像素实际上就是一个从 0 到 255 的值.
</p>

<p>
模板测试就是比较对应位置上的像素数值和片元模板值, 比如像上面图那样, 只有模板值等于 1 的片元才能被保留下来.
</p>

<p>
当然判断方法也有可能是大于等于 1, 判断方法不是唯一的, 其他方法可以看<a href="https://www.khronos.org/opengl/wiki/Stencil_Test#Stencil_test">官方文档</a>.
</p>

<p>
最后 <code>OpenGL/WebGL</code> 再对经过筛选的片元进行一些处理就能输出到屏幕上了.
</p>
</div>
</div>
</div>
<div id="outline-container-org5ed2b70" class="outline-2">
<h2 id="org5ed2b70"><span class="section-number-2">2.</span> 一个简单而完整的 Shader 程序</h2>
<div class="outline-text-2" id="text-2">
<p>
我们约定 <code>Shader</code> 代码是运行在 <code>CPU</code> 上的, 而调用 <code>OpenGL/WebGL API</code> 的代码则是运行在 <code>CPU</code> 上的;
</p>

<p>
当提到调用 <code>OpenGL/WebGL API</code> 给 <code>Shader</code> 提供数据的时候, 就说从 <code>CPU</code> 上传数据到 <code>GPU</code>.
</p>

<p>
这部分的内容主要是补充描述 <code>GPU</code> 具体是如何接收来自于 <code>CPU</code> 的数据的.
</p>

<p>
<b>为了不让文章被上下文断断续续的代码扰乱, 这里准备了一个简单的<a href="https://github.com/saltb0rn/saltb0rn.github.io/tree/master/src/examples/learn-webgl-how-to-read-data">例子</a>用于讲解</b>, 效果如下:
</p>

<p>
<iframe width="300" height="300" src="../../../examples/learn-webgl-how-to-read-data/index.html"></iframe>
</p>

<p>
在阅读下面的内容前请 <b>务必</b> 把例子的代码复制到本地, 然后边阅读边对照, 有疑惑可以修改代码查看效果.
</p>

<p>
需要注意的是, 这个例子是基于 <code>WebGL 1.0/GLSL 1.20</code> 的.
</p>
</div>
<div id="outline-container-how-cpu-upload-data" class="outline-3">
<h3 id="how-cpu-upload-data"><span class="section-number-3">2.1.</span> CPU 如何上传数据给 GPU</h3>
<div class="outline-text-3" id="text-how-cpu-upload-data">
<p>
首先,  <code>GPU</code> 会等 <code>CPU</code> 把数据传送过来, 在接收到数据后, 数据会被储存在缓冲(buffers)上.
</p>

<p>
我们以 <code>WebGL</code> 为例子 (<code>OpenGL</code> 其实也差不了太多), 设现有一个名为 <code>gl</code> 的 <code>WebGL</code> 上下文实例, 要完成上述过程需要进行以下操作:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21578;&#35785; GPU &#21019;&#24314;&#22909;&#32531;&#20914;,&#29992;&#20110;&#21518;&#32493;&#20648;&#23384; CPU &#21457;&#36807;&#26469;&#30340;&#25968;&#25454;
</span><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">buffer</span> = gl.createBuffer();

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35774;&#23450;&#24403;&#21069;&#21487;&#25805;&#20316;&#32531;&#20914;,&#22240;&#20026; GPU &#21487;&#20197;&#26377;&#19981;&#27490;&#19968;&#20010;&#32531;&#20914;,&#25152;&#20197;&#38656;&#35201;&#21578;&#35785; GPU &#25509;&#19979;&#26469;&#35201;&#23545;&#21738;&#20010;&#32531;&#20914;&#36827;&#34892;&#25805;&#20316;
</span>gl.bindBuffer(target, buffer);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#24448;&#24403;&#21069;&#21487;&#25805;&#20316;&#32531;&#20914;&#37324;&#38754;&#22635;&#20805;&#25968;&#25454;,&#36825;&#19968;&#27493;&#25442;&#21477;&#35805;&#35828;&#23601;&#26159;&#20648;&#23384; CPU &#21457;&#36807;&#26469;&#30340;&#25968;&#25454; data &#20102;.
</span>gl.bufferData(target, data, usage);
</pre>
</div>

<p>
这里对应例子的<a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L92">这一部分(80-92行)</a>.
</p>

<p>
由于数据的用途的不同, 缓冲可以分为很多种类型, 在绑定的时候就需要指定了, 也就是上面代码里面的 <code>target</code> 变量.
</p>

<p>
想要知道 <code>target</code> 的值能够是什么, 可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer">这里</a>, 这些方法的参考说明都可以在<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext">这里</a>找到.
</p>

<blockquote>
<p>
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml">参考文档</a> <code>usage</code> 变量是用来提示 <code>OpenGL/WebGL</code> 储存数据的使用模式, 使用模式分为两个方面来讨论:
</p>

<p>
<b>数据的访问频率</b> 以及 <b>数据的访问性质</b>.
</p>

<p>
访问频率有以下几种情况:
</p>

<ul class="org-ul">
<li><code>STREAM</code>: 数据只会被修改一次并且偶尔使用几次</li>
<li><code>STATIC</code>: 数据只会被修改一次并且使用多次</li>
<li><code>DYNAMIC</code>: 数据会重复修改并且使用多次</li>
</ul>

<p>
访问性质其实就是在描述数据来源(也就是修改数据的方式)以及用途, 有以下几种情况:
</p>

<ul class="org-ul">
<li><code>DRAW</code>: 数据由 <code>CPU</code> 上传到 <code>GPU</code>, 并且作为绘图命令/图片规范命令的数据源</li>
<li><code>READ</code>: 数据由 <code>GPU</code> 读取到 <code>CPU</code></li>
<li><code>COPY</code>: 数据由 <code>GPU</code> 读取到 <code>GPU</code>, 并且作为绘图命令/图片规范命令的数据源</li>
</ul>

<hr />

<p>
值得注意的是, <code>usage</code> 仅仅是用来 <b>提示</b> 数据的使用模式, 目的是想让 <code>OpenGL/WebGL</code> 对数据的储存进行优化;
</p>

<p>
但 <code>usage</code> 并不一定要匹配实际的使用模式, 比如说可以对 <code>STATIC_DRAW</code> 用途的数据进行多次修改, 并不约束数据的实际使用模式.
</p>
</blockquote>

<p>
在 <code>OpenGL/WebGL</code> 里面, 这些用来作为物体顶点信息的缓冲叫做 <code>Vertex Buffer Object (VBO)</code>,
</p>

<p>
因为 <code>OpenGL/WebGL</code> 里面有不止一种类型的缓冲, 所以个人更喜欢把储存顶点信息的缓冲叫做 <code>VBO</code>,
</p>

<p>
所以在下文提到 <code>VBO</code> 时应该立刻想起 <code>VBO</code> 是通过 <code>gl.createBuffer</code> 方法创建的.
</p>

<p>
一旦有了数据源, 就可以让 <code>GPU</code> 根据利用这些数据来渲染了.
</p>

<p>
<code>VBO</code> 并非只能存顶点数据, 也可以包含一些其它与顶点相关的数据, 我们一般把顶点数据以其关联数据统称为集合数据(<code>Geometry Data</code>).
</p>

<p>
另外, <code>OpenGL/WebGL</code> 也不规定 <code>CPU</code> 上传的数据只能存到缓冲里, 后面会介绍它们.
</p>
</div>
</div>
<div id="outline-container-how-gl-use-data" class="outline-3">
<h3 id="how-gl-use-data"><span class="section-number-3">2.2.</span> GPU 如何从缓冲读取数据</h3>
<div class="outline-text-3" id="text-how-gl-use-data">
<p>
首先需要提及的一点是, <code>GPU</code> 并非直接使用缓冲来进行渲染, 在说明这点之前, 我们先来明白一个概念.
</p>

<p>
<code>VBO</code> 里面的数据格式不是固定的, 比如渲染一个三角形, 它的顶点数据格式可能是这样的:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, x2, y2, z2, x3, y3, z3 }
</pre>
</div>

<p>
每个顶点只有 \((x,y,z)\) 坐标数据.
</p>

<p>
也可能是这样的:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3 }
</pre>
</div>

<p>
现在每个顶点的坐标数据多了一个 \(w\) 分量.
</p>

<p>
也有可能包含了坐标以外的数据:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, w1, r1, g1, b1, a1, x2, y2, z2, w2, r2, g2, b2, a2, x3, y3, z3, w3, r3, g3, b3, a3, }
</pre>
</div>

<p>
总的来说, 每个顶点数据可能会有不同属性(attribute), 而不同属性的格式又不是固定的.
</p>

<p>
那么问题来了, 既然数据格式不一样, <code>GPU</code> 是如何读取这些数据才能渲染出一个三角形的呢?
</p>

<p>
这需要开发人员告诉 <code>GPU</code> 如何读取数据, 调用 <code>gl.vertexAttribPointer(index, size, type, normalized, stride, offset)</code> 这个 API 来生成一个 <code>Vertex Array Object (VAO)</code>,
</p>

<p>
<b>VAO 决定了如何从 VBO 里面读取数据, 并把读取到的数据绑定给变量</b>.
</p>

<p>
它控制读取数据的方式其实很简单, 假设下面这里有另外一种数据格式:
</p>


<div id="org98636fa" class="figure">
<p><img src="../../../files/glVertexAttribPointer-api-overview.png" alt="glVertexAttribPointer-api-overview.png" />
</p>
<p><span class="figure-number">Figure 6: </span>vertexAttribPointer</p>
</div>

<p>
这里面的顶数据有三种属性: 顶点坐标(xyz), 颜色(rgb)以及纹理坐标(st).
</p>

<p>
正如前面说所说的, 顶点的信息不是固定的, 实际上还能会存在别的数据, 比如说法线向量, 又或者属性之间的排序不同于上图.
</p>

<p>
这样做的好处是, 顶点的所有相关数据都储存在一个缓冲里面, 只读取其某个属性的话(比如顶点颜色)只需要调用 <code>gl.vertexAttribPointer()</code> 来新建一个指针来读取即可, 不需要重新创建一个缓冲来专门储存颜色数据.
</p>

<p>
<code>gl.vertexAttribPointer</code> 的 <code>index</code> 参数是 <code>Shader</code> 程序(shader program)里面 <code>attribute</code> 类型变量的索引值, 可以手动指定, 也可以通过 <code>gl.getAttribLocation(shaderProgram, attribName)</code> 来获取.
</p>

<p>
<code>attribute</code> 类型变量是 <code>shader</code> 程序里面定义的变量, 用来传递缓冲里面某种数据给 <code>Vertex Shader</code> 中, 后面会讲到.
</p>

<blockquote>
<p>
<code>gl.vertexAttribPointer</code> 其它参数:
</p>

<ul class="org-ul">
<li><code>size</code>: 指定某属性由多少个分量组成, 比如图中的 <code>POSITION</code> 属性是由 3 个分量组成, 如果读取 <code>POSITION</code>, 那么 <code>size</code> 应该是 3.</li>

<li><code>type</code>: 分量的类型, 是整形还是浮点型, 图中的分量类型是浮点型, 浮点型数据大小为 32 位(4 字节), 因此每个分量占了 4 个字节.</li>

<li><code>normalized</code>: 是否对整形分量限定在某个范围内, 该参数对浮点型分量无效.</li>

<li><code>stride</code>: 每一组顶点数据的步进, 就比如图中的每一个顶点的属性有 <code>POSITION/COLOR/TEXTURE</code>, 加起来共 32 字节, 这就是它的步进.</li>

<li><code>offset</code>: 顶点数据的属性偏移, 就比如图中顶点数据的每种属性的偏移分别为: <code>POSITION</code> 为 0 个字节; <code>COLOR</code> 为 12 个字节; <code>TEXTURE</code> 为 24 个字节.</li>
</ul>
</blockquote>

<p>
在 <code>gl.bindBuffer(target, buffer)</code> 之后调用 <code>gl.vertexAttribPointer</code> 就可以把缓冲里的数据填充到指定的 <code>attribute</code> 变量里面.
</p>

<p>
在填充到 <code>attribute</code> 变量后不要忘记通过 <code>gl.enableVertexAttribArray( RET-VAL-OF-vertexAttribPointer )</code> 启用指针.
</p>

<p>
这一段对应例子的<a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L116">这一部分(94-114行)</a>: 往 "aVertexPosition" 变量填充了顶点位置坐标数据, 往 "aVertexColor" 变量填充了顶点颜色数据,
</p>

<p>
其中 <code>aVertexPosition</code> 和 <code>aVertexColor</code> 是 <code>shader</code> 程序的 <a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L16-L29">Vertex Shader</a> 里面 <b>声明</b> 的 <code>attribute</code> 变量名, 强调这是声明是因为 <code>gl.vertexAttribPointer</code> 的调用实际上就是给这些变量补充定义.
</p>

<p>
此外, 当你对 <code>a_vertexPosition</code> 和 <code>a_vertexColor</code> 两个值进行打印, 你会发现它们的值分别是 0 和 1, 正好对应 <code>attribute</code> 变量声明的顺序.
</p>

<p>
<code>Shader</code> 程序并非只有 <code>attribute</code> 变量, 接下来会对 <code>GLSL</code> 变量修饰符进行介绍, 掌握了这一块才能算是真正的掌握 <code>GLSL</code>.
</p>
</div>
</div>
<div id="outline-container-org274cd2e" class="outline-3">
<h3 id="org274cd2e"><span class="section-number-3">2.3.</span> 如何使用缓冲的数据进行绘制</h3>
<div class="outline-text-3" id="text-2-3">
<p>
当给缓冲填充了数据以及设置好读取方式后, 就可以开始绘制图形了.
</p>

<p>
<code>WebGL</code> 有两个基础绘制命令: <code>gl.drawArrays(mode, first, count)</code> 以及 <code>gl.drawElements(mode, count, type, offset)</code>.
</p>

<p>
例子使用的是前者进行绘制的, <code>mode</code> 是指绘制的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements#mode">图元种类</a>, <code>first</code> 指定读取图元数据源时的起始索引, <code>count</code> 指定图源需要多少个顶点数据;
</p>

<p>
例子里的 <code>gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);</code> 就是绘制一个三角形, 从绑定的数据源的首个位置开始读取, 需要 3 个顶点数据.
</p>

<p>
<code>gl.drawElements(mode, count, type, offset)</code> 则是 <code>gl.drawArrays</code> 的内存节省版本, 使用顶点数据的索引来进行绘图, 可以有效节省顶点数据的使用空间.
</p>

<p>
具体用法可以参考 <a href="https://webglfundamentals.org/webgl/lessons/webgl-indexed-vertices.html">WebGL Index Vertices</a>.
</p>

<p>
在调用绘图命令时 <code>Shader</code> 就会开始执行了, 这点在第一节里面已经详细讲述了.
</p>
</div>
</div>
<div id="outline-container-glsl-type-qualifier-overview" class="outline-3">
<h3 id="glsl-type-qualifier-overview"><span class="section-number-3">2.4.</span> GLSL 变量修饰符(Variable Qualifiers / Type Qualifiers)</h3>
<div class="outline-text-3" id="text-glsl-type-qualifier-overview">
<p>
和其他编程语言一样, <code>GLSL</code> 的变量也是一样有修饰符的, 这里的修饰符并非指 <code>int</code>, <code>float</code> 这些 <a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)">数据类型</a>;
</p>

<p>
而是指控制变量的储存以及行为的标识, 这么说可能有点不太好理解, 举个例子 "禁止变量在声明后被修改" 的 <code>const</code> 就是其中一个修饰符.
</p>

<p>
这种表示被叫做 <a href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)">类型限定符</a>.
</p>

<p>
我们都知道 <code>GLSL</code> 的工作内容并不完全像其他编程语言一样, 它的任务是控制图形渲染的, 而这项任务的流程是分成好几个阶段的,
</p>

<p>
有些数据可以在所有阶段中都能访问到, 而有些数据只能在特定阶段中访问, 还有一些数据能够从这个阶段输出到下一个阶段.
</p>

<p>
为了标识变量能够在哪些阶段使用, 就需要使用类型表示符来进行声明, 最常用的有两个: <code>attribute</code> 以及 <code>uniform</code>.
</p>

<p>
一个 <code>shader</code> 变量可以使用多种限定符的组合进行声明, 但要注意遵守<a href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)#Qualifier_order">顺序</a>.
</p>
</div>
<div id="outline-container-org2955eda" class="outline-4">
<h4 id="org2955eda"><span class="section-number-4">2.4.1.</span> attribute</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
它在这篇文章里面第一个被介绍的修饰符, 它属于存储修饰符, 被它修饰后的变量可以简单理解为 <code>Vertex Shader</code> 的输入,
</p>

<p>
这种变量不能在 <code>Vertex Shader</code> 以外的阶段被使用, 同样也不能用在接口块(<a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)">interface block</a>)里面, 并且这种变量是只读的(read-only).
</p>

<p>
作为 <code>Vertex Shader</code> 的输入, 也就是说 <code>attribute</code> 变量接收的数据是从缓冲里面读取的.
</p>
</div>
</div>
<div id="outline-container-org57a8d00" class="outline-4">
<h4 id="org57a8d00"><span class="section-number-4">2.4.2.</span> uniform</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
例子里面传入了两个 <code>uniform</code> 变量, 这种变量是全局的, 它可以在整个图元处理过程中被访问到,
</p>

<p>
可以在 <code>Vertex Shader</code> 以及 <code>Fragment Shader</code> 访问这些变量, 同样也不能在接口块里面使用. 这种变量是只读的(read-only).
</p>

<p>
<code>uniform</code> 是我们前面提到的存到缓冲以外的数据.
</p>

<p>
在 <code>GLSL 1.10</code> 中, 当 <code>Shader</code> 程序成功编译链接后, 所有的 <code>uniform</code> 变量都会被赋予 0 作为默认值.
</p>

<p>
在 <code>GLSL 1.20</code> 中, 除了 <code>sampler2D/samplerCube</code> 外的所有 <code>uniform</code> 变量都支持使用初始化器:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec3</span> color = <span style="color: #98fb98;">vec3</span>(0.7, 0.7, 0.2);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge9be2b8" class="outline-3">
<h3 id="orge9be2b8"><span class="section-number-3">2.5.</span> GLSL 内置变量</h3>
<div class="outline-text-3" id="text-2-5">
<p>
这里着重介绍几个稍微重要一点的并且不能被 <code>Shader</code> 修改的内置数据.
</p>

<ul class="org-ul">
<li><p>
<code>gl_VertexID</code>
</p>

<p>
支持 <code>GLSL 1.30</code> 以及之后的版本, 只支持在 <code>Vertex Shader</code> 中访问.
</p>

<p>
<code>gl_VertexID</code> 就是当前被处理的顶点 <code>ID</code> (<code>Vertex ID</code>).
</p>

<p>
比如绘制 20 个顶点: <code>gl.drawArrays(gl.POINTS, 0, 20)</code>, 那么第一个顶点的 <code>ID</code> 就是 \(first + i,\ \mathrm{where}\ i = 0\),
</p>

<p>
\(first\) 是绘图命令 <code>gl.drawArrays(mode, first, count)</code> 的第二个参数, \(i\) 是由当前处理的第 \(i+1\) 个顶点的索引.
</p>

<p>
这是对于每次像 <code>gl.drawArrays</code> 这样的绘图命令来讲的, 也就是说如果进行第二次调用 <code>gl.drawArrays(gl.POINTS, 0, 20)</code> 的话,
</p>

<p>
第二次绘制中第一个顶点的 <code>ID</code> 必定也是 \(first + 0\), 而不是 \(first + 20\).
</p></li>

<li><p>
<code>gl_PointCoord</code>
</p>

<p>
支持 <code>GLSL 1.10</code> 以及之后的版本, 支持在 <code>Fragment Shader</code> 中访问.
</p>

<p>
<code>gl_PointCoord</code> 是点在像素块内的相对坐标, 分量 \(x\) 和 \(y\) 的范围是 \(\left[0, 1\right]\).
</p>

<p>
比如在前面的图片 <code>实心三角形</code> 中, 点 <code>p0</code> 在它所处的片元正中心, 那么该片元的 <code>gl_PointCoord</code> 的值就是 \((0.5, 0.5)\),
</p>

<p>
如果它处于片元的左上角, 那么值就是 \((0, 0)\).
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgb7a842a" class="outline-3">
<h3 id="orgb7a842a"><span class="section-number-3">2.6.</span> 其它常见问题</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li><p>
<code>GLSL</code> 的矩阵是行优先(row major)还是列优先(column major)?
</p>

<p>
默认是列优先, 可以通过 <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">Layout Qualifier</a> 去修改.
</p></li>

<li><p>
为什么看到别人代码的向量的同一个位置的分量会不同, 比如 <code>vec4</code> 类型的变量会写 <code>v4.rgba</code>, 又有时候会写 <code>v4.xyzw</code>, 又有时候会写 <code>v4.stpq</code>?
</p>

<p>
这几种写法其实都是同一个东西, 比如第一个分量 <code>r/x/s</code> 都是同一个东西, 只不过在语义上有所区别.
</p>

<p>
如果分量用来表示颜色, 那么就建议用 <code>rgba</code>; 如果表示位置坐标, 那么建议用 <code>xyzw</code>; 如果表示纹理坐标, 那么建议用 <code>stpq</code>;
</p>

<p>
但是不能混着用, 比如 <code>xgba</code> 这样.
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org19e4f77" class="outline-2">
<h2 id="org19e4f77"><span class="section-number-2">3.</span> WebGL 的 API 概览</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>WebGL</code> 的很多 <code>API</code> 名字都看着差不多且令人迷惑, 比如: <code>gl.createBuffer</code>, <code>gl.createFramebuffer</code>, <code>gl.createRemderbuffer</code>.
</p>

<p>
令人迷惑主要是源于它们背后所对应的概念. 比如什么是 <code>Buffer</code>, 什么是 <code>Framebuffer</code> 以及什么是 <code>Renderbuffer</code>, 以及他们之间有什么区别.
</p>

<p>
再加上这些东西的使用频率很高, 这里就借着介绍 <code>API</code> 的机会学习这些概念.
</p>
</div>
<div id="outline-container-org937ab7f" class="outline-3">
<h3 id="org937ab7f"><span class="section-number-3">3.1.</span> 缓冲 (Buffer)</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>Buffer</code> 就是专门用来储存几何数据的缓冲, 使用 <code>gl.createBuffer</code> 进行创建.
</p>

<p>
<code>Buffer</code> 这个词语的字面含义过于普遍了: 任何种类的缓冲都是缓冲.
</p>

<p>
但是在 <code>OpenGL/WebGL</code> 中 <code>buffer</code> 这个对象并不能指代所有缓冲, 所以个人偏向使用 <code>Vertex Buffer Objects</code> 或 <code>VBO</code> 来指代它.
</p>

<p>
<code>VBO</code> 的使用在前面就介绍过了, 这里就不再赘述.
</p>
</div>
</div>
<div id="outline-container-org47c1e51" class="outline-3">
<h3 id="org47c1e51"><span class="section-number-3">3.2.</span> 贴图 (Texture)</h3>
<div class="outline-text-3" id="text-3-2">
<p>
贴图本质上就是一个图片对象, 为顶点/片元提供可选数据, 同时贴图也提供了一些针对图片的基本操作.
</p>

<p>
在 <code>OpenGL/WebGL</code> 中使用贴图需要理解一些前置知识.
</p>

<p>
<code>OpenGL/WebGL</code> 至少有 8 个贴图插槽, 每个插槽可以绑定一个贴图对象, 最后可以往贴图对象写入图片数据.
</p>

<p>
在绑定贴图之前需要说明操作哪个插槽, 这个可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/activeTexture">gl.activeTexture(texture)</a> 方法来完成,
</p>

<p>
参数 <code>texture</code> 是一个枚举变量: \(\mathrm{gl.TEXTUREI} \in \{ \mathrm{gl.TEXTURE0}, \mathrm{gl.TEXTURE1}, \mathrm{gl.TEXTURE2}, ... \mathrm{gl.TEXTURE7}, ... \}\).
</p>

<p>
指定插槽后需要说明插槽绑定的贴图类型以及贴图对象, 这则是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindTexture">gl.bindTexture(target, texture)</a> 方法来完成,
</p>

<p>
<code>target</code> 是贴图类型, 可选值为 <code>gl.TEXTURE_2D</code> 和 <code>gl.TEXTURE_CUBE_MAP</code>;
</p>

<p>
<code>texture</code> 是贴图对象的 <code>ID</code>, 这个 <code>ID</code> 是由 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createTexture">gl.createTexture()</a> 方法返回的.
</p>

<p>
<code>gl.createTexture()</code> 方法的作用是初始化一个贴图对象, 在绑定绑定贴图后, 后续的一系列贴图操作都是在绑定贴图上发生,
</p>

<p>
比如使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei">gl.pixelStorei(pname, param)</a> 指定贴图的图片数据的字节如何对齐,
</p>

<p>
使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter">gl.texParameter[fi](target, pname, param)</a> 指定贴图的一些参数,
</p>

<p>
使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D">gl.texImage2D</a> 往贴图对象里面填充贴图数据, 或者设置贴图储存信息的方式.
</p>

<blockquote>
<p>
在实践中会经常设置贴图储存, 为此要明白 <code>gl.texImage2D</code> 哪些参数影响储存.
</p>

<p>
该函数有很多种声明方式, 这里以最为代表性的声明作为学习例子:
</p>

<p>
<code>gl.texImage2D(target, level, internalformat, width, height, border, format, type, srcData)</code>.
</p>

<p>
这里面影响贴图储存的参数是 <code>internalformat</code>, <code>format</code> 和 <code>type</code> 这 3 个参数.
</p>

<p>
它们并非完全独立, 有着<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D#type">固定的组合</a>. 别忘记了 <code>gl.texImage2D</code> 的重要作用是把 <code>CPU</code> 的像素数据写入到 <code>GPU</code> 上,
</p>

<p>
在该过程中要声明好输入端 - <code>CPU</code> 的数据格式以及接收端 <code>GPU</code> 储存数据的格式, 这 3 个参数的总体作用就是声明格式:
</p>

<p>
<code>internalformat</code> 指定 <code>GPU</code> 储存贴图像素的方式, 一个像素由哪些组件构成以及如何布局, 比如 <code>gl.RGBA</code> 表示依次有 <code>R/G/B/A</code> \(4\) 个组件;
</p>

<p>
<code>format</code> 指定 <code>CPU</code> 储存贴图像素的方式, 比如 <code>gl.RGBA</code> 表示写入到 <code>GPU</code> 的像素依次有 <code>R/G/B/A</code> \(4\) 个组件;
</p>

<p>
<code>type</code>  指定 <code>CPU</code> 这边像素的组件大小, 不同组件应该占多少位(<code>bits</code>), 比如 <code>gl.UNSIGNED_BYTE</code> 表示一个组件占 \(8\) 位,
</p>

<p>
在比如 <code>gl.UNSIGNED_SHORT_5_5_5_1</code> 表示 <code>R/G/B/A</code> 4 个组件分别占 <code>5/5/5/1</code> 位.
</p>

<p>
通常来说, <code>CPU</code> 和 <code>GPU</code> 两端的储存方式应该保持一致, 从而保证数据的一致性.
</p>
</blockquote>

<p>
这些函数都不要求传入贴图对象的 <code>ID</code> 作为参数来说明对哪个贴图对象进行操作,
</p>

<p>
因为之前的 <code>gl.activeTexture</code> 已经在内部设置好了状态: 指定了操作的贴图插槽,
</p>

<p>
<code>OpenGL/WebGL</code> 本质上就是一个状态机, 后续的一切贴图操作都是基于这个状态进行.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">WebGL &#40664;&#35748;&#25351;&#23450; gl.TEXTURE0 &#20026;&#24403;&#21069;&#25554;&#27133;, &#26377;&#20123;&#31243;&#24207;&#21482;&#20351;&#29992;&#19968;&#20010;&#25554;&#27133;, &#36825;&#31181;&#24773;&#20917;&#19979;&#36825;&#19968;&#21477;&#22522;&#26412;&#20250;&#34987;&#24573;&#30053;&#25481;
</span>gl.activeTexture(gl.TEXTURE0);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21019;&#24314;&#36148;&#22270;&#23545;&#35937;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">texture</span> = gl.createTexture();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#36148;&#22270;&#32465;&#23450;&#21040;&#25554;&#27133;&#19978;
</span>gl.bindTexture(gl.TEXTURE_2D, texture);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25351;&#23450;&#36148;&#22270;&#25968;&#25454;&#30340;&#20648;&#23384;
</span>gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20026;&#36148;&#22270;&#35774;&#23450;&#21442;&#25968;
</span>gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20026;&#36148;&#22270;&#20998;&#37197;&#31354;&#38388;, &#21442;&#25968; pixels &#20026; null, &#24847;&#21619;&#30528;&#19981;&#25552;&#20379;&#25968;&#25454;, &#36825;&#31181;&#31354;&#30333;&#36148;&#22270;&#19968;&#33324;&#26377;&#29305;&#27530;&#29992;&#36884;
</span>gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, <span style="color: #7fffd4;">null</span>);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30452;&#25509; img &#20803;&#32032;&#20316;&#20026;&#36148;&#22270;&#30340;&#25968;&#25454;&#26469;&#28304;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">image</span> = document.getElementById(<span style="color: #ffa07a;">'image-element'</span>);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);

<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">isPowerOf2</span> = (value) =&gt; value &amp; (value - 1) === 0;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26816;&#26597;&#22270;&#29255;&#30340;&#23610;&#23544;&#26159;&#21542;&#20026; 2 &#30340;&#24130;&#27425;&#26041;
</span><span style="color: #00ffff;">if</span> (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29983;&#25104;&#22810;&#32423;&#32441;&#29702;
</span>  gl.generateMipmap(gl.TEXTURE_2D);
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#19981;&#26159; 2 &#30340;&#24130;&#27425;&#26041;, &#36890;&#36807;&#35774;&#32622; gl.TEXTURE_MIN_FILTER &#20026; gl.LINEAR &#25110; gl.NEARST &#26469;&#20851;&#38381;&#22810;&#32423;&#32441;&#29702;&#29983;&#25104;,

     &#30001;&#20110;&#20851;&#38381;&#22810;&#32423;&#32441;&#29702;&#21518;, &#36828;&#36317;&#31163;&#30340;&#32441;&#29702;&#21487;&#33021;&#22240;&#20026;&#32553;&#23567;&#32780;&#20986;&#29616;&#38191;&#40831;, &#25152;&#20197;&#20351;&#29992; gl.LINEAR &#26368;&#22909;.

     &#22810;&#32423;&#32441;&#29702;&#19981;&#24433;&#21709;&#25918;&#22823;, &#25152;&#20197; gl.TEXTURE_MAG_FILTER &#21487;&#20197;&#19981;&#29992;&#35774;&#32622;.
</span><span style="color: #ff7f24;">   */</span>
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#36148;&#22270;&#30340;&#29615;&#32469;&#27169;&#24335;&#35774;&#32622;&#20026; gl.CLAMP_TO_EDGE
</span>  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36890;&#36807; uniform &#21464;&#37327;&#20026; Shader &#25552;&#20379;&#36148;&#22270;&#25968;&#25454;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">textureLocation</span> = gl.getUniformLocation(shaderProgram, <span style="color: #ffa07a;">"u_texture"</span>);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">0 &#34920;&#31034;&#20351;&#29992; gl.TEXTURE0 &#25554;&#27133;&#19978;&#30340;&#36148;&#22270;, &#22914;&#27492;&#31867;&#25512;, 1 &#34920;&#31034;&#20351;&#29992; gl.TEXTURE1 &#19978;&#30340;&#36148;&#22270;
</span>gl.uniform1i(textureLocation, 0);
</pre>
</div>

<p>
想在 <code>Shader</code> 程序中使用贴图, 那么需要使用 <code>sampler2D</code> 类型的 <code>uniform</code> 变量传递数据:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_texture;
</pre>
</div>

<p>
如果贴图类型是 <code>gl.TEXTURE_CUBE_MAP</code>, 那么应该使用 <code>samplerCube</code> 类型的 <code>uniform</code> 变量.
</p>

<p>
更多贴图相关的内容可以阅读 <a href="https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html">WebGL Textures</a>.
</p>

<blockquote>
<p>
如果有对比 <code>VBO</code> 的使用模式, 你会发现他们的 <code>API</code> 的设计十分类似.
</p>

<p>
基本上都是先调用 <code>gl.create*</code> 方法创建对象, 再调用 <code>gl.bind*</code> 方法绑定操作对象, 最后根据对象提供的 <code>API</code> 对绑定的对象进行操作.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org923f98e" class="outline-3">
<h3 id="org923f98e"><span class="section-number-3">3.3.</span> 帧缓冲 (FrameBuffer)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
帧缓冲是一个缓冲集合, 该集合包含若干个渲染数据, 所谓渲染数据就是渲染结果的拆分:
</p>

<p>
颜色缓冲(<code>color buffer</code>), 深度缓冲(<code>depth buffer</code>) 以及模板缓冲(<code>stencil buffer</code>).
</p>

<p>
新创建的帧缓冲是一个空集, 开发者需要把渲染数据关联到附件(<code>attachments</code>)上, 每关联一个附件, 集合里面就多出一元素,
</p>

<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindFramebuffer">gl.bindFramebuffer(target, framebuffer)</a> 用来指定渲染结果输出 <code>framebuffer</code> 上, 如果 <code>framebuffer</code> 是 <code>null</code>, 那么渲染结果输出到画布上.
</p>

<p>
在调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays">gl.drawArrays(mode, first, count)</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements">gl.drawElements(mode, count, type, offset)</a> 时, <code>OpenGL/WebGL</code> 会把渲染结果输出到帧缓冲上,
</p>

<p>
然而只有当 <code>OpenGL/WebGL</code> 发现渲染数据被关联了附件时, 输出的渲染数据才能被"接住".
</p>

<p>
在帧缓冲里面, 渲染管线的任意一个步骤都不会被遗漏, 如果帧缓冲里面有储存深度缓冲和模板缓冲的附件, 那么深度测试和模板测试依然会进行.
</p>

<blockquote>
<p>
<a href="https://webglfundamentals.org/webgl/lessons/webgl-framebuffers.html">WebGLFundamentals - FrameBuffers</a> 里面用伪代码的形式把这个过程解释得非常清楚, 推荐阅读.
</p>
</blockquote>

<p>
储存缓冲数据的附件可以是贴图, 也可以是渲染缓冲(<code>RenderBuffer</code>), 这两者在用法上存在一些区别.
</p>

<p>
贴图前面已经有介绍了, 它可以给 <code>Shader</code> 程序提供数据从而输出到画面上,
</p>

<p>
而 <code>OpenGL/WebGL</code> 并没有提供任何 <code>API</code> 来读取渲染缓冲上的数据, 因此也无法把它的数据输出到画面上.
</p>

<p>
如果需要把渲染数据用在 <code>Shader</code> 程序中或者用在成像画面上, 那么应该选择贴图作为附件,
</p>

<p>
渲染缓冲适合用于储存深度缓冲和模板缓冲, 进行深度测试和模板测试.
</p>

<p>
以下代码片段演示了帧缓冲的最基本用法:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">canvas</span> = document.getElementById(<span style="color: #ffa07a;">'#canvas'</span>);

gl.enable(gl.DEPTH_TEST);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312;&#25226;&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#21040; fbo &#19978;&#20043;&#21069;&#35774;&#32622;&#28210;&#26579;&#23610;&#23544;
</span>gl.viewport(0, 0, textureWidth, textureHeight);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">fbo</span> = gl.createFramebuffer();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#21040; fbo &#19978;
</span>gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#39068;&#33394;&#32531;&#20914;&#36755;&#20986;&#21040;&#36148;&#22270;&#20013;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">texture</span> = gl.createTexture();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">level</span> = 0;
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20351;&#29992;&#36148;&#22270;&#20316;&#20026;&#38468;&#20214;&#20648;&#23384;&#39068;&#33394;&#32531;&#20914;, &#24182;&#28155;&#21152;&#21040;&#24103;&#32531;&#20914;&#20013;
</span>gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
              canvas.width, canvas.height, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, <span style="color: #7fffd4;">null</span>);  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35774;&#32622;&#36148;&#22270;&#20648;&#23384;
</span><span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  &#22240;&#20026;&#22270;&#29255;&#30340;&#20687;&#32032;&#20197; RGBA &#24418;&#24335;&#20648;&#23384;, &#22240;&#27492;&#22312;&#21360;&#35937;&#20013;, &#25105;&#20204;&#26412;&#33021;&#22320;&#20063;&#35748;&#20026;&#36148;&#22270;&#20687;&#32032;&#30340;&#23383;&#33410;&#26159;&#20197;&#25972;&#25968;&#36827;&#34892;&#32534;&#30721;.

  &#20294;&#23454;&#38469;&#19978;&#23383;&#33410;&#20063;&#33021;&#20197;&#28014;&#28857;&#25968;&#36827;&#34892;&#32534;&#30721;, &#36825;&#26679;&#26368;&#32456;&#24471;&#21040;&#30340;&#36148;&#22270;&#20687;&#32032;&#30340;&#23383;&#33410;&#25152;&#33021;&#20648;&#23384;&#30340;&#20540;&#23601;&#19981;&#29992;&#38480;&#23450;&#22312; 0 ~ 255 &#20013;&#20102;.

  &#24819;&#35201;&#35753;&#36148;&#22270;&#20648;&#23384;&#28014;&#28857;&#25968;, &#38656;&#35201; WebGL &#25903;&#25345;&#28014;&#28857;&#25968;&#25299;&#23637;, &#24120;&#29992;&#30340;&#26377;: OES_texture_float &#25110; OES_texture_half_float.

  if(gl.getExtension('OES_texture_float')) {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                  canvas.width, canvas.height, 0,
                  gl.RGBA, gl.FLOAT, null);
  }
</span><span style="color: #ff7f24;">*/</span>
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, level);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#39068;&#33394;&#32531;&#20914;&#36755;&#20986;&#21040;&#36148;&#22270;&#20013;: end
</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#21040; renderbuffer &#20013;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">rbo</span> = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.FRAMEBUFFER, rbo);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35753;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#30340;&#23610;&#23544;&#21644;&#36148;&#22270;&#30340;&#19968;&#26679;
</span>gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureWidth, textureHeight);
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#21040; renderbuffer &#20013;: end
</span>
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#19968;&#20010;&#35843;&#29992;&#20102; gl.drawArrays/gl.drawEelements &#26041;&#27861;&#30340;&#20989;&#25968;
</span>renderScene();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30446;&#21069;&#20026;&#27490;, &#33719;&#24471;&#20102;&#19968;&#20010;&#32463;&#36807;&#28145;&#24230;&#27979;&#35797;&#30340;&#36148;&#22270; texture, &#21487;&#29992;&#22312; Shader &#31243;&#24207;&#20013;
</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21487;&#20197;&#29992;&#22312;&#25226;&#36148;&#22270;&#19978;&#30340;&#25968;&#25454;&#35835;&#21462;&#20986;&#26469;, &#22312; Shader &#31243;&#24207;&#20197;&#22806;&#30340;&#22320;&#26041;&#25110;&#32773;&#20854;&#23427; Shader &#31243;&#24207;&#20013;&#20351;&#29992;
</span><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">pixels</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Uint8Array</span>(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#27599;&#27425;&#24448; framebuffer &#20013;&#20889;&#20837;&#25968;&#25454;, gl.drawingBufferWidth &#37117;&#20250;&#34987;&#35774;&#32622;&#20026; textureWidth,
   gl.drawingBufferHeight &#21017;&#34987;&#35774;&#32622;&#20026; textureHeight</span><span style="color: #ff7f24;"> */</span>
gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">gl.RGBA &#21644; gl.UNSIGNED_BYTE &#20026;&#35835;&#21462; GPU &#25968;&#25454;&#30340;&#26041;&#24335;, &#20063;&#21487;&#20197;&#29702;&#35299;&#20026; pixels &#30340;&#25968;&#25454;&#26684;&#24335;</span><span style="color: #ff7f24;"> */</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#21518;&#32493;&#30340;&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#22238;&#30011;&#24067;&#19978;
</span>gl.bindFramebuffer(gl.FRAMEBUFFER, <span style="color: #7fffd4;">null</span>);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35774;&#32622;&#22238;&#30011;&#24067;&#30340;&#28210;&#26579;&#23610;&#23544;
</span>gl.viewport(0, 0, canvasWidth, canvasHeight);
renderScene();
</pre>
</div>

<p>
帧缓冲经常会被用在后处理(<code>post processing</code>)上, 所谓的后处理就是在整个场景渲染完毕之后, 把渲染结果写入到帧缓冲的贴图上,
</p>

<p>
创建一个 <code>3D</code> 平面铺满整个画布, 为这个 <code>3D</code> 平面编写 <code>Shader</code> 程序: 以帧缓冲的贴图作为 <code>uniform</code> 变量, 针对贴图内容进行处理并渲染到 <code>3D</code> 平面上.
</p>

<p>
举个通俗点的例子, 比如拍照, 照片就是帧缓冲的贴图, 使用软件对照片进行美化就是后处理, 当然也可以对后处理结果再做一次后处理, 个人把这种情况叫做多阶段后处理(<code>multi pass post procesing</code>).
</p>
</div>
</div>
</div>
<div id="outline-container-org41591e4" class="outline-2">
<h2 id="org41591e4"><span class="section-number-2">4.</span> 搭建自己的 Shadertoy</h2>
<div class="outline-text-2" id="text-4">
<p>
如果想在编写 <code>shader</code> 这条路上走得远, 那么必须得掌握必要的数学基础, 读懂别人 <code>shader</code> 并从中学习, 自己还要动手实践.
</p>

<p>
有一个叫做 <a href="https://www.shadertoy.com/">Shadertoy</a> 网站, 上面有好多高人分享自己的 <code>shaders</code> (运行于 <code>WebGL 2.0</code> / <a href="https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL 300 ES</a>), 是一个庞大的学习资源库.
</p>

<p>
关于阅读代码, 我是始终坚持一个观点, 那就是读源码的第一点是要读得懂, 否者不可能有所收获;
</p>

<p>
这里的"读得懂"并非说掌握代码所使用得语言, 而是知道源代码里面这么写是为什么, 这个为什么的答案终点就是用了什么算法或者技巧.
</p>

<p>
这一点在 <code>shader code</code> 里面是非常好理解的, 在这个 <code>shader</code> 里面,为了实现这个效果使用了哪些数学公式或者概念.
</p>

<p>
当做到了这一点我们就能够达到入门水平了, 反过来知道用哪些数学公式或者概念去实现这个效果了;
</p>

<p>
如果后面能够深入理解掌握的数学公式或者概念, 就能知道它们能够解决什么问题以及用于实现那些自己以前没有实现过的效果了.
</p>

<p>
说了这么多好像, 跟这篇文章的内容无关啊?
</p>

<p>
其实不然, 我这里一直都在强调"学习别人要先保证自己学得懂"这个观点, 学不懂是因为你有一些前置条件没达到,
</p>

<p>
读得懂 <code>Shadertoy</code> 上的源代码要先知道要理解 <code>Shadertoy</code> 是如何工作, 它上面的 <code>shader</code> 都有 <code>Shadertoy</code> 内置的一些变量,
</p>

<p>
清楚这些内置变量的定义是不可缺的, 而要理解清楚它们的定义就得知道在 <code>OpenGL/WebGL</code> 中如何 <code>GPU</code> 传入数据, 如何在 <code>GPU</code> 里面操作数据,
</p>

<p>
这不正好是文章的内容吗?
</p>

<p>
理解一件事物的最好方式就是把它构造出来, 正好 <code>WebGL Fundamentals</code> 以及 <code>WebGL2 Fundamentals</code> 都提供了教程告诉读者如何从 <code>Shadertoy</code> 扒代码,
</p>

<p>
或者如何在 <code>Shadertoy</code> 上面分享代码, 说简单点就是如何搭建自己的 <code>Shadertoy</code>:
</p>

<ul class="org-ul">
<li><code>WebGL Fundamentals</code> 的 <a href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">Shadertoy 搭建教程</a></li>

<li><code>WebGL2 Fundamentals</code> 的 <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html">Shadertoy 搭建教程</a></li>
</ul>


<blockquote>
<p>
在知道 <code>Shadertoy</code> 是如何搭建后, 也可以尝用其他同类型的工具.
</p>

<p>
个人推荐 <a href="https://github.com/patriciogonzalezvivo/glslViewer?tab=readme-ov-file">glslViewer</a>, 可以在这里找到它的<a href="https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-UNIFORMS">内置变量</a>说明, 再配合 <a href="https://github.com/patriciogonzalezvivo/glslViewer/tree/main/examples">官方例子</a> 来快速上手, 至于如何使用这些例子请看官方例子目录下的 <a href="https://github.com/patriciogonzalezvivo/glslViewer/blob/main/examples/Makefile">Makefile</a>.
</p>

<p>
推荐理由正是由于它的自带例子, 这份例子新手在习惯 <code>Shader</code> 方面而言做的相当友好, 比起一上来在 <code>Shadertoy</code> 上面乱找别人的代码来阅读要好, 主打一个循序渐进.
</p>

<p>
另外, <code>Lewis Lepton</code> 使用 <code>glslViewer</code> 作为演示工具来做了一系列入门短视频 <a href="https://www.youtube.com/watch?v=HIvNePu7UEE&amp;list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7">Shader Tutorial Series</a>, 每个视频 4 分钟左右, 是一套不错的教程, 理解教程里面的代码能够让你快速熟悉 <code>Shader</code> 编程.
</p>

<p>
除了 <code>glslViewer</code> 的教程外, 还有一个 <code>Shadertoy Tutorial</code> 系列的教程也相当不错:
</p>

<p>
<a href="https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1">Shadertoy Tutorial Part 1 - Intro</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/48-shadertoy-tutorial-part-2">Shadertoy Tutorial Part 2 - Circles and Animation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/49-shadertoy-tutorial-part-3">Shadertoy Tutorial Part 3 - Squares and Rotation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/50-shadertoy-tutorial-part-4">Shadertoy Tutorial Part 4 - Multiple 2D Shapes and Mixing</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/51-shadertoy-tutorial-part-5">Shadertoy Tutorial Part 5 - 2D SDF Operations and More 2D Shapes</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6">Shadertoy Tutorial Part 6 - 3D Scenes with Ray Marching</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7">Shadertoy Tutorial Part 7 - Unique Colors and Multiple 3D Objects</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8">Shadertoy Tutorial Part 8 - 3D Rotation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/55-shadertoy-tutorial-part-9">Shadertoy Tutorial Part 9 - Camera Movement</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/56-shadertoy-tutorial-part-10">Shadertoy Tutorial Part 10 - Camera Model with a Lookat Point</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11">Shadertoy Tutorial Part 11 - Phong Reflection Model</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/58-shadertoy-tutorial-part-12">Shadertoy Tutorial Part 12 - Fresnel and Rim Lighting</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/59-shadertoy-tutorial-part-13">Shadertoy Tutorial Part 13 - Shadows</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14">Shadertoy Tutorial Part 14 - SDF Operations</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/61-snowman-shader-in-shadertoy">Snowman Shader in Shadertoy</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/62-shadertoy-tutorial-part-15">Shadertoy Tutorial Part 15 - Channels, Textures, and Buffers</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16">Shadertoy Tutorial Part 16 - Cubemaps and Reflections</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/64-shader-resources">Shader Resources</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/65-glow-shader-in-shadertoy">Glow Shader in Shadertoy</a>
</p>

<hr />

<p>
另外, 上手 <code>GLSL</code> 的时候遇到一些内置函数难免会不清楚文档里面的描述的, 所以 <code>Shadertoy</code> 的作者 <a href="https://iquilezles.org/">Inigo Quilez</a> 贴心地开发了一个 <a href="https://graphtoy.com/">Graphtoy</a> 可视化这些函数.
</p>

<p>
PS: 这位大佬除了很多教程文章和视频, 都是非常不错的进阶资源.
</p>

<p>
还有如果你不了解<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/index.php">文档</a>上 <code>Gen*Type</code> 这个词语是什么意思, 你可以去看 <code>GLSL</code> 的语言规范, 我这里可以告诉你的是它的全称是 <code>Generic * Types</code>, 中间的 <code>*</code> 是做进一步限定的,
</p>

<p>
比如 <code>genType</code> 是 <code>float/vec2/vec3/vec4</code>, <code>genIType</code> 可以是 <code>int/ivec2/ivec3/ivec4</code>.
</p>

<p>
并且如果一个函数是这么写的话: <code>genType func(genType x, genType y)</code>, 那么 <code>genType</code> 的值必定是统一的, 只能一起是 <code>float</code>, 或者一起是 <code>vec2</code>, 如此类推.
</p>

<p>
不可能出现像 <code>vec2 func(float x, float y)</code> 这种不统一的情况, 这种是错误用法.
</p>
</blockquote>

<p>
<br />
</p>

<p>
其实这两个教程就是使用的 <code>WebGL</code> 的版本不太一样而已, 选用你喜欢的就好,
</p>

<p>
<code>Shadertoy</code> 上的代码基本上都是只用 <code>Fragment Shader</code> 实现效果的, 但是还存在这么一个网站, 它包含了各种只使用 <code>Vertex Shader</code> 但不使用任何几何输入来实现各种效果的 <code>Shader</code> 程序, 它就是 <a href="https://www.vertexshaderart.com/">VertexShaderArt</a>.
</p>

<p>
<code>WebGL Fundamentals</code> 以及 <code>WebGL2 Fundamentals</code> 在提供 "Shadertoy 搭建教程" 前提供了对应的教程:
</p>

<ul class="org-ul">
<li><code>WebGL Fundamentals</code> 的 <a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html">不使用几何数据作图教程</a></li>

<li><code>WebGL2 Fundamentals</code> 的 <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html">不适用几何数据作图教程</a></li>
</ul>


<p>
<br />
</p>

<p>
从热度上来看, <code>Shadertoy</code> 比 <code>VertexShaderArt</code> 更高, 这是不是意味着 <code>Vertex Shader</code> 不重要呢?
</p>

<p>
不管是 <code>Vertex Shader</code> 还是 <code>Fragment Shader</code>, 都需要开发者掌握名为数学的画笔工具, 并且都是一样的数学知识点, 讨论谁重要毫无意义.
</p>

<p>
<code>Shadertoy</code> 热度高纯粹是因为大部分情况下只需操作像素就能绘制一幅画, 所以使用 <code>Fragment Shader</code> 便足以.
</p>

<p>
而 <code>Vertex Shader</code> 是不能直接控制像素的, 它更倾向于用来控制几何物体的形状, 最典型的例子就是 <a href="https://developer.nvidia.com/gpugems/gpugems/contributors">GPU Gems</a> 中第一章的 <a href="https://developer.nvidia.com/gpugems/gpugems/contributors">波浪模拟</a>, BabylonJS 官方也演示了<a href="https://www.youtube.com/watch?v=JqMxTZ2q4Nw&amp;list=PLsaE__vWcRam5eDcUlGHvylTaATXCAQnC">这一块</a>.
</p>

<p>
如果纵眼望去 <code>ShaderToy</code> 和 <code>VertexShaderArt</code> 上的例子, 可以发现 <code>Vertex Shader</code> 比起 <code>Fragment Shader</code> 更加偏向线性代数(比如这个<a href="https://www.vertexshaderart.com/art/R2FYLbHWTcCWh5PiE">例子</a>, 满满都是矩阵), 两者都涉及微积分的内容.
</p>

<p>
不管怎么说, 如果想要在游戏视觉特效的开发上得心应手, 那么它们两者都很重要.
</p>

<blockquote>
<p>
你可能会听到有人说 <code>ShaderToy</code> 的例子有点太过"邪道", 对游戏开发来说用处不大.
</p>

<p>
但我想说的是 "放屁", 就我见过的一些游戏 <code>Demo</code>, 有好几个用了 <code>SDF</code> 替代粒子系统从而大大地节省了画面上的开销.
</p>

<p>
再说难道游戏里面用到的噪声算法在 <code>ShaderToy</code> 里面看不到吗? 退一步讲, 难道里面的各种数学知识用不上?
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org56a810d" class="outline-2">
<h2 id="org56a810d"><span class="section-number-2">5.</span> 学习使用 Three.js 进行实践</h2>
<div class="outline-text-2" id="text-5">
<p>
想学习游戏开发的 <code>Shader</code> 编程的话, 通常来说是直接上手游戏引擎的.
</p>

<p>
但是个人体验下来, 游戏引擎的封装程度很高, 一些基础的图形效果是不需要开发者去实现的,
</p>

<p>
对于工作意味着效率, 但是对于学习而言就是一个黑盒子, 作为图形学初学者而言, 个人认为不应该通过游戏引擎上手.
</p>

<p>
但也不推荐直接使用 <code>WebGL</code> 或 <code>OpenGL</code> 的 <code>API</code> 去实践, 这些 <code>API</code> 在开发效率上并不占优势,
</p>

<p>
而初学者在实践时不断地调整代码是不可避免的, 这个时候使用这些低效的 <code>API</code> 很容易疲劳.
</p>

<p>
这里推荐 <code>Three.js</code> 作为开发工具, 它对 <code>WebGL API</code> 封装程度比起游戏引擎对 <code>WebGL/OpenGL API</code> 的封装程度要低,
</p>

<p>
在使用难度上对 <code>WebGL API</code> 进行了大幅度的简化. 虽然 <code>Three.js</code> 定位上不是游戏引擎,
</p>

<p>
毕竟很多概念都是相通的, 所以不用担心学习的知识无法迁移到游戏开发上, 况且相比游戏引擎,
</p>

<p>
<code>Three.js</code> 的学习成本比起游戏引擎更低, 使用的 <code>JavaScript</code> 语言, 只要有一个现代浏览器就可以进行开发了.
</p>

<p>
(如果选择了工程化的开发方式, 还可以使用 <code>TypeScript</code> 进行开发).
</p>

<p>
学习 <code>Three.js</code> 的正确方式并非是通过扣文档来掌握它的 <code>API</code>, 这些 <code>API</code> 规定到底就是图形学知识的实现,
</p>

<p>
也就是学好图形学的知识再读个文档基本上知道怎么用这些 <code>API</code> 了, 而且文档上最多只会说明白这个 <code>API</code> 是对应哪个图形学知识,
</p>

<p>
知识的具体细节是不会提及的, 所以脑海没有概念是用不懂这些 <code>API</code> 的, 这也是我观察身边的人与自身情况进行对比得出的感想.
</p>

<p>
最后一个原因是 <code>API</code> 会随着 <code>Three.js</code> 的升级而发生改变, 扣文档学 <code>API</code> 容易使得花了大力气学习的知识被浪费掉.
</p>

<p>
因此, 在掌握了图形学基础的情况下, 只着重掌握以下几点即可.
</p>
</div>
<div id="outline-container-org785d4cc" class="outline-3">
<h3 id="org785d4cc"><span class="section-number-3">5.1.</span> 如何搭建基础项目</h3>
<div class="outline-text-3" id="text-5-1">
<p>
这一点阅读文档 <a href="https://threejs.org/manual/#en/creating-a-scene">Creating a Scene</a> 即可, 它介绍了一个最基础的场景需要什么.
</p>

<p>
在搭建完基础场景后, <b>了解</b> 以下以下几个大类做什么的以及有什么子类(如果有的话)即可:
</p>

<ul class="org-ul">
<li><p>
<a href="https://threejs.org/docs/?q=Camera#api/en/cameras/Camera">Camera</a>
</p>

<p>
相机类
</p></li>

<li><p>
<a href="https://threejs.org/docs/?q=Mesh#api/en/objects/Mesh">Mesh</a>
</p>

<p>
<code>3D</code> 物体类, 一个 <code>3D</code> 物体由一个 <a href="https://threejs.org/docs/?q=Geometry#api/en/core/BufferGeometry">BufferGeometry</a> (缓冲几何体) 实例和一个 <a href="https://threejs.org/docs/?q=Material#api/en/materials/Material">Material</a> (材质类) 实例构成.
</p>

<p>
一个 <code>BufferGeometry</code> 实例整合了 <code>VBO</code> 和 <code>VAO</code>;
</p>

<p>
一个 <code>Material</code> 则是整合了一组 <code>Vertex/Fragment Shader</code>.
</p>

<blockquote>
<p>
实际上 <code>Mesh</code> 应该翻译成网格, 它的父类 <code>Object3D</code> 才应该被翻译成 <code>3D</code> 物体,
</p>

<p>
但是 <code>Object3D</code> 定位应该是抽象类, 所以这里把更具体的 <code>Mesh</code> 翻译成物体.
</p>
</blockquote></li>

<li><p>
<a href="https://threejs.org/docs/?q=Light#api/en/lights/Light">Light</a>
</p>

<p>
光源类, 建议在学习完毕 <a href="../../2020/graphics-opengl-light-and-material.html">图形学 - 光和材质</a> 后再回来了解.
</p></li>

<li><p>
<a href="https://threejs.org/docs/?q=Scene#api/en/scenes/Scene">Scene</a>
</p>

<p>
场景类, 一个包含了 <code>Mesh</code> 实例和 <code>Light</code> 实例的集合, 事实上 <code>Scene/Mesh/Light</code> 的父类都是 <a href="https://threejs.org/docs/?q=Light#api/en/core/Object3D">Object3D</a> 的子类.
</p>

<p>
因此, 从通俗的角度来讲, 场景类就是最顶层的 <code>3D</code> 物体.
</p></li>

<li><p>
<a href="https://threejs.org/docs/?q=WebGLRender#api/en/renderers/WebGLRenderer">WebGLRenderer</a>
</p>

<p>
渲染器, 一个可以调用绘制命令(<code>gl.drawArrays</code> 以及 <code>gl.gl.drawElements</code>)的类.
</p>

<p>
同时包含很多全局设置选项, 比如阴影贴图选项, 背景色等选项.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org2fea439" class="outline-3">
<h3 id="org2fea439"><span class="section-number-3">5.2.</span> 如何把 <code>Shader</code> 应用到物体上</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<code>Three.js</code> 有两种 <code>Material</code> 子类支持 <code>Shader</code> 编程: <a href="https://threejs.org/docs/?q=ShaderMate#api/en/materials/ShaderMaterial">ShaderMaterial</a> 和 <a href="https://threejs.org/docs/?q=ShaderMate#api/en/materials/RawShaderMaterial">RawShaderMaterial</a>.
</p>

<p>
<code>ShaderMaterial</code> 相比 <code>RawShaderMaterial</code> 内置了很多 <a href="https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram">Uniforms/Attributes</a> 和函数,
</p>

<p>
<code>Three.js</code> 的 <code>Shader</code> 编译器支持 <code>#include</code> 宏引入内置 <code>Shader</code> 代码, 从而提供内置函数,
</p>

<p>
这些内置代码在 <a href="https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk">ShaderChunk</a> 中, 可惜的是这些代码并没有在文档中详细描述.
</p>

<p>
初学者开始时应要做到不依赖内置的函数, 能够自己实现, 理由如下:
</p>

<p>
内置函数实现起来不复杂, 是基础得不再能基础的知识, 可以迁移到游戏引擎或者 <code>3D</code> 渲染器框架上.
</p>

<p>
在使用感觉和效率上, <code>RawShaderMaterial</code> 和 <code>WebGL API</code> 差不多, 所以建议使用 <code>ShaderMaterial</code> 进行学习,
</p>

<p>
至少可以免掉定义 <code>Uniforms/Attributes</code> 的功夫.
</p>

<blockquote>
<p>
说起来有点难以置信, <code>RawShaderMaterial</code> 是 <code>ShaderMaterial</code> 的子类.
</p>
</blockquote>

<p>
此外, 也可以在其它内置 <code>Material</code> 子类的基础上进行拓展.
</p>

<p>
比如想要自定义符合 <code>PBR</code> 流程的 <code>Material</code> 类, 最简单的做法应该是基于 <a href="https://github.com/mrdoob/three.js/blob/8722ea5455a6a6623f194b9a60ef5887ac16a4b0/src/materials/MeshStandardMaterial.js">MeshStandardMaterial (r179)</a> 进行修改,
</p>

<p>
而不是直接使用 <code>ShaderMaterial</code> 再实现一遍 <code>PBR</code> 流程, 那么该如何修改呢?
</p>

<p>
在官方文档上可以看到 <a href="https://github.com/mrdoob/three.js/blob/8722ea5455a6a6623f194b9a60ef5887ac16a4b0/src/materials/Material.js">Material (r179)</a> 都有一个 <a href="https://threejs.org/docs/#api/en/materials/Material.onBeforeCompile">onBeforeCompile</a> 方法, 该方法在 <code>shader</code> 程序编译之前被执行.
</p>

<p>
开发者一般不会 <b>直接</b> 调用该方法, 该方法执行的地方有两处, 可在 <a href="https://github.com/mrdoob/three.js/blob/8722ea5455a6a6623f194b9a60ef5887ac16a4b0/src/renderers/WebGLRenderer.js">WebGLRenderer (r179)</a> 中找到:
</p>

<blockquote>
<ul class="org-ul">
<li><p>
<code>WebGLRenderer.compile</code>
</p>

<p>
<code>prepareMaterial</code>
</p>

<p>
<code>getProgram</code>
</p>

<p>
<code>Material.onBeforeCompile</code>
</p></li>
</ul>


<ul class="org-ul">
<li><p>
<code>WebGLRenderer.render</code>
</p>

<p>
<code>renderTransmissionPass</code>
</p>

<p>
<code>renderObjects</code>
</p>

<p>
<code>renderObject</code>
</p>

<p>
<code>WebGLRenderer.renderBufferDirect</code>
</p>

<p>
<code>setProgram</code>
</p>

<p>
<code>getProgram</code>
</p>

<p>
<code>Material.onBeforeCompile</code>
</p></li>
</ul>
</blockquote>

<p>
简单来说是调用在 <code>Shader</code> 解析和编译之前. <code>onBeforeCompile</code> 的第一个参数是一个 <code>Shader</code> 对象(参考 <code>ShaderMaterial</code> 的参数),
</p>

<p>
这个 <code>Shader</code> 对象代表着当前材质的所有 <code>Shader</code> 信息, 包括 <code>Vertex/Fragment Shader</code> 的代码, 该对象会被用于后续的解析和编译阶段.
</p>

<p>
因此, 可以在这个函数里对 <code>Shader</code> 对象进行修改影响最终结果.
</p>

<p>
这里推荐阅读 <a href="https://github.com/pailhead/three.js/blob/materials-multi-uv/examples/webgl_materials_extended_multiple_uvs.html">webgl materials extended multiple uvs</a> 和 <a href="https://medium.com/@pailhead011/extending-three-js-materials-with-glsl-78ea7bbb9270">extending-three-js-materials-with-glsl</a> 这两个参考资料.
</p>
</div>
</div>
<div id="outline-container-orge52208c" class="outline-3">
<h3 id="orge52208c"><span class="section-number-3">5.3.</span> 如何进行后处理</h3>
<div class="outline-text-3" id="text-5-3">
<p>
了解如何 <a href="https://threejs.org/manual/#en/how-to-use-post-processing">使用 EffectComposer 类</a> 和各种内置 <a href="https://github.com/mrdoob/three.js/blob/8722ea5455a6a6623f194b9a60ef5887ac16a4b0/examples/jsm/postprocessing/Pass.js">Pass</a> 的子类完成后处理.
</p>

<p>
诚然, 内置后处理效果是无法满足全部人的需求, 所以 <code>Three.js</code> 也开放了自定义后处理效果的能力.
</p>

<p>
目前有两种自定义后处理效果的方法, 一是为 <code>ShaderPass</code> 编写 <code>Shader</code>, 上一个文档链接有说明如何进行;
</p>

<p>
第二种就是继承 <code>Pass</code> 类实现自定义 <code>Pass</code>, 实现自己想要的后处理效果.
</p>

<p>
这两种做法适用于不同情况, 如果只是想直接对渲染结果进行后处理, 那么直接使用 <code>ShaderPass</code> 方案;
</p>

<p>
如果后处理需要使用到场景的深度贴图/法线贴图等内容, 那么就得使用定义 <code>Pass</code> 子类方案.
</p>

<p>
生成场景的深度贴图/法线贴图需要额外的渲染步骤, 它们本身也是后处理, 所以这种情况就是多阶段后处理,
</p>

<p>
换而言之, 多阶段后处理就得使用定义 <code>Pass</code> 子类方案.
</p>

<p>
多阶段后处理要求掌握 <a href="https://threejs.org/docs/?q=WebGLRender#api/en/renderers/WebGLRenderTarget">WebGLRenderTarget</a> 类的用法, 该类所对应的就是帧缓冲.
</p>

<p>
可惜的是, 文档并没有该类的使用例子, 这里给出两个例子: 生成场景的深度贴图, 以及生成场景的法线贴图.
</p>

<p>
这两个算是有代表性的例子, 前者代表着特殊贴图的生成和读取, 后者代表通用贴图的生成和读取.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">width</span> = 1920, <span style="color: #eedd82;">height</span> = 1080, <span style="color: #eedd82;">samples</span> = 8;

<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">scene</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.Scene</span>();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">camera</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.PerspectiveCamera</span>(75, width / height, 0.5, 2000);

<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">renderer</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.WebGLRenderer</span>(width, height, { samples });

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29983;&#25104;&#22330;&#26223;&#30340;&#27861;&#32447;&#36148;&#22270;
</span>{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21019;&#24314;&#27861;&#32447;&#26448;&#36136;
</span>  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">normalMaterial</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.ShaderMaterial</span>({
    uniforms: {},
    vertexShader: <span style="color: #ffa07a;">`
varying vec3 vNormal;

void main () {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  vNormal = normalize(normalMatrix * normal);
}
  `</span>,
    fragmentShader: <span style="color: #ffa07a;">`
varying vec3 vNormal;

void main () {
  vec3 color = vNormal * 0.5 + 0.5;
  gl_FragColor = vec4(color, 1.0);
}
  `</span>
  });
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21019;&#24314;&#29992;&#20110;&#33719;&#21462;&#27861;&#32447;&#22330;&#26223;&#28210;&#26579;&#32467;&#26524;&#30340; FBO, &#30456;&#24403;&#20110; const normalFBO = gl.createFramebuffer();
</span>  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">normalFBO</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.WebGLRenderTarget</span>(width * samples, height * samples, {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21487;&#20197;&#22312;&#36825;&#37324;&#35774;&#32622;&#36148;&#22270;&#21442;&#25968;: wrapS/wrapT/magFilter/minFilter &#31561;&#31561;
</span>  });
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35201;&#24819;&#33719;&#21462;&#22330;&#26223;&#30340;&#27861;&#32447;&#36148;&#22270;, &#35753;&#27861;&#32447;&#26448;&#36136;&#35206;&#30422;&#22330;&#26223;&#20013;&#25152;&#26377;&#29289;&#20307;&#30340;&#21407;&#26448;&#36136;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Scene &#31867;&#26377;&#19968;&#20010; overrideMaterial &#23646;&#24615;, &#21487;&#29992;&#20110;&#20020;&#26102;&#35206;&#30422;&#22330;&#26223;&#26448;&#36136;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312;&#35206;&#30422;&#21069;&#24212;&#35813;&#20808;&#20445;&#21407;&#20808;&#30340; overrideMaterial &#23646;&#24615;&#20540;
</span>  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">overrideMaterialOriginal</span> = scene.overrideMaterial;
  scene.overrideMaterial = normalMaterial;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32465;&#23450;&#24103;&#32531;&#20914;, &#31867;&#20284;&#20110; gl.bindFramebuffer(gl.FRAMEBUFFER, normalFBO)
</span>  renderer.setRenderTarget(normalFBO);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36827;&#34892;&#28210;&#26579;, &#30456;&#24403;&#20110;&#35843;&#29992; gl.drawArrays/gl.drawEelements
</span>  renderer.render(scene, camera);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36824;&#21407; scene.overrideMaterial &#23646;&#24615;
</span>  scene.overrideMaterial = overrideMaterialOriginal;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32465;&#23450;&#24103;&#32531;&#20914;, &#21518;&#32493;&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#21040;&#23631;&#24149;&#19978;
</span>  renderer.setRenderTarget(<span style="color: #7fffd4;">null</span>);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">normalFBO.texture &#35775;&#38382;&#27861;&#32447;&#36148;&#22270;
</span>}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29983;&#25104;&#22330;&#26223;&#30340;&#28145;&#24230;&#36148;&#22270;
</span>{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29983;&#25104;&#22330;&#26223;&#30340;&#28210;&#26579;&#32467;&#26524;&#36148;&#22270;&#27604;&#36215;&#27861;&#32447;&#36148;&#22270;&#35201;&#31616;&#21333;&#24471;&#22810;, Three.js &#24050;&#32463;&#20869;&#37096;&#23436;&#25104;&#35206;&#30422;&#21644;&#36824;&#21407;&#25972;&#20010;&#22330;&#26223;&#30340;&#26448;&#36136;
</span>  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">depthFBO</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.WebGLRenderTarget</span>(width * samples, height * samples);
  depthFBO.depthTexture = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">THREE.DepthTexture</span>(width * samples, height * samples);
  renderer.setRenderTarget(depthFBO);
  renderer.render(scene, camera);
  renderer.setRenderTarget(<span style="color: #7fffd4;">null</span>);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">depthFBO.depthTexture &#35775;&#38382;&#28210;&#26579;&#32467;&#26524;&#36148;&#22270;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/depth.glsl.js
</span>}  
</pre>
</div>

<p>
接下来要做的就是明白如何继承 <code>Pass</code> 类需要实现哪些关键内容,
</p>

<p>
不幸的是, 文档没有关于 <code>Pass</code> 类的描述, 幸运的是 <code>Pass</code> 类本身就很简单, 它的定位是抽象类,
</p>

<p>
意味着不会直接对它进行实例化, 而是作为父类使用.
</p>

<p>
<code>Pass</code> 类的源文件提供了 <code>Pass</code> 和 <code>FullScreenQuad</code> 两个类,
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00ffff;">import</span> {
        BufferGeometry,
        Float32BufferAttribute,
        OrthographicCamera,
        Mesh
} from <span style="color: #ffa07a;">'three'</span>;

<span style="color: #ffa07a;">/**
 * Abstract base class for all post processing passes.
 *
 * This module is only relevant for post processing with {@link WebGLRenderer}.
 *
 * @abstract
 * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';
 */</span>
<span style="color: #00ffff;">class</span> Pass {

        <span style="color: #ffa07a;">/**
         * Constructs a new pass.
         */</span>
        constructor() {

                <span style="color: #ffa07a;">/**
                 * This flag can be used for type testing.
                 *
                 * @type {boolean}
                 * @readonly
                 * @default true
                 */</span>
                <span style="color: #7fffd4;">this</span>.isPass = <span style="color: #7fffd4;">true</span>;

                <span style="color: #ffa07a;">/**
                 * If set to `true`, the pass is processed by the composer.
                 *
                 * @type {boolean}
                 * @default true
                 */</span>
                <span style="color: #7fffd4;">this</span>.enabled = <span style="color: #7fffd4;">true</span>;

                <span style="color: #ffa07a;">/**
                 * If set to `true`, the pass indicates to swap read and write buffer after rendering.
                 *
                 * @type {boolean}
                 * @default true
                 */</span>
                <span style="color: #7fffd4;">this</span>.needsSwap = <span style="color: #7fffd4;">true</span>;

                <span style="color: #ffa07a;">/**
                 * If set to `true`, the pass clears its buffer before rendering
                 *
                 * @type {boolean}
                 * @default false
                 */</span>
                <span style="color: #7fffd4;">this</span>.clear = <span style="color: #7fffd4;">false</span>;

                <span style="color: #ffa07a;">/**
                 * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
                 * pass chain gets automatically rendered to screen, no matter how this property is configured.
                 *
                 * @type {boolean}
                 * @default false
                 */</span>
                <span style="color: #7fffd4;">this</span>.renderToScreen = <span style="color: #7fffd4;">false</span>;

        }

        <span style="color: #ffa07a;">/**
         * Sets the size of the pass.
         *
         * @abstract
         * @param {number} width - The width to set.
         * @param {number} height - The height to set.
         */</span>
        setSize( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">width, height</span><span style="color: #ff7f24;"> */</span> ) {}

        <span style="color: #ffa07a;">/**
         * This method holds the render logic of a pass. It must be implemented in all derived classes.
         *
         * @abstract
         * @param {WebGLRenderer} renderer - The renderer.
         * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
         * destination for the pass.
         * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
         * previous pass from this buffer.
         * @param {number} deltaTime - The delta time in seconds.
         * @param {boolean} maskActive - Whether masking is active or not.
         */</span>
        render( <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">renderer, writeBuffer, readBuffer, deltaTime, maskActive</span><span style="color: #ff7f24;"> */</span> ) {

                console.error( <span style="color: #ffa07a;">'THREE.Pass: .render() must be implemented in derived pass.'</span> );

        }

        <span style="color: #ffa07a;">/**
         * Frees the GPU-related resources allocated by this instance. Call this
         * method whenever the pass is no longer used in your app.
         *
         * @abstract
         */</span>
        dispose() {}

}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Helper for passes that need to fill the viewport with a single quad.
</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">_camera</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">OrthographicCamera</span>( - 1, 1, 1, - 1, 0, 1 );

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://github.com/mrdoob/three.js/pull/21358
</span>
<span style="color: #00ffff;">class</span> FullscreenTriangleGeometry <span style="color: #00ffff;">extends</span> BufferGeometry {

        constructor() {

                <span style="color: #00ffff;">super</span>();

                <span style="color: #7fffd4;">this</span>.setAttribute( <span style="color: #ffa07a;">'position'</span>, <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Float32BufferAttribute</span>( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
                <span style="color: #7fffd4;">this</span>.setAttribute( <span style="color: #ffa07a;">'uv'</span>, <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Float32BufferAttribute</span>( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

        }

}

<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">_geometry</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">FullscreenTriangleGeometry</span>();


<span style="color: #ffa07a;">/**
 * This module is a helper for passes which need to render a full
 * screen effect which is quite common in context of post processing.
 *
 * The intended usage is to reuse a single full screen quad for rendering
 * subsequent passes by just reassigning the `material` reference.
 *
 * This module can only be used with {@link WebGLRenderer}.
 *
 * @augments Mesh
 * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';
 */</span>
<span style="color: #00ffff;">class</span> FullScreenQuad {

        <span style="color: #ffa07a;">/**
         * Constructs a new full screen quad.
         *
         * @param {?Material} material - The material to render te full screen quad with.
         */</span>
        constructor( material ) {

                <span style="color: #7fffd4;">this</span>._mesh = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Mesh</span>( _geometry, material );

        }

        <span style="color: #ffa07a;">/**
         * Frees the GPU-related resources allocated by this instance. Call this
         * method whenever the instance is no longer used in your app.
         */</span>
        dispose() {

                <span style="color: #7fffd4;">this</span>._mesh.geometry.dispose();

        }

        <span style="color: #ffa07a;">/**
         * Renders the full screen quad.
         *
         * @param {WebGLRenderer} renderer - The renderer.
         */</span>
        render( renderer ) {

                renderer.render( <span style="color: #7fffd4;">this</span>._mesh, _camera );

        }

        <span style="color: #ffa07a;">/**
         * The quad's material.
         *
         * @type {?Material}
         */</span>
        get material() {

                <span style="color: #00ffff;">return</span> <span style="color: #7fffd4;">this</span>._mesh.material;

        }

        set material( value ) {

                <span style="color: #7fffd4;">this</span>._mesh.material = value;

        }

}

<span style="color: #00ffff;">export</span> { Pass, FullScreenQuad };
</pre>
</div>

<p>
其中 <code>FullScreenQuad</code> 是一个用于绑定 <code>ShaderMaterial</code> 并渲染的上下文,
</p>

<p>
它向外提供了 <code>material</code> 的 <code>setter</code> 用于内部的 <code>mesh</code> 绑定 <code>ShaderMaterial</code>,
</p>

<p>
(PS: 它的 <code>mesh</code> 覆盖了整个屏幕空间的, 然而这个 <code>mesh</code> 是一个三角形而不是矩形, 这里是<a href="https://github.com/mrdoob/three.js/pull/21358">原因</a>.)
</p>

<p>
提供的 <code>render( renderer )</code> 方法指定 <code>renderer</code> 调用绘制命令(<code>drawcall</code>), 用于绘制这个 <code>mesh</code> 对象从而执行绑定的 <code>ShaderMaterial</code>;
</p>

<p>
<code>renderer</code> 是一个 <code>WebGLRenderer</code> 实例, 在调用 <code>render( renderer )</code> 方法前,
</p>

<p>
<code>renderer</code> 应该先调用 setRendererTarget 方法设定渲染结果的输出保存在哪里,
</p>

<p>
<code>WebGLRenderer.setRendererTarget</code> 的参数是一个 <code>WebGLRenderTarget</code> 实例.
</p>

<p>
<code>Pass</code> 类主要是为 <code>FullScreenQuad</code> 实例的渲染提供一个调度, 这个调度需要在 <code>Pass</code> 提供的 <code>render</code> 方法里面完成,
</p>

<p>
这个 <code>render</code> 方法的主要内容应该是从 <code>readBuffer</code> 从读取上一个渲染阶段的渲染结果,
</p>

<p>
用到 <code>FullScreenQuad</code> 实例的渲染计算上, 再把这个阶段的渲染结果根据情况通过输出到下一个渲染阶段 (<code>writeBuffer</code>) 或屏幕上,
</p>

<p>
完整的调度在 <code>EffectComposer</code> 的 <code>render</code> 方法中可以找到, 本质就是一个遍历 <code>Pass</code> 实例列表的循环,
</p>

<p>
每遍历一个 <code>Pass</code>, 默认情况下都会把 <code>writeBuffer</code> 和 <code>readBuffer</code> 两者进行交换, 这样可以把当前 <code>Pass</code> 的渲染结果传递到下一个 <code>Pass</code> 上.
</p>

<p>
(PS: 由于源文件内容过长, 这里只截取其中的 <code>render</code> 方法)
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">examples/jsm/postprocessing/EffectComposer.js
</span>render( deltaTime ) {

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">deltaTime value is in seconds
</span>
  <span style="color: #00ffff;">if</span> ( deltaTime === <span style="color: #7fffd4;">undefined</span> ) {

    deltaTime = <span style="color: #7fffd4;">this</span>.clock.getDelta();

  }

  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">currentRenderTarget</span> = <span style="color: #7fffd4;">this</span>.renderer.getRenderTarget();

  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">maskActive</span> = <span style="color: #7fffd4;">false</span>;

  <span style="color: #00ffff;">for</span> ( <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">i</span> = 0, <span style="color: #eedd82;">il</span> = <span style="color: #7fffd4;">this</span>.passes.length; i &lt; il; i ++ ) {

    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">pass</span> = <span style="color: #7fffd4;">this</span>.passes[ i ];

    <span style="color: #00ffff;">if</span> ( pass.enabled === <span style="color: #7fffd4;">false</span> ) <span style="color: #00ffff;">continue</span>;

    pass.renderToScreen = ( <span style="color: #7fffd4;">this</span>.renderToScreen &amp;&amp; <span style="color: #7fffd4;">this</span>.isLastEnabledPass( i ) );
    pass.render( <span style="color: #7fffd4;">this</span>.renderer, <span style="color: #7fffd4;">this</span>.writeBuffer, <span style="color: #7fffd4;">this</span>.readBuffer, deltaTime, maskActive ); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25191;&#34892; Pass &#23454;&#20363;
</span>
    <span style="color: #00ffff;">if</span> ( pass.needsSwap ) {     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#40664;&#35748;&#24773;&#20917;&#19979; Pass &#23454;&#20363;&#30340; needsSwap &#25104;&#21592;&#20026; true
</span>
      <span style="color: #00ffff;">if</span> ( maskActive ) {

      <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">context</span> = <span style="color: #7fffd4;">this</span>.renderer.getContext();
      <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">stencil</span> = <span style="color: #7fffd4;">this</span>.renderer.state.buffers.stencil;

      <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
</span>      stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );

      <span style="color: #7fffd4;">this</span>.copyPass.render( <span style="color: #7fffd4;">this</span>.renderer, <span style="color: #7fffd4;">this</span>.writeBuffer, <span style="color: #7fffd4;">this</span>.readBuffer, deltaTime );

      <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">context.stencilFunc( context.EQUAL, 1, 0xffffffff );
</span>      stencil.setFunc( context.EQUAL, 1, 0xffffffff );

      }

      <span style="color: #7fffd4;">this</span>.swapBuffers();       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20132;&#25442; readBuffer &#21644; writeBuffer
</span>
    }

    <span style="color: #00ffff;">if</span> ( MaskPass !== <span style="color: #7fffd4;">undefined</span> ) {

      <span style="color: #00ffff;">if</span> ( pass <span style="color: #00ffff;">instanceof</span> <span style="color: #98fb98;">MaskPass</span> ) {

      maskActive = <span style="color: #7fffd4;">true</span>;

      } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> ( pass <span style="color: #00ffff;">instanceof</span> <span style="color: #98fb98;">ClearMaskPass</span> ) {

      maskActive = <span style="color: #7fffd4;">false</span>;

      }

    }

  }                             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Loop ends here
</span>
  <span style="color: #7fffd4;">this</span>.renderer.setRenderTarget( currentRenderTarget );

}
</pre>
</div>

<p>
因此结论是, 在实现 <code>Pass</code> 的子类时, 重点是实现它 <code>render</code> 方法,
</p>

<p>
<code>render</code> 所作的事情可以概括为:
</p>

<p>
从 <code>readBuffer</code> 读取上一个 <code>Pass</code> 的渲染结果, 然后创建 <code>ShaderMaterial</code> 绑定给 <code>FullScreenQuad</code>,
</p>

<p>
调用 <code>FullScreenQuad</code> 的 <code>render</code> 方法完成后处理, 最后把处理结果输出到屏幕上, 或者通过 <code>writeBuffer</code> 输出到下一个 <code>Pass</code> 中.
</p>

<p>
作为学习参考, 内置的 <a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/FilmPass.js">FilmPass</a> 和 <a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/SavePass.js">SavePass</a> 因复杂度适中非常适合作为入门例子, 适合以 <a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/postprocessing/SSAOPass.js">SSAOPass</a> 作为进阶例子.
</p>
</div>
</div>
<div id="outline-container-orga0d913d" class="outline-3">
<h3 id="orga0d913d"><span class="section-number-3">5.4.</span> 项目结构推荐</h3>
<div class="outline-text-3" id="text-5-4">
<p>
如果按照文档教程的方式开发项目, 把所有内容都写在一个文件上, 必然会面临复杂度提高且难以维护的问题.
</p>

<p>
这里分享一套本人从 <a href="https://www.bilibili.com/video/BV13jU4YoErU/">Three.js Journey</a> 总结的项目结构, 以此解决问题.
</p>

<p>
(PS: 本人使用了 <code>TypeScript</code> 开发, 但对于 <code>JavaScript</code> 也合适, <a href="../../../files/Outline.zip">例子的源代码</a>)
</p>

<blockquote>
<p>
eventEmitter.ts: 事件派发器
disposer.ts:     专门针对 <code>Scene</code> 实例进行内存释放
access.ts:       应对模块化, 对 <code>Scene/Camera/WebGLRenderer</code> 等实例进行全局化
camera.ts:       对全局 <code>Camera</code> 实例进行初始化和配置
main.ts:         对 <code>Scene/Camera/WebGLRenderer</code> 等全局实例进行调度, 项目的入口
materials/:      存放自定义材质
postProcessing/: 存放自定义后处理
postProc.ts:     对全局 <code>EffectComposer</code> 实例进行初始化和配置
renderer.ts:     对全局 <code>WebGLRenderer</code> 实例进行初始化和配置
scene.ts:        对全局 <code>Scene</code> 实例进行初始化和配置, 该文件负责定义加载 <code>3D</code> 物体, 设置光源
</p>
</blockquote>

<p>
这个结构的思路是, 如果新增一个重要的全局实例, 那么就为它单独编写一个模块进行初始化和配置,
</p>

<p>
这样即可以有效地保证模块的复杂程度低于一定程度, 同时也让结构看上去更加清晰.
</p>

<p>
比如 <code>postProc.ts</code> 就是专门为全局 <code>EffectComposer</code> 实例编写的模块;
</p>

<p>
这个结构还方便拓展, 比如想对场景定义一些鼠标事件, 可以在不动 <code>scene.ts</code> 模块的情况下单独写一个 <code>mouse.ts</code> 的模块完成,
</p>

<p>
当然这少不了 <code>eventEmitter.ts</code> 的功劳, 它是 <code>access.ts</code> 的父类, 主要作用是让模块之间进行通信,
</p>

<p>
具体可以参考 <code>renderer.ts</code> 如何调度(<code>EventEmitter.tirgger</code> 方法)这些钩子,
</p>

<p>
以及 <code>postProc.ts</code> 如何设置(<code>EventEmitter.on</code> 方法)和卸载(<code>EventEmitter.off</code>)钩子.
</p>

<p>
大部分情况下, 基本上只有 <code>postProc.ts</code> 和 <code>scene.ts</code> 两个文件需要进行修改, 其它文件基本定型.
</p>

<p>
自定义材质和后处理效果都属于 <code>Shader</code> 编程的范围, 所以把它们单独存放.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2022-02-11</p>
<p class="author">Author: saltb0rn</p>
<p class="date">Created: 2025-09-08 Mon 22:07</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
