#+title: How to Read and Do Proofs 6th Edition 阅读笔记
#+date: 2025-05-12
#+index: How to Read and Do Proofs 6th Edition 阅读笔记
#+tags: Math
#+status: wd
#+begin_abstract
xxx
#+end_abstract

*** Chapter 1: The Truth of It All

真值表

#+caption: 真值表
| A     | B     | A implies B / $\mathbf{A} \Rightarrow \mathbf{B}$ |
|-------+-------+---------------------------------|
| True  | True  | True                            |
| True  | False | False                           |
| False | True  | True                            |
| False | False | True                            |

证明一个命题(=proposition=)的本质是:

假定 $\mathbf{A}$ 是 =True=, 尝试以 $\mathbf{A} \Rightarrow \mathbf{B}$ 为 =True= 为目的推断出 $\mathbf{B}$ 为 =True=, 来得出 $\mathbf{A} \Rightarrow \mathbf{B}$,

而 $\mathbf{B}$ 的真值需要以 $\mathbf{A}$ 作为依据, 并非简单的 $\mathbf{A}$ 为 =True= 和 $\mathbf{B}$ 为 =True= 就可以了.

#+begin_quote
其实原文是 "you can assume that A is true; your job is to conclude that B is true",

并没有 "尝试以 $\mathbf{A} \Rightarrow \mathbf{B}$ 为 =True= 为目的" 这一句或类似表达, 这里只是把上下文的信息结合在里面了.

从而强调证明的目的是得出 $\mathbf{A} \Rightarrow \mathbf{B}$ 的真值, 推断出 $\mathbf{B}$ 为 =True= 只是实现目的的手段.

这么一来衍生出了一个疑问:

为什么不假设 $\mathbf{A}$ 为 =False= 和推断 $\mathbf{B}$ 为 =True= 来得出 $\mathbf{A} \Rightarrow \mathbf{B}$ 为 =True= 的方式来进行证明呢?

因为根据真值表, 当 $\mathbf{A}$ 为 =False= 时, 不管 $\mathbf{B}$ 是 =True= 还是 =False=, $\mathbf{A} \Rightarrow \mathbf{B}$ 都为 =True=, 这样的话证明就变得没必要了;

而当 $\mathbf{A}$ 为 =True= 时, 在以证明 $\mathbf{A} \Rightarrow \mathbf{B}$ 为 =True= 的前提下, $\mathbf{B}$ 只能为 =True=.
#+end_quote

*** Chapter 2: 前后向证明法 (The Forward-Backward Method)

前后向证明法是最基本的证明方法, 同时也是所有其它证明方法的基础. 它也被称为直接证明法

*** Chapter 12: 归纳法 (Induction)

归纳法适用于证明命题集合 $\left\{ P(n) \mid n \gt 0, n \in \mathbb{Z} \right\}$ 的所有命题都为 =True=.

它的核心是假设 $P(n)$ 为 =True= 并尝试以 $P(n)$ 推断出 $P(n+1)$ 为 =True=, 从而证明 $P(n) \Rightarrow P(n+1)$ 为 =True=.

这样就能像多米诺骨牌一样, 只要证明其中一个命题为 =True=, 就可以得出它的下一个命题也为 =True=,

为了保证覆盖到所有命题, 需要证明第一个命题 $P(1)$ 为 =True=.

#+begin_quote
学习过编程的人应该听说过递归(=recursion=)这个概念, 它其实就是源于归纳法.

递归会把问题划分成多个规模更小的问题, 使得问题更容易解决,

这个划分过程并非一步到位的, 一次划分得到的问题还可能需要继续划分, 一直划分直到问题能够解决的程度.

把需要划分的情况称为可递归情况, 把无需划分的情况称为基本情况.

回到归纳法上, $P(1)$ 就是基本情况, $n \gt 1$ 时 $P(n)$ 属于可递归情况,

$P(n) \Rightarrow P(n+1)$ 在说明如何对 $P(n)$ 进行"扩大规模"得到 $P(n+1)$;

递归则是反过来, 知道如何把小变大, 那么就知道如何把大拆小, 直到拆到 $P(1)$ 为止;

这两者本质上是一样的.
#+end_quote
