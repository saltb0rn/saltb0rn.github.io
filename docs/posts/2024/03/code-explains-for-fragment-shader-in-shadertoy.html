<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-09-25 Thu 22:12 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ShaderToy常见代码解释 (收录中)</title>
<meta name="author" content="saltb0rn" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<!-- <script type="text/javascript" src="../../../js/live.js" defer></script> -->
<script src="../../../js/main.js" defer></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="../../../js/mathjax/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content" class="content">
<h1 class="title">ShaderToy常见代码解释 (收录中)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga959dba">常见的困惑</a>
<ul>
<li><a href="#orgbcef113">GLSL 矩阵储存方式</a></li>
</ul>
</li>
<li><a href="#org9ca5951">常见的 UV 计算</a>
<ul>
<li><a href="#orgb6aee9b">UV - 计算片元在屏幕上所对应的 UV 坐标</a></li>
<li><a href="#org61e9207">UV计算 - 平铺(tiling)</a></li>
</ul>
</li>
<li><a href="#orgc8a40ab">GLSL 内置函数</a>
<ul>
<li><a href="#org89a9de2">函数 - smoothstep</a>
<ul>
<li><a href="#org4fe9c50">The Book Of Shaders 的 smoothstep 函数绘制 Shader 解析</a></li>
<li><a href="#org601a049">编写 <code>Fragment Shader</code> 的思路</a></li>
</ul>
</li>
<li><a href="#orgd9238f0">函数 - mix</a></li>
<li><a href="#org222b95a">函数 - dFdx/dFdy</a></li>
<li><a href="#orgd3db1e0">函数 - fract</a></li>
<li><a href="#orga43090a">函数 - faceforward</a></li>
<li><a href="#orga1fd365">函数 - reflect</a></li>
<li><a href="#org407522c">函数 - refract</a></li>
<li><a href="#orga70f782">函数 - packUnorm 和 函数 - unpackUnorm</a></li>
<li><a href="#org2bd0a75">函数 - modf</a></li>
<li><a href="#org55ed4f2">函数 - texture</a></li>
</ul>
</li>
<li><a href="#org71c7f7b">常用自定义函数</a>
<ul>
<li><a href="#orgcfe532a">remap 函数</a></li>
<li><a href="#org8171fdf">调色板生成</a></li>
<li><a href="#orgfe8dc03">缓动函数</a></li>
</ul>
</li>
<li><a href="#org17cdc5d">基础噪声</a>
<ul>
<li><a href="#orgeb5d13b">随机函数</a>
<ul>
<li><a href="#org491d238">高维随机函数</a></li>
<li><a href="#orge21d4a9">向量值函数形式的随机函数</a></li>
<li><a href="#orge214715">三角函数的缺陷</a></li>
</ul>
</li>
<li><a href="#org8fa24ce">噪声函数</a>
<ul>
<li><a href="#org1db0250">值噪声</a></li>
<li><a href="#orge8770ab">梯度噪声</a></li>
<li><a href="#org4cc56e9">单形噪声</a></li>
<li><a href="#org91c5f46">细胞噪声</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org19b4108">SDF</a>
<ul>
<li><a href="#orgde7d658">估算点与几何解析式的距离</a>
<ul>
<li><a href="#org9decf7f">案例一: 估算点与曲线之间的距离</a></li>
<li><a href="#org046c655">案例二: 估算点与直线之间的距离</a></li>
<li><a href="#org3223fb2">初识 SDF</a></li>
<li><a href="#org1bf9685">对 SDF 描述的图形进行变换</a></li>
<li><a href="#org65fb9b1">图形组合 - 布尔操作符 (boolean operators)</a></li>
</ul>
</li>
<li><a href="#orgddc17a2">2D SDF</a>
<ul>
<li><a href="#orgfb905a7">计算点与线段之间的距离</a></li>
<li><a href="#org28ae747">计算点与矩形之间的距离</a></li>
<li><a href="#org5ea0a5f">计算点与不规则多边形之间的距离</a></li>
</ul>
</li>
<li><a href="#org3cf360a">3D SDF</a>
<ul>
<li><a href="#ray-marching">Ray Marching</a></li>
<li><a href="#org4cd1da7">3D SDF 变换的注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3a77868">分形 (Fractal)</a>
<ul>
<li><a href="#org7f597d0">分形布朗运动 (Fractal Brownian Motion)</a>
<ul>
<li><a href="#org42e981f">噪声的导数解析式</a></li>
</ul>
</li>
<li><a href="#org8635a66">谢尔宾斯基三角形 (Sierpiński Triangle)</a></li>
<li><a href="#orgdb00242">madelbrot set</a></li>
</ul>
</li>
<li><a href="#org3c22e8c">图像处理</a>
<ul>
<li><a href="#orgaeb22ab">卷积 (Convolution)</a></li>
<li><a href="#sobel">Sobel 核</a>
<ul>
<li><a href="#orgc193edb">GlslViewer 的多阶段渲染</a></li>
</ul>
</li>
<li><a href="#laplacian">拉普拉斯核 (Laplacian 核)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract" id="org4bb04a5">
<p>
在编程这一方面, 个人认同这一个观点: 要想实现某个东西最有效的办法是抄别人的代码, 并且要抄得明白.
</p>

<p>
不要看这句话看似很 <code>low</code>, 它里面其实有这么一些对应关系, "抄得明白"对应知道原理, "抄别人代码"对应实践.
</p>

<p>
对于 <code>ShaderToy</code> 也是一样的, 你想像那些前辈一样实现酷炫的效果, 就得脸皮厚一点去 <b>抄明白</b> 他们的代码, 大胆承认抄别人的代码.
</p>

<p>
想做到 <b>抄明白</b>, 得了解代码使用了哪些知识, 这些知识就像是积木一样, 我们要做的利用这些积木搭出自己想要的东西,
</p>

<p>
这里就是专门介绍这些常用的积木, 它们基本上是数学知识, 主要是线性代数, 微积分以及概率论的这三个方面,
</p>

<p>
当然, 使用代码实现数学内容少不了数值分析这一门学问, 另外还包含一些数字信号处理和图像处理的的知识.
</p>

<p>
但是本文并不是要成为数学的入门课, 而是学习如何用它们解决图形上的一些问题, 同时尽量会说明引用了什么数学定理,
</p>

<p>
方便读者(包括我本人)遇到不会的数学知识可以自行去搜索学习, 尽可能地给初学者提供一个系统的入门指南.
</p>

<p>
这里有很多内容来自于 <a href="https://thebookofshaders.com/">The Book of Shaders</a> 这本书(截止目前为止还没写完), 以及 <a href="https://iquilezles.org/articles/">Inigo Quilez 的文章</a>,
</p>

<p>
相当一部分来自于 <a href="https://www.youtube.com/@TheArtofCodeIsCool/featured">The Art of Code 频道</a>, 少部分参考了 <a href="https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/">Programming Tricks in ShaderToy / GLSL</a>.
</p>

<p>
<code>Inigo Quilez</code> 的文章要求读者有前面提到的数学基础, 所以读不懂不要气馁, 等掌握了基础再来读即可.
</p>

<p>
有很多时候需要作图以及计算等式, 所以个人建议最后学一两个这方面的工具,
</p>

<p>
简单作图的话推荐 <a href="https://graphtoy.com">GraphToy</a>, 想要作一些复杂的图以及公式计算则推荐 <a href="https://maxima.sourceforge.io/">Maxima</a>.
</p>

<p>
另外, 如果你不喜欢在 <code>ShaderToy</code> 上编码而是喜欢本地进行实验, 那么推荐使用 <a href="https://github.com/patriciogonzalezvivo/glslViewer">glslViewer</a>,
</p>

<p>
和 <code>glslViewer</code> 的差别基本在于内置 <code>Uniforms</code> 名字不太一样, 并且比其 <code>ShaderToy</code> 还支持更高版本的 <code>GLSL</code>,
</p>

<p>
你想更加全面得接触 <code>GLSL</code> 那么 <code>glslViewer</code> 更好.
</p>

<p>
推荐完工具后就是个人的数学学习心得了 (仅供参考, 不作标准), 个人认为学数学应 <b>尽可能</b> 地对给出定理刨根问底, 具体做法是:
</p>

<p>
理解定理 \(P\) 的证明思路, 知道每一个证明步骤是以哪些定理/公理作为根据, 所以在这个过程中可能也会遇到一些陌生的定理 \(L\),
</p>

<p>
如果定理 \(L\) 的定义影响到你对定理 \(P\) 证明的理解, 那么以同样做法去理解定理 \(L\) 的证明思路, 再回过头来接着理解定理 \(P\) 的证明;
</p>

<p>
否则就默认定理 \(L\) 是正确的, 继续理解定理 \(P\) 的证明.
</p>

<p>
简单来说, 学数学是一个递归过程, 这就会为什么数学里存在公理且公理是不可证明的, 因为不可能一直刨根问底的.
</p>

<p>
理解定理的证明思路, 是为了理解定理诞生的动机及思想, 只有这样避免死记硬背, 为后面的运用自如打下基础.
</p>

<p>
<b>复杂理论最初必定是源自一个简单的想法</b>, 不过想找到这个简单想法可不简单.
</p>

<p>
最后就是对于知识的运用, 当到了知道哪些知识可以解决什么问题, 以及看到问题可以联想到用哪些知识解决, 就说明到达运用自如的地步了,
</p>

<p>
而在遇到一些从未见过的新问题时, 也能联想到使用哪些知识进行分析和解决, 到了这一个地步就极有可能发掘出知识的新用法,
</p>

<p>
而这种程度的联想就是人们口中的灵感，也是人们口中天才的特质.
</p>

<p>
想要到达运用自如的境界需要经常练习, 以及找出知识与知识之间的联系, 就比如多元函数的梯度向量与导数与法线向量三者之间的联系.
</p>

<p>
所以说, 学数学依靠的是耐心和理解.
</p>

<blockquote>
<p>
你可能会有异议, 天赋就不重要了吗?
</p>

<p>
我的理由是: 每个人对天赋的定义是不统一的, 也就是天赋缺乏良定义, 学习的一个重要原则是不能使用有歧义的概念去描述问题.
</p>
</blockquote>

<p>
对于抄代码也一样, 先找出这段代码背后是哪些知识原理, 解决什么类型的问题, 然后抄到形成条件反射随手就能写出来的程度,
</p>

<p>
但严谨死记硬背, 抄到即便别人写法不太一样但也能马上看出来是抄过的代码, 抄到明白每一个参数变量的作用, 可以按照自己的意愿对代码进行调整.
</p>

<p>
当基础知识足够扎实时, 应该就有能力实现 <a href="https://advances.realtimerendering.com/">Advances in Real-Time Rendering in 3D Graphics and Games</a> 里面的技术了.
</p>

</div>
<div id="outline-container-orga959dba" class="outline-2">
<h2 id="orga959dba">常见的困惑</h2>
<div class="outline-text-2" id="text-orga959dba">
</div>
<div id="outline-container-orgbcef113" class="outline-3">
<h3 id="orgbcef113">GLSL 矩阵储存方式</h3>
<div class="outline-text-3" id="text-orgbcef113">
<p>
默认情况下, <code>GLSL</code> 使用列优先储存矩阵. 假设这是一个用于左乘的矩阵: \(\left( \begin{array}{c} a & b \\ c & d \end{array} \right)\),
</p>

<p>
那么在 <code>GLSL</code> 里应该这么定义:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">mat2</span>(a, c,
     b, d);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9ca5951" class="outline-2">
<h2 id="org9ca5951">常见的 UV 计算</h2>
<div class="outline-text-2" id="text-org9ca5951">
</div>
<div id="outline-container-orgb6aee9b" class="outline-3">
<h3 id="orgb6aee9b">UV - 计算片元在屏幕上所对应的 UV 坐标</h3>
<div class="outline-text-3" id="text-orgb6aee9b">
<blockquote>
<p>
写于 2024/3/3
</p>
</blockquote>

<p>
<code>OpenGL</code> 的 <code>UV</code> 坐标是一个左下角为原点, 向上为 \(U\), 向右为 \(V\), 且范围都是 \([0, 1]\) 的坐标系.
</p>

<p>
在 <code>ShaderToy</code> 中, 人们把整个画面看作是一张大贴图, 片元就是该大贴图上面的一个纹理像素(texel).
</p>

<p>
片元理所当然地有一个 <code>UV</code> 坐标, 可以通过片元坐标 \(gl\_FragCoord\) 和屏幕分辨率 \(iResolution\) 计算出来.
</p>

<blockquote>
<p>
默认情况下, \(gl\_FragCoord\) 假设左下角为屏幕坐标系的原点, 以及以像素的中心为像素原点.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = <span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[0.0, 1.0]</span>
</pre>
</div>

<p>
当要注意的是, 为了方便作图, 片元的 <code>UV</code> 并非就要固定在 \([0.0, 1.0]\) 之间.
</p>

<p>
有时候为了实现某些目的, 需要对 <code>UV</code> 做一些列变换.
</p>

<p>
比如把纹理坐标空间的原点从左下角平移到中心,
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = (<span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy) - 0.5; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-0.5, 0.5]</span>
</pre>
</div>

<blockquote>
<p>
这一步开始已经把一个屏幕平均分成 4 份了.
</p>

<p>
\([-0.5, 0.5]\) 分别在 \(u\) 和 \(v\) 两个方向上分为 \([-0.5, 0]\) 和 \([0, 0.5]\) 两个区间.
</p>

<p>
因此, \(2 \times 2 = 4\) 份.
</p>
</blockquote>

<p>
把新的纹理坐标空间的范围拓展到 \([-1.0, 1.0]\),
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = 2.0 * ((<span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy) - 0.5); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1.0, 1.0]
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21487;&#31616;&#21270;&#25104;
</span><span style="color: #98fb98;">vec2</span> uv = 2.0 * (<span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy) - 1.0;
</pre>
</div>

<p>
到目前为止, 我们的 <code>UV</code> 计算都是针对屏幕分辨率比例是一比一的情况.
</p>

<p>
在非一比一情况下绘制个圆形会导致圆变椭圆, 这是因为 <b>\(UV\) 两分量的范围比例和屏幕分辨率比例对不上</b>, 导致出现拉伸的情况.
</p>

<p>
解决方法很简单, 以屏幕分辨率比例为准, 对 \(UV\) 长的那一方维度分量进行补偿, 使得 \(UV\) 分量的范围比例和屏幕分辨率比例一致.
</p>

<p>
原本的 \(UV\) 范围比例固定是 \(\frac{x_{uv}}{y_{uv}} = 1\), 而屏幕分辨率比例是 \(\frac{x_{iResolution}}{y_{iResolution}}\),
</p>

<p>
如果屏幕是 \(X\) 轴比较长, 那么 \(UV\) 就要针对 \(x\) 分量进行补偿才能和屏幕分辨率一致: \(\frac{x_{uv} \times \frac{x_{iResolution}}{y_{iResolution}}}{x_{uv}} = 1 \times \frac{x_{iResolution}}{y_{iResolution}} = \frac{x_{iResolution}}{y_{iResolution}}\),
</p>

<p>
如果屏幕是 \(Y\) 轴比较长, 那么 \(UV\) 就要针对 \(y\) 分量进行补偿才能和屏幕分辨率一致: \(\frac{x_{uv}}{y_{uv} \times \frac{y_{iResolution}}{x_{iResolution}}} = 1 \div \frac{y_{iResolution}}{x_{iResolution}} = \frac{x_{iResolution}}{y_{iResolution}}\).
</p>

<blockquote>
<p>
你可能会问既然要保证两者比例一样, 为什么还要讨论哪根轴较长呢?
</p>

<p>
从公式上来看, 如果 \(Y\) 比较长的话, 用 \(1 \times \frac{x_{iResolution}}{y_{iResolution}}\) 来计算不也是一样可以保证两者比例一致吗?
</p>

<p>
但是别忘记了 \(UV\) 本身就是依赖 \(iResolution\) 计算出来的, 因此这个数字 \(1\) 本身就依赖于 \(iResolution\), 下面的代码可以证明这点.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = 2.0 * (<span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy) - 1.0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1.0, 1.0]
</span><span style="color: #00ffff;">if</span> (iResolution.x &gt; iResolution.y) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#23631;&#24149;&#30340; X &#36724;&#27604; Y &#36724;&#38271;
</span>  uv.x *= iResolution.x / iResolution.y;
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#23631;&#24149;&#30340; Y &#36724;&#27604; X &#36724;&#38271;, &#25110;&#20004;&#32773;&#30456;&#31561;
</span>  uv.y *= iResolution.y / iResolution.x;
}
</pre>
</div>

<p>
到目前为止我相信大部分人都能看得懂, 但 <code>ShaderToy</code> 上的例子大部分都是把这段代码简化成一句的.
</p>

<p>
现在来逐个分析,
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = 2.0 * (<span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy) - 1.0;
<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  &#31561;&#21516;&#20110;

  uv = (2.0 * gl_FragCoord.xy) / iResolution.xy - iResolution.xy / iResolution.xy
  uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy

  &#21516;&#26102;&#21487;&#20197;&#25286;&#24320;&#26469;&#30475;

  uv.x = (2.0 * gl_FragCoord.x - iResolution.x) / iResolution.x
  uv.y = (2.0 * gl_FragCoord.y - iResolution.y) / iResolution.y
</span><span style="color: #ff7f24;">*/</span>

<span style="color: #00ffff;">if</span> (iResolution.x &gt; iResolution.y) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#23631;&#24149;&#30340; X &#36724;&#27604; Y &#36724;&#38271;
</span>  uv.x *= iResolution.x / iResolution.y;
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
    &#31561;&#21516;&#20110;
    uv.x = (2.0 * gl_FragCoord.x - iResolution.x) / iResolution.x * iResolution.x / iResolution.y
    uv.x = (2.0 * gl_FragCoord.x - iResolution.x) / iResolution.y

    &#22914;&#26524;&#21644; y &#20998;&#37327;&#21512;&#24182;&#19968;&#36215;&#35745;&#31639;, &#37027;&#20040;&#23601;&#26159;
    uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y
</span><span style="color: #ff7f24;">   */</span>
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#23631;&#24149;&#30340; Y &#36724;&#27604; X &#36724;&#38271;, &#25110;&#20004;&#32773;&#30456;&#31561;
</span>  uv.y *= iResolution.y / iResolution.x;
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
    &#31561;&#21516;&#20110;
    uv.y = (2.0 * gl_FragCoord.y - iResolution.y) / iResolution.y * iResolution.y / iResolution.x
    uv.y = (2.0 * gl_FragCoord.y - iResolution.y) / iResolution.x

    &#22914;&#26524;&#21644; x &#20998;&#37327;&#21512;&#24182;&#19968;&#36215;&#35745;&#31639;, &#37027;&#20040;&#23601;&#26159;
    uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.x
</span><span style="color: #ff7f24;">   */</span>
}
<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  &#32508;&#21512;&#20004;&#31181;&#24773;&#20917;&#26469;&#30475;&#23601;&#26159;
  uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y)
</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>

<p>
所以, <code>ShaderToy</code> 上有不少例子都是有这一句(或类似的).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
</pre>
</div>

<p>
在大部分的 <code>ShaderToy</code> 例子中, <code>UV</code> 计算是基础且重要的东西, 这个小节所介绍的 <code>UV</code> 计算其实是 <code>UV</code> 补偿, 解决画面拉伸的问题.
</p>

<p>
还会介绍一些其它的 <code>UV</code> 计算来实现不同的效果.
</p>
</div>
</div>
<div id="outline-container-org61e9207" class="outline-3">
<h3 id="org61e9207">UV计算 - 平铺(tiling)</h3>
<div class="outline-text-3" id="text-org61e9207">
<p>
这里的平铺就是和计算机的桌面壁纸里的平铺是一个概念: 当一张壁纸不能把桌面铺满, 那么就用重复若干张壁纸铺满桌面.
</p>

<p>
<code>Shader</code> 编程也可以平铺.
</p>

<p>
我们可以换个角度来思考, 默认情况下, 一个像素所对应 \(UV\) 坐标是 <code>gl_FragCoord.xy / iResolution.xy</code>, 分量的范围是 \([0, 1]\), 这是针对与整个屏幕来说的.
</p>

<p>
想要平铺, 我们只要在屏幕的范围内复制多几个 \([0, 1]\) 范围的 \(UV\) 坐标空间就好了.
</p>


<div id="org576d060" class="figure">
<p><img src="../../../files/uv-tiling.png" alt="uv-tiling.png">
</p>
<p><span class="figure-number">Figure 1: </span>重复了 4 个 \([0, 1]\) 范围的 \(UV\) 坐标空间</p>
</div>

<p>
话虽如此, 具体应该怎么做呢? 虽然没有标准答案, 但还是有基本法的.
</p>

<p>
从原本映射关系来看是 \([x_{min}, x_{max}] \rightarrow [0, 1]\) 和 \([y_{min}, y_{max}] \rightarrow [0, 1]\),
</p>

<p>
想要在更小的屏幕范围内应该一个 \(UV\) 空间, 只要改变 \(x_{max}\) 和 \(y_{max}\) 的值就可以了.
</p>

<p>
对于看左上角的 \(UV\) 空间, 可以通过 <code>gl_FragCoord.xy / (iResolution.xy / 2)</code>, 这里就是把 \(x_{max}\) 和 \(y_{max}\) 分别改变为 <code>iResolution.x / 2</code> 和 <code>iResolution.y / 2</code>.
</p>

<p>
接下来的问题就是如何让构造出另外三个 \(UV\) 空间呢?
</p>

<p>
因为当 <code>gl_FragCoord.x</code> 超出 <code>iResolution.x / 2</code> 时, <code>gl_FragCoord.x / (iResolution.x / 2)</code> 的值就是大于 1 的浮点数,
</p>

<p>
我们的目标是让其它三个 \(UV\) 空间的分量范围为 \([0, 1]\), 方法很简单, <code>glsl</code> 的内置函数 <code>fract</code> 可以获取浮点数的小数部分,
</p>

<p>
比如 <code>fract(1.1)</code> 等于 0.1, <code>fract(2.1)</code> 也是等于 0.1, 从而形成一个以 0 到 0.999&#x2026; (没到 1) 为一个周期的周期序列.
</p>

<blockquote>
<p>
其实可以把第下一个周期头部的 0 看作是上一个周期的 1.
</p>

<p>
原因很简单, 假设现在经过划分得到两个周期, 那么 <code>fract(x)</code> 会得到这样的一个序列(, 以 0.1 为步长):
</p>

<p>
<code>[0, 0.1, 0.2, ..., 0.9], [0(1), 0.1, 0.2, ..., 0.9], 0(2)</code>
</p>
</blockquote>

<p>
这样就可以让其它 \(UV\) 空间的分量范围也处于 \([0, 1)\) 之间,
</p>

<p>
综上所述, \(UV\) 的计算方式就变成这样:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">div_num</span> = 2;
<span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">uv</span> = fract(gl_FragCoord.xy / (iResolution.xy / div_num));
<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  or

  vec2 uv = fract(gl_FragCoord.xy / iResolution.xy * div_num);
</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>

<p>
这并非唯一的方法, 事实上 <b>只要是周期函数都可以获取周期序列来进行平铺</b>, 比如 <code>cosine</code>, <code>sine</code> 和 <code>modulo</code>, 等等.
</p>

<p>
<code>cosine</code> 和 <code>sine</code> 的用法和 <code>fract</code> 差不多, 基本上把 <code>fract</code> 替换就可以了:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">div_num</span> = 2;
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21035;&#24536;&#35760;&#25511;&#21046;&#22909;&#21608;&#26399;
</span><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">uv</span> = cos(gl_FragCoord.xy / (iResolution.xy / div_num * 2 * PI));
<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  or

  vec2 uv = fract(gl_FragCoord.xy / iResolution.xy * div_num * 2 * PI);
</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>

<p>
模运算(modulo)有一点不同:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">div_num</span> = 2;
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">period</span> = 1.0;
<span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">uv</span> = mod(gl_FragCoord.xy / (iResolution.xy / div_num), period);
<span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  or

  vec2 uv = mod(gl_FragCoord.xy / iResolution.xy * div_num, period);
</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>

<p>
并且模运算的周期可以用来对 \(UV\) 空间进行等比缩放, 如果把 <code>period</code> 定义为 2.0, 那么 \(UV\) 的分量范围就是 \([0, 2]\).
</p>
</div>
</div>
</div>
<div id="outline-container-orgc8a40ab" class="outline-2">
<h2 id="orgc8a40ab">GLSL 内置函数</h2>
<div class="outline-text-2" id="text-orgc8a40ab">
</div>
<div id="outline-container-org89a9de2" class="outline-3">
<h3 id="org89a9de2"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml">函数 - smoothstep</a></h3>
<div class="outline-text-3" id="text-org89a9de2">
<blockquote>
<p>
从这里开始的后面几个章节都会介绍一些常用(或者一些光看名字不知道做啥)的 <code>GLSL</code> <a href="https://gist.github.com/markknol/d06c0167c75ab5c6720fe9083e4319e1">内置函数</a>, 不过并不会介绍一些典型的数学函数, 比如 <code>sin/cos/atan</code> 这些,
</p>

<p>
这些直接去看数学书就好, 介绍它们会拉长笔记的篇幅.
</p>

<p>
这些内置函数均可用在 <code>Fragment Shader</code> 中.
</p>
</blockquote>

<p>
\(smoothstep\) 函数的定义等价如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  genType clamp(genType x, genType minValue, genType maxValue)

  equals

  min(max(x, minValue), maxValue)
</span><span style="color: #ff7f24;"> */</span>

genType <span style="color: #b0c4de;">smoothstep</span>(genType edge0, genType edge1, genType x) {
  genType t = <span style="color: #b0c4de;">clamp</span>((x - edge0) / (edge1 - edge0), 0.0, 1.0);
  <span style="color: #00ffff;">return</span> t * t * (3.0 - 2.0 * t);
}
</pre>
</div>

<p>
\(t\) 是从 \(edge0\) 到 \(edge1\) 的插值, 结果在 \([0, 1.0]\) 内.
</p>


<div id="orgb0d3ff3" class="figure">
<p><img src="../../../files/smoothstep-t.png" alt="smoothstep-t.png">
</p>
<p><span class="figure-number">Figure 2: </span>x, edge0 以及 edge1 三者的关系</p>
</div>

<p>
\(smoothstep\) 的返回值 \(f(t) = 3t^{2} - 2t^{3}\) 是一个最高次项为 3 的多项式函数,
</p>

<p>
其一阶导数为 \(f^{'}(t) = 6t - 6t^{2} = 6t(1 - t)\), 令 \(f^{'}(t) = 0\) 可以求得两个驻点的 \(t\) 分量: \(0\) 和 \(1\).
</p>

<p>
再求出二阶导数 \(f^{''}(t) = 6 - 12t\), 分别把驻点的 \(t\) 分量分别代入到其中, 分别得到 \(f^{''}(0) = 6 > 0\) 和 \(f^{''}(1) = -6 < 0\).
</p>

<p>
也就是说函数 \(f(t)\) 在 \(t = 0\) 为极小值, 在 \(t = 1\) 为极大值, \(t\) 在 \([0, 1]\) 这个区间内是单调递增的.
</p>

<p>
又刚好 \(t \in [0, 1.0]\), 因此, \(f(t)\) 最小值为 \(f(0) = 0\), 最大值为 \(f(1) = 1\).
</p>

<p>
我们再令 \(f^{''}(t) = 0\) 尝试求出函数 \(f(t)\) 在 \([0, 1]\) 区间的拐点, 解得 \(t = 0.5\).
</p>

<p>
把 \(t = 0.5\) 代入原函数得到 \(f(t=0.5) = 3 \times 0.5^{2} - 2 \times 0.5^{3} = 0.5\), 得到拐点 \((0.5, 0.5)\).
</p>

<p>
最后求该点处的切线: \(k = f^{'}(0.5) = \frac{y - 0.5}{x - 0.5} = 1.5 \rightarrow y = 1.5x - 0.25\).
</p>

<p>
该切线的导数 \(k^{'} = 1.5\), 表明了函数 \(f(t)\) 在 \(t = 0.5\) 处的斜率的变化率(也就是 \(f^{''}(t)\))是在逐渐增加,
</p>

<p>
在 \(t = 0.5\) 的左边 \(f^{''}(t) > 0\) (函数图像 \(f\) 在 \(x = 0.5\) 左边为上凹), 在右边则是 \(f^{''}(t) < 0\) (函数 \(f\) 在 \(x = 5\) 的右边为下凹). 因此, 点 \((0.5, 0.5)\) 的确是拐点.
</p>

<p>
因此, \(smoothstep\) 是一个从 \([edge0, edge1]\) 到 \([0, 1]\) 的映射, 一条变化率为先增后减的曲线.
</p>

<p>
最终的函数图像如下:
</p>

<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="https://graphtoy.com/?f1(x,t)=smoothstep(0.0,1,x)&v1=true&f2(x,t)=&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0.4302807407932391,-0.05999176204044846,1.9620958899187213"></iframe>
</p>

<blockquote>
<p>
如果仔细看文档的话你会发现一句: "Results are undefined if edge0 ≥ edge1".
</p>

<p>
然而实践发现: \(edge0 \gt edge1\) 的时候, <code>GraphToy</code> 所绘制的 \(smoothstep\) 函数图像表面依然是有结果的.
</p>

<p>
比如, 你可以尝试把上面的 \(smoothstep(0.0, 1, x)\) 换成 \(smoothstep(1, 0.0, x)\) 观察一下: 函数图像会镜像翻转, 从 1 到 0 之间进行插值.
</p>

<p>
经过搜索, 发现在 <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.10.pdf">GLSL 1.10</a> 中 \(smoothstep\) 是没有这一句的, 这一句是从 <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.20.pdf">GLSL 1.20</a> 开始才有的.
</p>

<p>
目前不确定这一句是不是只对一些新版本的 <code>GLSL</code> 生效, 还是说有些 <code>GLSL</code> 的实现没有严格按照标准来.
</p>

<p>
其实在数学层面来看, \(edge0 \ge edge1\) 不会导致函数 <code>undefined</code> 的, 目前实践下来也没有出现 <code>undefined</code> 的情况.
</p>
</blockquote>
</div>
<div id="outline-container-org4fe9c50" class="outline-4">
<h4 id="org4fe9c50"><a href="https://thebookofshaders.com/glossary/?search=smoothstep">The Book Of Shaders 的 smoothstep 函数绘制 Shader 解析</a></h4>
<div class="outline-text-4" id="text-org4fe9c50">
<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#ifdef</span> GL_ES
<span style="color: #00ffff;">precision</span> <span style="color: #00ffff;">mediump</span> <span style="color: #98fb98;">float</span>;
<span style="color: #b0c4de;">#endif</span>

<span style="color: #b0c4de;">#define</span> PI 3.14159265359

<span style="color: #98fb98;">float</span> plot(<span style="color: #98fb98;">vec2</span> st, <span style="color: #98fb98;">float</span> pct) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">smoothstep</span>(pct-0.02, pct, st.y) -
         <span style="color: #b0c4de;">smoothstep</span>(pct, pct+0.02, st.y);
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> st = <span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">smooth interpolation between 0.1 and 0.9
</span>  <span style="color: #98fb98;">float</span> y = <span style="color: #b0c4de;">smoothstep</span>(0.1, 0.9, st.x);

  <span style="color: #98fb98;">vec3</span> color = <span style="color: #98fb98;">vec3</span>(y);

  <span style="color: #98fb98;">float</span> pct = plot(st, y);
  color = (1.0 - pct) * color + pct * <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 0.0);

  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(color, 1.0);
}
</pre>
</div>

<p>
这段 <code>shader</code> 的算法做的事情很简单: 绘制出 \(smoothstep(0.1, 0.9, x)\) 的函数图.
</p>

<p>
实现很简单: 首先计算出 \(st.x\) 经过 \(smoothstep(0.1, 0.9, x)\) 映射后的值 \(y\), 但这样的话所有 \(x\) 分量相同的片元在经过映射后拥有相同的 \(y\), 我们需要判断片元是否处于函数上.
</p>

<p>
\(plot\) 函数就是判断片元是否在函数上的.
</p>

<p>
上面代码中的 \(plot\) 函数其实是优化过了的, 先看未经优化的版本:
</p>

<p>
在计算出经过映射的 \(y\) 后, 对片元的 \(y\) 分量和映射 \(y\) 进行对比, 如果两者相等就说明片元在函数上.
</p>

<p>
但由于它们两者都是浮点数, 没法直接判断是否相等, 因此只能认为当两者相差小于一个边界时为相等.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> plot(<span style="color: #98fb98;">vec2</span> st, <span style="color: #98fb98;">float</span> pct) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">abs</span>(pct - st.y) &lt; 0.01 ? 1.0: 0.0;
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#25110;&#32773;&#20351;&#29992; step &#20989;&#25968;
     step(abs(pct - st.y), 0.01);

     type = float/vec2/vec3/vec4

     type step(type edge, type x)

     equals

     returnValue[i] = edge[i] &gt; x[i] ? 0.0: 1.0;
</span><span style="color: #ff7f24;">   */</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">return step(abs(pct - st.y), 0.01) ? 1.0: 0.0;
</span>}
</pre>
</div>

<p>
<b>不过</b> 这样绘制出来的函数图像很生硬, 边界有锯齿, 过渡不够平滑(, 改节标题连接上面的代码可以修改看效果).
</p>

<p>
优化后的 \(plot\) 函数就是为了解决过渡不平滑的问题而出现的:
</p>

<p>
\(smoothstep(pct-0.02, pct, st.y)\) 的函数图像是 \(smoothstep(0.02, pct+0.02, st.y)\) 图像的左平移, 在水平方向上两者相差 \(0.02 \times 2\) 个距离.
</p>

<p>
在 \([ptc-0.02, pct+0.02]\) 区间的某一个位置上, 两个图像 <b>在垂直方向上</b> 相差的距离的变化规律是先增后减少, \(0.02\) 决定着变化率, 越大变化越小, 线条越粗.
</p>

<p>
如果稍微了解过微积分的话, 应该能感觉相差距离的变化正好符合 \(smoothstep\) 导数的行为, 事实上 <code>plot</code> 就是一个蕴含了求近似导数的步骤.
</p>

<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="https://graphtoy.com/?f1(x,t)=smoothstep(0.1,0.9,x)&v1=true&f2(x,t)=smoothstep(0.1-0.5,0.9,x)&v2=true&f3(x,t)=smoothstep(0.1,0.9+0.5,x)&v3=true&f4(x,t)=smoothstep(0.1-0.5,0.9,x)-smoothstep(0.1,0.9+0.5,x)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=-0.07768258978845546,0.5049807710072313,4.205926793776948"></iframe>
</p>

<blockquote>
<p>
我们也可以使用 <code>Maxima</code> 进行绘图, <code>Maxima</code> 是一个 <code>CAS</code> 软件, 除了能画图以外还能帮助你进行强大的数学运算.
</p>

<p>
个人十分推荐掌握这个工具.
</p>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#23450;&#20041; smoothstep &#20989;&#25968; <span style="color: #00ffff;">*/</span>
smoothstep(l, u, x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(
  t<span style="color: #00ffff;">:</span> <span style="color: #b0c4de;">min</span>(<span style="color: #b0c4de;">max</span>((x <span style="color: #00ffff;">-</span> l) <span style="color: #00ffff;">/</span> (u <span style="color: #00ffff;">-</span> l), <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>), <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>),
  <span style="color: #b0c4de;">return</span> (t <span style="color: #00ffff;">*</span> t <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">3</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> t))
)$

<span style="color: #00ffff;">/*</span> &#32472;&#22270; <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #00ffff;">[</span>smoothstep(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span><span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span>, x), smoothstep(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span><span style="color: #00ffff;">+</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, x), smoothstep(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span><span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span>, x) <span style="color: #00ffff;">-</span> smoothstep(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">1</span><span style="color: #00ffff;">+</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, x) <span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">]</span>);
</pre>
</div>
</blockquote>

<p>
通过 \(smoothstep(0.1-0.5, 0.1, x) - smoothstep(0.1, 0.1+0.5, x)\) 的图像可以得知, 优化后的 \(plot\) 的变化相对平滑一点.
</p>

<p>
回到优化后的 \(plot\) 上, 它的作用就是让 \(st.y\) 在 \([y-0.02, y+0.02]\) 范围内进行插值, 以先增后减的变化率返回 \([0, 1]\) 的值, 而不是像未优化版只返回 \(0\) 或 \(1\) 那样一刀切.
</p>
</div>
</div>
<div id="outline-container-org601a049" class="outline-4">
<h4 id="org601a049">编写 <code>Fragment Shader</code> 的思路</h4>
<div class="outline-text-4" id="text-org601a049">
<p>
刚开始学习 <code>Fragment Shader</code> 时, 我只知道最终目的是为了设置片元的颜色, 然而并不知道如何绘制出自己想要的图像.
</p>

<p>
即便去学习别人的代码, 也只能在有参考的情况下写的出来, 完全不知道别人是如何想出来的, 也不知道所谓的阅读代码中学习要学什么内容.
</p>

<p>
相信很多经历过新手期的人都和我一样认为阅读别人的代码就是要学习其中的数学概念, 其实也没错, <code>Fragment Shader</code> 多少得涉及一些数学概念.
</p>

<p>
然而, 这解释不了为什么有些数学好的人也不能写出自己想要的效果.
</p>

<p>
在经过一定量的阅读以及大量的总结后, 发现了一个事实: 不管实现什么效果, 任何 <code>Fragment Shader</code> 在结构上都有一个固定的模式.
</p>

<p>
个人认为那些数学好的人没能实现自己想要的效果是因为不了解这个模式, 虽然没办法证明这个观点, 但相信你在看完这个模式后会认同我这个观点.
</p>

<p>
<b>开始吧</b>:
</p>

<ol class="org-ol">
<li>确定好 <code>UV</code> 坐标系: 原点在哪, 范围在哪.</li>

<li><p>
<b>时刻记住</b> 片元原本的 <code>UV</code> 坐标 \(st_{0}\) 坐标是 <code>gl_FragCoord.xy / iResolution</code>;
</p>

<p>
<b>代码中的变量 \(st\) 可以看作是片元的一个新属性</b>, 其初始值为 \(st_{0}\) 的值, 但是 \(st\) 可能会在经过计算后发生变化.
</p>

<p>
因此, 在 <code>Fragment Shader</code> 里面, 一个片元包含始终有一个关系: \(f(st_{0}) = st\).
</p>

<p>
最后, <code>Fragment Shader</code> 绘图的关键在于如何根据 \(st\) 来计算出片元的颜色, 粗略地讲就是 <b>位置决定颜色</b>.
</p>

<p>
函数 \(f\) 就是针对 \(st\) 的计算, \(f\) 可以由多个更小的一系列的函数构成, 比如:
</p>

<p>
\(f(st_{0}) = st\)
</p>

<p>
\(\Downarrow\)
</p>

<p>
\(f_{0}(st_{0}) = st_{1}\)
</p>

<p>
\(f_{1}(st_{1}) = st_{2}\)
</p>

<p>
\(\vdots\)
</p>

<p>
\(f_{n}(st_{n}) = st\)
</p>

<p>
确定好每一个函数(每一步运算)的输入范围和计算结果范围, 并且要求对函数的变化规律有直观的理解.
</p>

<blockquote>
<p>
这就是为什么开篇就推荐绘图工具, 可以帮助我们对函数变化有直观了解;
</p>

<p>
这里再推荐掌握 <a href="https://en.wikipedia.org/wiki/Interval_arithmetic#Interval_operators">区间运算(interval arithmetic)</a> 的应用, 在 <code>Shader</code> 编程中会经常遇到两个函数之间的算术运算,
</p>

<p>
为了估算结果通常都是分别确定好两个函数的计算结果范围在对两者进行运算得到最终范围, 区间运算可以帮助我们快而准地估算出结果.
</p>
</blockquote>

<p>
在明白了这一点后, 关键点就在于: 怎么定义出一个可以实现自己想要效果的函数 \(f\).
</p></li>

<li>思考如何定义函数 \(f\).

<ol class="org-ol">
<li><p>
正如前面说的, 位置决定了颜色, 所以, 我们要这么思考: <b>随着位置发生怎么样的变化, 颜色要如何变化呢?</b>
</p>

<p>
举几个简单的例子来看看.
</p>

<p>
<b>例子一</b>: 往 \(y\) 方向增加, 颜色越亮, 往 \(x\) 方向增加, 颜色越亮.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">f(st) = st.x + st.y
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">y &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = clamp((st.x + st.y) * 0.5, 0.0, 1.0);

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="org8b3e2ce" class="figure">
<p><img src="../../../files/how-to-think-of-fun-creation-in-shader.png" alt="how-to-think-of-fun-creation-in-shader.png">
</p>
<p><span class="figure-number">Figure 3: </span>越往右上角方向越亮</p>
</div>

<p>
<b>例子二</b>: 往 \(y\) 方向增加, 颜色越亮.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">f(st) = st.y
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">y &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = st.y;

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="orgda5f40f" class="figure">
<p><img src="../../../files/how-to-think-of-fun-creation-in-shader-2.png" alt="how-to-think-of-fun-creation-in-shader-2.png">
</p>
<p><span class="figure-number">Figure 4: </span>越往上走越亮</p>
</div>

<p>
<b>例子三</b>: 往 \(x\) 方向增加, 颜色越亮.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">f(st) = st.x
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = st.x;

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="org3cb1b67" class="figure">
<p><img src="../../../files/how-to-think-of-fun-creation-in-shader-3.png" alt="how-to-think-of-fun-creation-in-shader-3.png">
</p>
<p><span class="figure-number">Figure 5: </span>越往右走越亮</p>
</div>

<p>
<b>例子四</b>: 往 \(y\) 方向增加, 颜色越亮; 往 \(x\) 方向增加, 颜色越暗.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">f(st) = st.y + (1.0 - st.x)
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">y &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x &#22686;&#21152;, color &#20943;&#23567;
</span><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = clamp((st.y + 1.0 - st.x) * 0.5, 0.0, 1.0);

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="org246c638" class="figure">
<p><img src="../../../files/how-to-think-of-fun-creation-in-shader-4.png" alt="how-to-think-of-fun-creation-in-shader-4.png">
</p>
<p><span class="figure-number">Figure 6: </span>越往左上角走越亮</p>
</div>

<p>
<b>例子五</b>: 往 \(y\) 方向增加, 颜色越亮; 往 \(x\) 方向增加, 颜色越暗, 比上一个例子更明显.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">f(st) = (st.x + st.y) + (st.y - 2 * st.x) = 2 * st.y - st.x
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">y &#22686;&#21152;, color &#22686;&#21152;
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x &#22686;&#21152;, color &#20943;&#23567;
</span>st += st.yx * vec2(1.0, -2.0);
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = clamp((st.x + st.y) * 0.5, 0.0, 1.0);

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="org5d95806" class="figure">
<p><img src="../../../files/how-to-think-of-fun-creation-in-shader-5.png" alt="how-to-think-of-fun-creation-in-shader-5.png">
</p>
<p><span class="figure-number">Figure 7: </span>越往左上角走越亮</p>
</div>

<p>
这五个例子中的 \(f\) 都是的线性函数, 凭想象来思考变化是比较轻松的.
</p>

<p>
然而, 对于非线性函数来凭想象就不是那么容易了, 所以借助绘图软快速绘制等值曲线(contour curves)来了解变化是一个不错的手段.
</p>

<p>
这里用 <code>Maxima</code> 来演示绘制 \(f(x, y) = x^{2} - y^{2} - 10\) 在 \(x,y \in [-1, 1]\) 的等值线图,
</p>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#26354;&#38754;&#22270; <span style="color: #00ffff;">+</span> &#31561;&#20540;&#32447;&#22270; <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">draw3d</span>(
  xlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"x"</span>,
  ylabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"y"</span>,
  zlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"z"</span>,
  contour <span style="color: #00ffff;">=</span> both,
  contour_levels <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">15</span>,
  surface_hide <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">true</span>,
  enhanced3d <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">true</span>,
  explicit(x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> y<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>, x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>, y, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>)
  )$
</pre>
</div>

<div id="org0bb7108" class="figure">
<p><img src="../../../files/x2-y2-10-contour-map-0.svg" alt="x2-y2-10-contour-map-0.svg" class="org-svg" width="800px">
</p>
<p><span class="figure-number">Figure 8: </span><code>曲面图 + 等值线图</code></p>
</div>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#26354;&#38754;&#22270; <span style="color: #00ffff;">+</span> &#31561;&#20540;&#32447;&#22270; <span style="color: #00ffff;">+</span> &#28784;&#38454; <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">draw3d</span>(
  xlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"x"</span>,
  ylabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"y"</span>,
  zlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"z"</span>,
  contour <span style="color: #00ffff;">=</span> both,
  contour_levels <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">15</span>,
  surface_hide <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">true</span>,
  enhanced3d <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">true</span>,
  palette <span style="color: #00ffff;">=</span> gray,
  explicit(x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> y<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>, x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>, y, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>)
  )$
</pre>
</div>

<div id="org9907511" class="figure">
<p><img src="../../../files/x2-y2-10-contour-map-1.svg" alt="x2-y2-10-contour-map-1.svg" class="org-svg" width="800px">
</p>
<p><span class="figure-number">Figure 9: </span><code>曲面图 + 等值线图 + 灰阶</code></p>
</div>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#22312;&#26354;&#38754;&#19978;&#32472;&#21046;&#31561;&#20540;&#32447;&#22270; <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">draw3d</span>(
  xlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"x"</span>,
  ylabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"y"</span>,
  zlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"z"</span>,
  contour <span style="color: #00ffff;">=</span> both,
  contour_levels <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">15</span>,
  surface_hide <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">true</span>,
  explicit(x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> y<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>, x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>, y, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>)
  )$
</pre>
</div>

<div id="orgab48c9f" class="figure">
<p><img src="../../../files/x2-y2-10-contour-map-3.svg" alt="x2-y2-10-contour-map-3.svg" class="org-svg" width="800px">
</p>
<p><span class="figure-number">Figure 10: </span><code>曲面图附加等值线 + 等值线图</code></p>
</div>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#31561;&#20540;&#32447;&#22270; <span style="color: #00ffff;">+</span> &#28784;&#38454; (&#20010;&#20154;&#20559;&#21521;&#29992;&#36825;&#20010;, &#25928;&#26524;&#22270;&#22914;&#19979;) <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">draw3d</span>(
  xlabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"x"</span>,
  ylabel <span style="color: #00ffff;">=</span> <span style="color: #ffa07a;">"y"</span>,
  view <span style="color: #00ffff;">=</span> <span style="color: #b0c4de;">map</span>,
  enhanced3d<span style="color: #00ffff;">=</span><span style="color: #7fffd4;">true</span>,
  palette <span style="color: #00ffff;">=</span> gray,
  explicit(x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> y<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>, x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>, y, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">1</span>)
  )$
</pre>
</div>

<div id="org6a1c437" class="figure">
<p><img src="../../../files/x2-y2-10-contour-map.svg" alt="x2-y2-10-contour-map.svg" class="org-svg" width="800px">
</p>
<p><span class="figure-number">Figure 11: </span><code>等值线图 + 灰阶</code></p>
</div>

<p>
关于 <code>Maxima</code> 更多的绘图选项请自行阅读<a href="https://maxima.sourceforge.io/docs/manual/maxima_250.html">文档</a>.
</p></li>

<li><p>
也可以这么想: 对于在函数 \(f\) 上的片元应该赋予什么颜色, 在函数外的片元又该赋予什么颜色.
</p>

<p>
这一点可以参考前面的函数 \(plot\).
</p></li>
</ol></li>

<li><p>
正确思考 <code>Fragment Shader</code> 中的循环.
</p>

<p>
<b>时刻记住</b>, <code>Fragment Shader</code> 的一切计算都是针对一个片元的, 对于一个片元的计算是不可能影响到另外一个片元的计算.
</p>

<p>
记住这一条之后, 相信对于很多没有接触过 <code>Shader</code> 编程的开发人员来说初次接触 <code>Fragment Shader</code> 的一些迭代会很反直觉:
</p>

<p>
既然只是针对一个片元, 为什么像下面的例子会绘制出 4 条直线而不是 1 条直线呢?
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">vec2</span> <span style="color: #eedd82;">st</span> = gl_FragCoord.xy / iResolution;

<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">color</span> = 0.0;
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">iterations</span> = 4;
<span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = 0; i &lt; iterations; i++, st *= 2.0) {
  <span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">st.x + st.y - 1.0 &lt;= 0.01 &#30456;&#24403;&#20110;&#20989;&#25968; y = x
</span>  color += <span style="color: #98fb98;">float</span>(abs(st.x + st.y - 1.0) &lt;= 0.01); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">float(true) =&gt; 1, float(false) =&gt; 0
</span>}

gl_FragColor = vec4(vec3(color), 1.0);
</pre>
</div>


<div id="orgda75278" class="figure">
<p><img src="../../../files/iteration-in-fragment-shader.png" alt="iteration-in-fragment-shader.png">
</p>
<p><span class="figure-number">Figure 12: </span>输出结果</p>
</div>

<p>
观察代码可知每个片元的 \(color\) 要执行 4 轮计算, 每轮计算都 <b>试图</b> 让 \(color\) 自增(我们这里约定能加到 1 才是成功自增), 并且让 \(st\) 翻倍.
</p>

<p>
我们知道这是在绘制直线 \(y = x\), 但为什么会绘制出 4 条直线呢?
</p>

<p>
<b>绘制过程</b> 是这样的:
</p>

<p>
位于直线上的片元的 \(color\) 在整个迭代中实际只能成功自增 1 次, 而不在直线上的片元则是 0 成功的自增.
</p>

<p>
这里选第一长的直线 \(l_{A}\) 和第二长的直线 \(l_{B}\) 作为例子进行分析, 它们是同时绘制的,
</p>

<blockquote>
<p>
这里其实没办法确认它们是否严格意义上的同时绘制, 但至少可以确认在执行顺序上两者不会相互影响.
</p>
</blockquote>

<p>
在 \(l_{A}\) 上的片元 \(p_{A}: (x_{0}, y_{0})\) 在整个迭代中的第 1 轮计算就成功自增, \(l_{B}\) 上的片元 \(p_{B}: (x_{1}, y_{1})\) 则是在第 2 轮计算才能成功自增.
</p>

<p>
这是因为 \(p_{A}\) 在第 1 轮计算中就符合 \(abs(st.x + st.y - 1.0) \le 0.01\), 之后的 3 轮计算其实没有意义了;
</p>

<p>
而 \(p_{B}\) 则是满足 \(2 \times (x_{1} + y_{1}) = x_{0} + y_{0}\), 所以在经过一轮的 \(st\) 翻倍后使得 \(p_{B} = (2 \times x_{1}, 2 \times y_{1})\), \(p_{B}\) 才符合 \(abs(st.x + st.y - 1.0) \le 0.01\).
</p>

<p>
第三长的直线和最短的直线也是这个道理, 它们符合条件的轮次分别是第 3 和第 4 轮.
</p>

<p>
这个其实就是一个很简单的绘制递归图案的例子, 我之所以选它是想对新人(我)说明一个事实: 在 <code>Fragment Shader</code> 中, <b>有时候</b> 迭代的每一轮计算更像是一次条件筛选, 整个迭代就是反复试验(<code>trial and error</code>).
</p>

<p>
这算是 <code>Fragment Shader</code> 编程中比较常见的迭代用法了, 比起类似以累加/累积为目的的迭代用法特殊一点,
</p>

<p>
它的特殊点在于 <b>为不同颜色赋予了不同的含义</b>: 白色为"有意义计算", 黑色为"无意义计算", 这就是如何为片元赋予颜色.
</p></li>
</ol>


<p>
第 3 步需要运用大量的数学知识, 学习数学知识(主要是微积分)就是为了强化这一步: 根据自己的意愿定义出函数 \(f\).
</p>

<p>
相信现在的你能够理解为什么数学好也不一定写好的 <code>Shader</code> 了: 不知道把数学用在何处.
</p>

<p>
只有在掌握整个模式后, "不断阅读其他人的代码并从中吸收所涉及的数学概念以及应用方法" 才是有用的.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd9238f0" class="outline-3">
<h3 id="orgd9238f0"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/mix.xhtml">函数 - mix</a></h3>
<div class="outline-text-3" id="text-orgd9238f0">
<p>
这个函数可能换个名字比较好理解一点: \(lerp\), 全称 <code>linear interpolation</code>.
</p>

<p>
没错, 这个函数就是计算出线性插值的.
</p>

<p>
函数定义为 \(mix(x, y, a) = x \times (1 - a) + y \times a\).
</p>


<div id="orga526350" class="figure">
<p><img src="../../../files/func-mix.png" alt="func-mix.png">
</p>
<p><span class="figure-number">Figure 13: </span>\(mix(x, y, a)\)</p>
</div>

<blockquote>
<p>
这个函数的定义是这么来的,
</p>

<p>
从 \(x\) 到 \(y\) 的 <b>变化率是固定的</b> (也就是线性的), 并且整个变化间隔只占了 1 个单位, 因此变化率是 \(k = \frac{y - x}{1}\).
</p>

<p>
现在想知道处于这个变化过程中的某一刻 \(a\) (\(0 <= a <= 1\)) 时候的值是多少:
</p>

<p>
\(x + k \times a = x + a \times (y - x) = x + a \times y - a \times x = x \times (1 - a) + y \times a\).
</p>
</blockquote>

<p>
看到这图你可能会联想到前面同样有插值行为的函数 \(smoothstep(edge0, edge1, x)\).
</p>

<p>
它们之间有三点不同:
</p>

<ol class="org-ol">
<li>\(mix\) 是线性插值; \(smoothstep\) 是埃尔米特(Hermite)插值, 属于非线性插值.</li>
<li>\(smoothstep(edge0, edge1, x)\) 的 \(edge0\) 和 \(edge1\) 要保证 \(edge0 \lt edge1\) 的关系(, 甚至要求 \(x\) 位于两者之间, 否则无法按预期插值).
\(mix(x, y, a)\) 中的 \(x\) 和 \(y\) 没有这个要求, 可以 \(x \gt y\) 也可以 \(x \lt y\), 甚至可以 \(x = y\), \(a\) 也没有大小限制.</li>
<li>\(smoothstep(edge0, edge1, x)\) 要求 \(x \in [edge0, edge1]\); \(mix(x, y, a)\) 则没有这个要求, 当 \(a \in [x, y]\) 时叫做内插(<code>interpolation</code>), 当 \(a\) 位于 \([x, y]\) 之外时叫做外插/外推(<code>extrapolation</code>).
因此, \(smoothstep(edge0, edge1, x) \in [0, 1]\), 而 \(mix(x, y, a) \in \mathbb{R}\).</li>
</ol>


<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="https://graphtoy.com/?f1(x,t)=mix(2,4,x)&v1=true&f2(x,t)=smoothstep(2,4,x)&v2=true&f3(x,t)=&v3=false&f4(x,t)=&v4=false&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=1&coords=0,0,12"></iframe>
</p>

<p>
如你所见, 在 \(mix(2, 4, x)\) 的图像中, \(x = 0\) 时 \(y = 2\), \(x = 1\) 时 \(y = 4\),
</p>

<p>
\(mix(l, r, a)\) 的函数图像必定符合这个规律: \(x = 0\) 时 \(y = l\), \(x = 1\) 时 \(y = r\).
</p>
</div>
</div>
<div id="outline-container-org222b95a" class="outline-3">
<h3 id="org222b95a"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/dFdx.xhtml">函数 - dFdx/dFdy</a></h3>
<div class="outline-text-3" id="text-org222b95a">
<p>
只有 <code>Fragment Shader</code> 支持这两函数, 要想理解它们的作用,
</p>

<p>
得先知道 <code>GPU</code> 每次都是以 \(2 \times 2\) 这样规模的片元方块作为单位进行处理的, 也就是每次同时调用 4 个 <code>Fragment Shaders</code>,
</p>

<p>
因此, 在一个 <code>Fragment Shader</code> 中, 对于 <code>GPU</code> 来说可以获取当前片元所在方块内的相邻片元的情况.
</p>

<p>
我们假设有一个函数 \(p(x, y)\) 可以获取位于 \((x, y)\) 的片元的(在光栅化过程计算得到的)某个属性 \(attr\): \(attr = p(x, y)\),
</p>

<p>
那么当前片元在 \(x\) 轴方向上的下一个相邻片元的属性值则是为 \(attr_{x+1} = p(x + 1, y)\),
</p>

<p>
而在 \(y\) 轴方向上的下一个相邻片元的属性值则是为 \(attr_{y+1} = p(x, y + 1)\).
</p>

<p>
\(dFdx(attr)\) 其实就是在求在当前片元的 \(x\) 轴方向上的某个属性的 \(attr\) 的微分(<code>differentation</code>).
</p>

<p>
不过在片元这个上下文中, 它非常接近偏导数(<code>partial derivative</code>)的定义:
</p>

<p>
\(dFdx(attr) = p(x + 1, y) - p(x, y) = \frac{p(x + 1, y) - p(x, y)}{(x + 1) - x} = attr_{x+1} - attr\).
</p>

<p>
因此可以使用 \(dFdx(attr)\) 求 \(x\) 轴方向的导数近似.
</p>

<p>
\(dFdy(attr)\) 同理, 其定义如下:
</p>

<p>
\(dFdy(attr) = p(x, y + 1) - p(x, y) = \frac{p(x, y + 1) - p(x, y)}{(y + 1) - y} = attr_{y+1} - attr\).
</p>


<div id="orgc48c0a0" class="figure">
<p><img src="../../../files/Shader-Derivatives-1.png" alt="Shader-Derivatives-1.png">
</p>
<p><span class="figure-number">Figure 14: </span>dFdx/dFdy</p>
</div>

<p>
在 <code>Shader</code> 编程中, 近似导数是求出片元法线的常用手段.
</p>

<p>
比如下面这个例子在 <code>Fragment Shader</code> 中使用 \(dFdx\) 和 \(dFdy\) 根据片元的视点空间(view space)坐标计算出面法线.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">vertex shader</span><span style="color: #ff7f24;"> */</span>
<span style="color: #b0c4de;">#ifdef</span> GL_ES
<span style="color: #00ffff;">precision</span> <span style="color: #00ffff;">mediump</span> <span style="color: #98fb98;">float</span>;
<span style="color: #b0c4de;">#endif</span>

<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">mat4</span> projectionMatrix;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">mat4</span> modelViewMatrix;

<span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec3</span> position;
<span style="color: #00ffff;">out</span> <span style="color: #98fb98;">vec3</span> normalInterp;
<span style="color: #00ffff;">out</span> <span style="color: #98fb98;">vec3</span> pos;

<span style="color: #98fb98;">void</span> main(){
    <span style="color: #eedd82;">gl_Position</span> = projectionMatrix * modelViewMatrix * <span style="color: #98fb98;">vec4</span>(position, 1.0);
    <span style="color: #98fb98;">vec4</span> pos4 = modelViewMatrix * <span style="color: #98fb98;">vec4</span>(position, 1.0);

    normalInterp = normalMatrix * normal;
    pos = <span style="color: #98fb98;">vec3</span>(pos4) / pos4.w;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">fragment shader</span><span style="color: #ff7f24;"> */</span>
<span style="color: #b0c4de;">#ifdef</span> GL_ES
<span style="color: #00ffff;">precision</span> <span style="color: #00ffff;">mediump</span> <span style="color: #98fb98;">float</span>;
<span style="color: #b0c4de;">#endif</span>

<span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec3</span> pos;
<span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec3</span> normalInterp;

<span style="color: #00ffff;">out</span> <span style="color: #98fb98;">vec4</span> outColor;

<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">float</span> bFlat;

<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vec3</span> lightPos = <span style="color: #98fb98;">vec3</span>(200, 60, 100);
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vec3</span> ambientColor = <span style="color: #98fb98;">vec3</span>(0.2, 0.0, 0.0);
<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">vec3</span> diffuseColor = <span style="color: #98fb98;">vec3</span>(0.5, 0.0, 0.0);

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec3</span> normal = <span style="color: #b0c4de;">mix</span>(<span style="color: #b0c4de;">normalize</span>(normalInterp),
                    <span style="color: #b0c4de;">normalize</span>(<span style="color: #b0c4de;">cross</span>(<span style="color: #b0c4de;">dFdx</span>(pos), <span style="color: #b0c4de;">dFdy</span>(pos))), <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#20351;&#29992; dFdx &#21644; dFdy &#27714;&#20986;&#29255;&#20803;&#25152;&#22312;&#24179;&#38754;&#30340;&#38754;&#27861;&#32447;</span><span style="color: #ff7f24;"> */</span>
                    bFlat);
  <span style="color: #98fb98;">vec3</span> lightDir = <span style="color: #b0c4de;">normalize</span>(lightPos - pos);

  <span style="color: #98fb98;">float</span> lambertian = <span style="color: #b0c4de;">max</span>(<span style="color: #b0c4de;">dot</span>(lightDir, normal), 0.0);
  <span style="color: #98fb98;">float</span> specular = 0.0;

  <span style="color: #00ffff;">if</span> (lambertian &gt; 0.0) {
    <span style="color: #98fb98;">vec3</span> viewDir = <span style="color: #b0c4de;">normalize</span>(-pos);
    <span style="color: #98fb98;">vec3</span> halfDir = <span style="color: #b0c4de;">normalize</span>(lightDir + viewDir);
    <span style="color: #98fb98;">float</span> specAngle = <span style="color: #b0c4de;">max</span>(<span style="color: #b0c4de;">dot</span>(halfDir, normal), 0.0);
    specular = <span style="color: #b0c4de;">pow</span>(specAngle, 16.0);
  }

  outColor = <span style="color: #98fb98;">vec4</span>(ambientColor + lambertian * diffuseColor + specular * specColor, 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd3db1e0" class="outline-3">
<h3 id="orgd3db1e0"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/fract.xhtml">函数 - fract</a></h3>
<div class="outline-text-3" id="text-orgd3db1e0">
<blockquote>
<p>
对这个函数进行笔记是因为本人在上面碰过壁, 对于 <code>GLSL</code> 里面的每个函数请一定要看它的定义, 并且使用绘图工具绘制一遍.
</p>
</blockquote>

<p>
<code>fract</code> 的官方定义是:
</p>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#23450;&#20041; fract &#20989;&#25968; <span style="color: #00ffff;">*/</span>
fract(x) <span style="color: #00ffff;">:=</span> x <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">floor</span>(x)$

<span style="color: #00ffff;">/*</span> &#32472;&#22270; <span style="color: #00ffff;">*/</span>
<span style="color: #b0c4de;">plot2d</span>(fract(x), <span style="color: #00ffff;">[</span>x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">]</span>);
</pre>
</div>

<p>
我一开始不理解 \(x \to 0\) 时 \(fract(x)\) 附近会是 1, 是因为无视了 \(floor(x)\) 函数的定义: 返回小于或等于 \(x\) 的最接近的整数.
</p>

<p>
在 \(x \ge 0\) 时, \(floor(x)\) 和 \(trunc(x)\) 的作用是一样的: 直接返回整数部分.
</p>

<p>
但是根据定义, 对于 \(x \lt 0\) 的时候就不一样了, 比如 \(floor(-0.01) = -1\), 而不是返回 0, 因此 \(fract(-0.01) = -0.01 + 1 = 0.99\).
</p>

<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="https://graphtoy.com/?f1(x,t)=fract(x)&v1=true&f2(x,t)=floor(x)&v2=true&f3(x,t)=&v3=true&f4(x,t)=&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=true&grid=1&coords=0,0,12"></iframe>
</p>

<blockquote>
<p>
既然提到了 \(floor\) 函数, 我觉得还是有必要提一下 \(ceil\) 函数以及 \(round\) 函数.
</p>

<p>
它们三者的作用都是处理掉浮点数的小数部分, 但是处理方式是完全不一样的, 在特殊情况下导致的结果也是天差地别.
</p>

<p>
如果不是经常使用, 很容易会因为对它们的定义不熟悉而写出意料之外的 <code>shader code</code>, 又由于对它们的不熟悉导, 在找出问题时也很难怀疑到它们身上.
</p>

<p>
所以不要掉以轻心, 我写这个函数就是因为痛苦的经历.
</p>

<p>
\(ceil(x)\) 函数定义就和 \(floor(x)\) 的完全相反: 返回大于或等于 \(x\) 的最接近整数. \(ceil(x)\) 的作用看上去和 \(trunc(x)\) 差很远, 所以就不过多解释.
</p>

<p>
\(round(x)\) 就是"四舍五入", 当 \(x\) 的小数部分大于或等于 \(0.5\) 就进 \(1\), 相信很多人都是在小学一/二年纪了解到这个概念, 但是那个时候是没有学负数的(, 学了负数后面好像也没有回顾"四舍五入"这个概念),
</p>

<p>
这个进 \(1\) 是否就像正数那样给 \(x\) 的整数部分加 \(1\) 呢? 刚好相反, 对于负数而言进 \(1\) 是减 \(1\), 所以 \(round(-1.5) = -2\), 而不是 \(0\).
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orga43090a" class="outline-3">
<h3 id="orga43090a"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/faceforward.xhtml">函数 - faceforward</a></h3>
<div class="outline-text-3" id="text-orga43090a">
<p>
\(faceforward(N, I, Nref)\) 函数用于判断入射向量 \(I(ncident vector)\) 和表面法线向量 \(Nref\) 是否一致朝向(指向同一个半球(hemisphere)/半圆(semicircle)的方向),
</p>

<p>
如果不是, 就要把法线向量 \(N\) 反转(\(-1 \times N\))并把它作为结果返回, 否则直接返回 \(N\).
</p>

<p>
通常 \(Nref\) 的值是和 \(N\) 是一样的,
</p>

<p>
所以这个函数一般是用来判断表面的面向是否为正面, 不是的话就进行纠正, 这就是函数名字的由来.
</p>

<p>
函数的定义:
</p>

<blockquote>
<p>
如果 \(dot(I, Nref) < 0\), 表明 \(I\) 是从表面的正面进入, 返回 \(N\);
</p>

<p>
如果 \(dot(I, Nref) > 0\), 表明 \(I\) 是从表面的背面进入, 返回 \(-1 \times N\).
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">/*</span> &#23450;&#20041; facef<span style="color: #00ffff;">or</span>ward &#20989;&#25968; <span style="color: #00ffff;">*/</span>
facef<span style="color: #00ffff;">or</span>ward(n, i, nr) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(
  <span style="color: #b0c4de;">return</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">signum</span>(i <span style="color: #00ffff;">.</span> nr) <span style="color: #00ffff;">*</span> n)
)$

<span style="color: #00ffff;">/*</span> Test <span style="color: #00ffff;">*/</span>
<span style="color: #00ffff;">/*</span> facef<span style="color: #00ffff;">or</span>ward(<span style="color: #00ffff;">[</span><span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[-</span><span style="color: #7fffd4;">4</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span><span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>); <span style="color: #00ffff;">*/</span>
<span style="color: #00ffff;">/*</span> facef<span style="color: #00ffff;">or</span>ward(<span style="color: #00ffff;">[</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[-</span><span style="color: #7fffd4;">4</span>, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span><span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span><span style="color: #7fffd4;">1</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">]</span>); <span style="color: #00ffff;">*/</span>
</pre>
</div>


<div id="org6fd2e89" class="figure">
<p><img src="../../../files/func-faceforward.png" alt="func-faceforward.png">
</p>
<p><span class="figure-number">Figure 15: </span>faceforward</p>
</div>

<p>
如果不理解的话可以看这图,
</p>

<p>
\(dot(I, Nref) = |I||Nref|\cos(angle(I, Nref))\), 其中 \(angle(I, Nref)\) 是向量 \(I\) 和 向量 \(Nref\) 之间的角度.
</p>

<p>
根据 \(\cos\) 函数图像可以知道, 如果 \(\frac{-\pi}{2} < angle(I, Nref) < \frac{\pi}{2}\), 那么 \(dot(I, Nref) > 0\),
</p>

<p>
很明显, 图中的 \(I1\) 符合这种情况: \(dot(I1, Nref) > 0\);
</p>

<p>
如果 \(\frac{-\pi}{2} > angle(I, Nref)\) 或 \(\frac{\pi}{2} < angle(I, Nref)\), 那么 \(dot(I, Nref) < 0\).
</p>

<p>
没错, \(I0\) 符合这种情况(, 准确一点是满足 \(\frac{-\pi}{2} > angle(I0, Nref)\)), 因此 \(dot(I0, Nref) < 0\).
</p>

<p>
如果还不理解的话, 可以看一下这个地址: <a href="https://blender.stackexchange.com/questions/279677/mathematically-what-does-faceforward-function-mean">mathematically-what-does-faceforward-fhunction-mean</a>.
</p>
</div>
</div>
<div id="outline-container-orga1fd365" class="outline-3">
<h3 id="orga1fd365"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/reflect.xhtml">函数 - reflect</a></h3>
<div class="outline-text-3" id="text-orga1fd365">
<p>
\(reflect(I, N)\) 函数用于计算 \(I\) 射入面向 \(N\)（需要确保被一般化) 的表面后的反射方向: \(I - 2.0 \times dot(N, I) \times N\).
</p>

<p>
这个函数定义的推导过程可以看我<a href="../../2020/08/graphics-opengl-light-and-material.html#specular">以前的文章</a>, 这里不再赘述.
</p>
</div>
</div>
<div id="outline-container-org407522c" class="outline-3">
<h3 id="org407522c"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/refract.xhtml">函数 - refract</a></h3>
<div class="outline-text-3" id="text-org407522c">
<p>
\(refract(I, N, eta)\) 函数用于计算出入射光线 \(I\) 经过面向 \(N\) 表面(surface)后的折射光线的向量, \(eta\) 是表面的折射率比(ratio of indices of refraction).
</p>

<p>
想了解 \(eta\) 的定义, 得先了解斯涅尔定律(<code>Snell's law</code>), 又叫折射定律.
</p>


<div id="org8af81fd" class="figure">
<p><img src="../../../files/refraction-and-snells-law-from-physics-ib.jpg" alt="refraction-and-snells-law-from-physics-ib.jpg" width="800px">
</p>
<p><span class="figure-number">Figure 16: </span><a href="https://www.youtube.com/watch?v=NcCSGtnUUpw&amp;ab_channel=AndyMasley%27sIBPhysicsLectures">折射 &amp; 斯涅尔定律(图来自 IB Physics)</a></p>
</div>

<p>
根据定律, \(n_1\) 和 \(n_2\) 分别是两种介质的折射率, 那么 \(eta = \frac{n_{1}}{n_{2}} = \frac{\sin\theta_{2}}{\sin\theta_{1}}\) 或者 \(eta = \frac{n_{2}}{n_{1}} = \frac{\sin\theta_{1}}{\sin\theta_{2}}\)? 究竟是哪个呢?
</p>

<p>
\(refract\) 的文档并没有说明这一切, 于是我在 <code>StackOverflow</code> 上通过这一篇帖子找到了答案: <a href="https://stackoverflow.com/questions/20801561/glsl-refract-function-explanation-available">glsl refract function explanation available</a>.
</p>

<blockquote>
<p>
我还在这篇帖子上收获了另外一个技巧: 在 <a href="https://books.google.com/">Google Books</a> 里面检索一些较为专业的名词/概念, 比如 "refraction vector".
</p>

<p>
事实上很多这种专业的名词/概念很少会出现在搜索引擎上的, 通常只会出现在教材上, 所以这个技巧对自学者很重要.
</p>
</blockquote>

<p>
这篇帖子直接给出了折射向量的公式推导, 不过还是得写下自己的理解(, 因为要看懂它的推导还需要一些额外的概念补充, 以及添加额外说明使它更易懂).
</p>


<div id="orgf1ca08f" class="figure">
<p><img src="../../../files/calc-refraction-vector.png" alt="calc-refraction-vector.png">
</p>
<p><span class="figure-number">Figure 17: </span>折射向量推导</p>
</div>

<p>
图中的向量 \(I\) / \(N\) / \(M\) 都是单位向量, \(M\) 是垂直于 \(N\) 的向量, 而向量 \(T\) 是 \(refract(I, N, eta)\) 的返回结果: 折射向量.
</p>

<p>
从图中可以看出, 求出 \(T\) 的关键是求出向量 \(M\).
</p>

<p>
其实, 向量 \(H\) 的单位向量就是 \(M\), 但两者的大小不一样, 它们的大小关系为: \(\sin\theta_{i} = \frac{|H|}{|I|} = \frac{|H|}{|M|} = |H|\),
</p>

<p>
因此, \(M = \frac{H}{\sin\theta_{i}}\).
</p>

<p>
现在可以计算出:
</p>

<p>
\(\begin{equation*} \begin{aligned} T &= M \times \sin\theta_{t} - N \times \cos\theta_{t} \\ &= \frac{\sin\theta_{t}}{\sin\theta_{i}}(N \times \cos\theta_{i} - I) - N \times \cos\theta_{t}  \\ &= \frac{\sin\theta_{t}}{\sin\theta_{i}} \times N \times \cos\theta_{i} - \frac{\sin\theta_{t}}{\sin\theta_{i}} \times I - N \times \cos\theta_{t} \\ &= (\frac{\sin\theta_{t}}{\sin\theta_{i}} \times \cos\theta_{i} - \cos\theta_{t}) \times N - \frac{\sin\theta_{t}}{\sin\theta_{i}} \times I \end{aligned} \end{equation*}\)
</p>

<p>
现在回过头来看 \(eta\), 从计算 \(T\) 的方程中, 选择 \(eta = \frac{\sin\theta_{t}}{\sin\theta_{i}}\) 比较合适, 所以 \(T = (eta \times \cos\theta_{i} - \cos\theta_{t}) \times N - eta \times I\).
</p>

<p>
已经没办法从上面的图获得任何有用的线索了, 换个思路: 从答案出发找出线索来连接目前得到的结论.
</p>

<p>
回头看一下 \(refract(I, N, eta)\) 的定义:
</p>

<div class="org-src-container">
<pre class="src src-c">k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
<span style="color: #00ffff;">if</span> (k &lt; 0.0)
    R = genType(0.0);       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">or genDType(0.0)
</span><span style="color: #00ffff;">else</span>
    R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;
</pre>
</div>

<p>
初看代码可能不知道 \(k\) 的含义是什么, 但只要把 \(eta\) 带入进去就明白了:
</p>

<p>
\(\begin{equation*}\begin{aligned} k &= 1.0 - eta \times eta \times (1.0 - dot(N, I) \times dot(N, I)) \\ &= 1.0 - \frac{\sin^{2}\theta_{t}}{\sin^{2}\theta_{i}} \times (1.0 - \cos^{2}\theta_{i}) \\ &= 1.0 - \frac{\sin^{2}\theta_{t}}{\sin^{2}\theta_{i}} \times \sin^{2}\theta_{i} \\ &= \cos^{2}\theta_{t} \end{aligned} \end{equation*}\)
</p>

<p>
现在整个 \(refract\) 的定义及其背后的含义已经全部解析完毕.
</p>

<p>
另外, 如上所示, \(refract\) 函数的计算结果和 \(T\) 是方向相反的.
</p>

<p>
在开发中通常会模拟现实中的一些折射情况, 幸好有人整理了各种<a href="https://pixelandpoly.com/ior.html">材质的折射率(index of refraction)</a>.
</p>

<p>
比如说想计算从空气射入水中的折射情况, 空气的折射率是 \(1\), \(0\) 摄氏度的水折射率是 \(1.333\), 那么此时 \(eta = \frac{1}{1.333}\).
</p>
</div>
</div>
<div id="outline-container-orga70f782" class="outline-3">
<h3 id="orga70f782"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/packUnorm.xhtml">函数 - packUnorm</a> 和 <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml">函数 - unpackUnorm</a></h3>
<div class="outline-text-3" id="text-orga70f782">
<p>
这两个函数只是用来把数据打包和解包.
</p>

<p>
举个例子, 我们知道 <code>Fragment Shader</code> 里面的片元颜色是这么个结构: \((r, g, b, a)\), 每个分量的范围都是 \([0.0, 1.0]\).
</p>

<p>
但是在一些程序中的颜色结构中, 分量的范围就变成 \([0, 255]\), 比如浏览器中的 <code>#F2F1F0</code>, 这个其实就是 \(242 \times 16^{4} + 241 \times 16^{2} + 240 \times 16^{0}\) 的 16 进制表示.
</p>

<p>
要完成从 \([0.0, 1.0]\) 到 \([0, 255]\) 的转换很简单, 针对分量进行这样的操作: \(round(x * 255.0)\).
</p>

<p>
然而, 这样的话会很繁琐, 毕竟 <code>GLSL</code> 支持 <code>vec4</code>, 对一个 <code>vec4</code> 进行转换就得手写 4 条这样的操作,
</p>

<p>
因此, <code>GLSL</code> 提供了 \(packUnorm\) 一套函数来减轻开发人员的负担, 另外还提供了 \(unpackUnorm\) 一套函数来完成 "从 \([0, 255]\) 到 \([0.0, 1.0]\)" 这样的逆操作.
</p>

<p>
这里就不再对函数的定义进行详细说明了, 写这个小节是因为初见该函数没了解到它是做什么的而已, 实际了解下来还是挺简单的.
</p>
</div>
</div>
<div id="outline-container-org2bd0a75" class="outline-3">
<h3 id="org2bd0a75"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/modf.xhtml">函数 - modf</a></h3>
<div class="outline-text-3" id="text-org2bd0a75">
<p>
\(modf(x, out\ i)\) 把浮点数 \(x\) 分开整数和小数两部分, 整数部分(integer part)会储存在参数 \(i\) 中, 小数部分(fractional part)则是作为函数的返回值.
</p>

<blockquote>
<p>
不要和 \(mod\) 函数搞混.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f;
<span style="color: #98fb98;">float</span> i;

f = <span style="color: #b0c4de;">modf</span>(1.2, i);
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">i = 1.0, f = 0.2</span><span style="color: #ff7f24;"> */</span>

<span style="color: #98fb98;">vec2</span> fs;
<span style="color: #98fb98;">vec2</span> is;
fs = <span style="color: #b0c4de;">modf</span>(<span style="color: #98fb98;">vec2</span>(1.2, -3.4), is);
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">fs = vec2(0.2, -0.4), is = ivec2(1.0, -3.0)</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org55ed4f2" class="outline-3">
<h3 id="org55ed4f2"><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/texture.xhtml">函数 - texture</a></h3>
<div class="outline-text-3" id="text-org55ed4f2">
<p>
\(texture\) 函数从贴图 \(tex\) 中获取指定纹理坐标 \(texCoord\) 上的纹素(<code>texels</code>), 一般用法是 \(texture(tex, texCoord)\).
</p>

<blockquote>
<p>
贴图分 <code>1D</code>, <code>2D</code> 和 <code>3D</code> 贴图, 这里主要介绍 <code>2D</code> 贴图.
</p>
</blockquote>

<p>
现在有一个问题: 如果 \(texCoord\) 的分量超出 \([0.0, 1.0]\) 的范围怎么办? 这就涉及贴图的一个属性 - 纹理环绕 (<code>texture wrapping</code>).
</p>

<p>
纹理环绕是指纹理坐标 \(texCoord\) 的分量超出范围 \([0.0, 1.0]\) 时该如何处理这些超出的坐标, <code>OpenGL</code> 里面有 <code>4</code> 种选项给开发者进行选择:
</p>

<ol class="org-ol">
<li><p>
<code>GL_REPEAT</code>: 默认模式, 使得贴图重复, 调用时效果如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> tex;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> texCoord;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec4 texel = texture(tex, texCoord); &#31561;&#21516;&#20197;&#19979;
</span><span style="color: #98fb98;">vec4</span> texel = <span style="color: #b0c4de;">texture</span>(tex, <span style="color: #b0c4de;">fract</span>(texCoord));
</pre>
</div></li>

<li><p>
<code>GL_MIRRORED_REPEAT</code>: 类似 <code>GL_REPEAT</code>, 只不过是镜像重复, 调用时效果如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> tex;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> texCoord;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec4 texel = texture(tex, texCoord); &#31561;&#21516;&#20197;&#19979;
</span><span style="color: #98fb98;">vec2</span> is;
<span style="color: #98fb98;">vec2</span> fs = <span style="color: #b0c4de;">modf</span>(texCoord, is);
<span style="color: #98fb98;">float</span> texCoordS = <span style="color: #b0c4de;">mod</span>(is.x, 2) == 0 ? fs.s : 1 - fs.s;
<span style="color: #98fb98;">float</span> texCoordT = <span style="color: #b0c4de;">mod</span>(is.y, 2) == 0 ? fs.t : 1 - fs.t;
<span style="color: #98fb98;">vec4</span> texel = <span style="color: #b0c4de;">texture</span>(tex, <span style="color: #98fb98;">vec2</span>(texCoordS, texCoordT));
</pre>
</div>

<p>
也就是 <code>texCoord</code> 分量的整数 \(i\) 部分为偶数时, 分量就被会被它自己的小数部分 \(f\) 取代; 如果分量的整数部分 \(i\) 为奇数, 分量就会被 \(1 - f\) 取代.
</p></li>

<li><p>
<code>GL_CLAMP_TO_EDGE</code>: 把贴图坐标的分量限定在 \([0.0, 1.0]\) 的范围内, 调用效果如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> tex;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> texCoord;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec4 texel = texture(tex, texCoord); &#31561;&#21516;&#20197;&#19979;
</span><span style="color: #98fb98;">vec4</span> texel = <span style="color: #b0c4de;">texture</span>(tex, <span style="color: #b0c4de;">clamp</span>(texCoord, 0.0, 1.0));
</pre>
</div></li>

<li><p>
<code>GL_CLAMP_TO_BORDER</code>: 类似 <code>GL_CLAMP_TO_EDGE</code>, 但当根据超出范围的贴图坐标获取纹素时, 该纹素的颜色为用户指定颜色,
</p>

<p>
这个颜色要通过 <code>OpenGL</code> 的 <code>API</code> 去设置 <code>GL_TEXTURE_BORDER_COLOR</code> 这个贴图属性的值来进行指定, 调用效果如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> tex;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> texCoord;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec4</span> borderColor;       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29992;&#25143;&#25351;&#23450;&#30340;&#39068;&#33394;
</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec4 texel = texture(tex, texCoord); &#31561;&#21516;&#20197;&#19979;
</span><span style="color: #98fb98;">vec4</span> texel = (texCoord.s &gt; 1 || texCoord.s &lt; 0 || texCoord.t &gt; 1 || texCoord.t &lt; 0) ? borderColor : <span style="color: #b0c4de;">texture</span>(tex, <span style="color: #b0c4de;">clamp</span>(texCoord, 0.0, 1.0));
</pre>
</div></li>
</ol>



<div id="org7ada431" class="figure">
<p><img src="../../../files/texture_wrapping.png" alt="texture_wrapping.png">
</p>
<p><span class="figure-number">Figure 18: </span>贴图环绕的 4 种选择 (图片来自 LearnOpenGL)</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org71c7f7b" class="outline-2">
<h2 id="org71c7f7b">常用自定义函数</h2>
<div class="outline-text-2" id="text-org71c7f7b">
</div>
<div id="outline-container-orgcfe532a" class="outline-3">
<h3 id="orgcfe532a">remap 函数</h3>
<div class="outline-text-3" id="text-orgcfe532a">
<blockquote>
<p>
从这里开始会介绍一下 <code>GLSL</code> 没有内置但又常用的函数.
</p>
</blockquote>

<p>
\(remap(value, low1, high1, low2, high2)\): 对 \(value\) 从 \([low1, high1]\) 映射到 \([low2, high2]\) 上, 并返回经过重新映射后的 \(value\).
</p>

<p>
因此, 函数的定义是: \(low2 + \frac{value - low1}{high1 - low1} \times (high2 - low2)\).
</p>
</div>
</div>
<div id="outline-container-org8171fdf" class="outline-3">
<h3 id="org8171fdf">调色板生成</h3>
<div class="outline-text-3" id="text-org8171fdf">
<p>
参考资料: <a href="https://offscreencanvas.com/issues/generative-shader-color-palettes/">https://offscreencanvas.com/issues/generative-shader-color-palettes/</a>
</p>
</div>
</div>
<div id="outline-container-orgfe8dc03" class="outline-3">
<h3 id="orgfe8dc03">缓动函数</h3>
<div class="outline-text-3" id="text-orgfe8dc03">
<p>
缓动函数(Easing Function) \(f\) 用于描述动画的进度 \(p\) 如何随着时间 \(t\) 的变化而变化.
</p>

<p>
在数学上, 其定义大概为: \(p = f(t)\).
</p>

<p>
其中 \(t \in [0, 1]\), \(t\) 是一个规范化的时间,
</p>

<p>
假设一个动画的总时长为 \(30\) 秒, 在播放到一半时(在第 \(15\) 秒), 那么 \(t = \frac{15}{30} = 0.5\),
</p>

<p>
所以 \(t = 0\) 表示动画开始, \(t = 1\) 表示动画结束;
</p>

<p>
\(p\) 它没有固定范围, 但满足关系: \(p = \begin{cases} 0 & \text{if } t = 0 \\ 1 & \text{if } t = 1 \end{cases}\).
</p>

<p>
根据这些特点, \(p\) 可以看作是 \(0\) 到 \(1\) 的插值函数, \(p\) 可以表示动画已播放帧数的归一化, 也可以表示变量插值变化的归一化.
</p>

<p>
比如动画的总帧数为 \(120\) 帧, 假设播放到一半(在第 \(60\) 帧), 那么 \(p = \frac{60}{120}\),
</p>

<p>
在其它地方中, \(p\) 会被定义为动画已播放的帧数, 这两者本质上是一致的, 只要知道动画的总帧数就可以进行相互转换.
</p>

<p>
通俗点来说, 缓动函数描述动画在什么时间上处于哪一帧.
</p>

<p>
另外, \(t\) 和 \(p\) 的关系类似与时间和位移之间关系, 一阶导数 \(f^{'}(t)\) 就是动画的当前播放速度, 二阶导数 \(f^{''}(t)\) 是动画的当前播放加速度.
</p>

<p>
缓动函数的作用通常是让运动的速度看起来更加自然, 而不是机械的匀速运动,
</p>

<p>
比如说汽车在启动到驾驶到目的地, 整个过程至少经历了缓缓加速(<code>Ease-in</code>)和缓缓减速(<code>Ease-out</code>)两个过程,
</p>

<p>
而不是一开始就以固定速度启动, 然后在目的地直接变为 0 速.
</p>

<p>
还有缓出缓入(<code>Ease-In-Out</code>), 这一类函数整体上是先从静止状态逐渐加速, 在中间阶段达到最大速度, 然后逐渐减速直到静止.
</p>

<p>
<a href="https://easings.net/">https://easings.net/</a>
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> PI 3.14159265359
<span style="color: #b0c4de;">#define</span> POW_IN(n, t) (<span style="color: #b0c4de;">pow</span>(t, n))
<span style="color: #b0c4de;">#define</span> POW_OUT(n, t) (<span style="color: #b0c4de;">pow</span>(1.0 - (t), n))
<span style="color: #b0c4de;">#define</span> POW_IN_OUT(n, t) ((t) &lt; 0.5 ? <span style="color: #b0c4de;">pow</span>(2.0, (n) - 1.0) * <span style="color: #b0c4de;">pow</span>(t, n): 1.0 - 0.5 * <span style="color: #b0c4de;">pow</span>(-2.0 * t + 2.0, n))

<span style="color: #98fb98;">float</span> easeInSine(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> 1.0 - <span style="color: #b0c4de;">cos</span>(0.5 * PI * t);
}

<span style="color: #98fb98;">float</span> easeOutSine(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">sin</span>(0.5 * PI * t);
}

<span style="color: #98fb98;">float</span> easeInOutSine(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> -0.5 * (<span style="color: #b0c4de;">cos</span>(PI * t) - 1.0);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pow 2
</span><span style="color: #98fb98;">float</span> easeInQuad(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN(2.0, t);
}

<span style="color: #98fb98;">float</span> easeOutQuad(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_OUT(2.0, t);
}

<span style="color: #98fb98;">float</span> easeInOutQuad(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN_OUT(2.0, t);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pow 3
</span><span style="color: #98fb98;">float</span> easeInCubic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN(3.0, t);
}

<span style="color: #98fb98;">float</span> easeOutCubic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_OUT(3.0, t);
}

<span style="color: #98fb98;">float</span> easeInOutCubic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN_OUT(3.0, t);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pow 4
</span><span style="color: #98fb98;">float</span> easeInQuart(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN(4.0, t);
}

<span style="color: #98fb98;">float</span> easeOutQuart(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_OUT(4.0, t);
}

<span style="color: #98fb98;">float</span> easeInOutQuart(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN_OUT(4.0, t);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pow 5
</span><span style="color: #98fb98;">float</span> easeInQuint(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN(5.0, t);
}

<span style="color: #98fb98;">float</span> easeOutQuint(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_OUT(5.0, t);
}

<span style="color: #98fb98;">float</span> easeInOutQuint(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> POW_IN_OUT(5.0, t);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Expo
</span><span style="color: #98fb98;">float</span> easeInExpo(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> t == 0.0 ? 0.0: <span style="color: #b0c4de;">pow</span>(2.0, 10.0 * t - 10.0);
}

<span style="color: #98fb98;">float</span> easeOutExpo(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> t == 1.0 ? 1.0: 1.0 - <span style="color: #b0c4de;">pow</span>(2.0, -10.0 * t);
}

<span style="color: #98fb98;">float</span> easeInOutExpo(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">if</span> (0.0 == x || 1.0 == x) {
    <span style="color: #00ffff;">return</span> x;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (x &lt; 0.5) {
    <span style="color: #00ffff;">return</span> 0.5 * <span style="color: #b0c4de;">pow</span>(2.0, 20.0 * t - 10.0);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> 0.5 * (2.0 - <span style="color: #b0c4de;">pow</span>(2.0, -20.0 * t + 10.0));
  }
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Circ
</span><span style="color: #98fb98;">float</span> easeInCirc(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> 1.0 - <span style="color: #b0c4de;">sqrt</span>(1.0 - <span style="color: #b0c4de;">pow</span>(x, 2.0));
}

<span style="color: #98fb98;">float</span> easeOutCirc(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">sqrt</span>(1.0 - <span style="color: #b0c4de;">pow</span>(x - 1.0, 2.0));
}

<span style="color: #98fb98;">float</span> easeInOutCirc(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> x &lt; 0.5 ?
    0.5 * (1.0 - <span style="color: #b0c4de;">sqrt</span>(1.0 - <span style="color: #b0c4de;">pow</span>(2.0 * x, 2.0))):
    0.5 * (<span style="color: #b0c4de;">sqrt</span>(1.0 - <span style="color: #b0c4de;">pow</span>(-2.0 * x + 2.0, 2.0)) + 1.0);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Back
</span><span style="color: #b0c4de;">#define</span> OVERSHOT 1.70158
<span style="color: #98fb98;">float</span> easeInBack(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21644; smoothstep &#38750;&#24120;&#30456;&#20284;
</span>  <span style="color: #00ffff;">return</span> (OVERSHOT + 1.0) * <span style="color: #b0c4de;">pow</span>(t, 3.0) - OVERSHOT * <span style="color: #b0c4de;">pow</span>(t, 2.0);
}

<span style="color: #98fb98;">float</span> easeOutBack(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> 1.0 + (OVERSHOT + 1.0) * <span style="color: #b0c4de;">pow</span>(t - 1.0, 3.0) + OVERSHOT * <span style="color: #b0c4de;">pow</span>(t - 1.0, 2.0);
}

<span style="color: #98fb98;">float</span> easeInOutBack(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #98fb98;">float</span> c2 = OVERSHOT * 1.525;
  <span style="color: #00ffff;">return</span> t &lt; 0.5 ?
    0.5 * <span style="color: #b0c4de;">pow</span>(2.0 * t, 2.0) * ((c2 + 1.0) * 2.0 * t - c2):
    0.5 * (<span style="color: #b0c4de;">pow</span>(2.0 * t - 2.0, 2.0) * ((c2 + 1.0) * (2.0 * t - 2.0) + c2) + 2.0);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Elastic
</span><span style="color: #98fb98;">float</span> easeInElastic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #98fb98;">float</span> c4 = 2.0 * PI / 3.0;
  <span style="color: #00ffff;">if</span> (0.0 == t || 1.0 == t) {
    <span style="color: #00ffff;">return</span> t;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> -<span style="color: #b0c4de;">pow</span>(2.0, 10.0 * t - 10.0) * <span style="color: #b0c4de;">sin</span>((10.0 * t - 10.75) * c4);
  }
}

<span style="color: #98fb98;">float</span> easeOutElastic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #98fb98;">float</span> c4 = 2.0 * PI / 3.0;
  <span style="color: #00ffff;">if</span> (0.0 == t || 1.0 == t) {
    <span style="color: #00ffff;">return</span> t;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">pow</span>(2.0, -10.0 * t) * <span style="color: #b0c4de;">sin</span>((t * 10.0 - 0.75) * c4) + 1.0;
  }
}

<span style="color: #98fb98;">float</span> easeInOutElastic(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #98fb98;">float</span> c5 = 2.0 * PI / 4.5;

  <span style="color: #00ffff;">if</span> (0.0 == t || 1.0 == t) {
    <span style="color: #00ffff;">return</span> t;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (t &lt; 0.5) {
    <span style="color: #00ffff;">return</span> -0.5 * <span style="color: #b0c4de;">pow</span>(2.0, 20.0 * t - 10.0) * <span style="color: #b0c4de;">sin</span>((20.0 * t - 11.125) * c5);
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> 0.5 * <span style="color: #b0c4de;">pow</span>(2.0, -20.0 * t + 10.0) * <span style="color: #b0c4de;">sin</span>((20.0 * t - 11.125) * c5) + 1.0;
  }
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Bounce
</span><span style="color: #98fb98;">float</span> easeInBounce(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> 1.0 - easeOutBounce(1.0 - t);
}

<span style="color: #98fb98;">float</span> easeOutBounce(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #98fb98;">float</span> n1 = 7.5625;
  <span style="color: #98fb98;">float</span> d1 = 2.75;

  <span style="color: #00ffff;">if</span> (t &lt; 1.0 / d1) {
    <span style="color: #00ffff;">return</span> n1 * t * t;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (t &lt; 2.0 / d1) {
    <span style="color: #00ffff;">return</span> n1 * <span style="color: #b0c4de;">pow</span>(t - 1.5 / d1, 2.0) + 0.75;
  } <span style="color: #00ffff;">else</span> <span style="color: #00ffff;">if</span> (t &lt; 2.5 / d1) {
    <span style="color: #00ffff;">return</span> n1 * <span style="color: #b0c4de;">pow</span>(t - 2.25 / d1, 2.0) + 0.9375;
  } <span style="color: #00ffff;">else</span> {
    <span style="color: #00ffff;">return</span> n1 * <span style="color: #b0c4de;">pow</span>(t - 2.625 / d1, 2.0) + 0.984375;
  }
}

<span style="color: #98fb98;">float</span> easeInOutBounce(<span style="color: #98fb98;">float</span> t) {
  <span style="color: #00ffff;">return</span> t &lt; 0.5 ?
    0.5 * (1.0 - easeOutBounce(1.0 - 2.0 * t)):
    0.5 * (1.0 + easeOutBounce(2.0 * t - 1.0));
}
</pre>
</div>

<p>
以下是这些缓动函数的 <code>Maxima</code> 实现以及绘制函数本身以及一阶和二阶导数图像的命令:
</p>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #b0c4de;">load</span>(<span style="color: #ffa07a;">"draw"</span>)$

<span style="color: #00ffff;">/*</span> Sine <span style="color: #00ffff;">*/</span>
easeInSine(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">cos</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">*</span> x)$
<span style="color: #b0c4de;">plot2d</span>(easeInSine(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInSine(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInSine(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutSine(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">sin</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">*</span> x)$
<span style="color: #b0c4de;">plot2d</span>(easeOutSine(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutSine(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutSine(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutSine(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #b0c4de;">cos</span>(<span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">*</span> x) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>)$
<span style="color: #b0c4de;">plot2d</span>(easeInOutSine(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInOutSine(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInOutSine(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$


<span style="color: #00ffff;">/*</span> Quad <span style="color: #00ffff;">*/</span>
easeInQuad(x) <span style="color: #00ffff;">:=</span> x <span style="color: #00ffff;">*</span> x$
<span style="color: #b0c4de;">plot2d</span>(easeInQuad(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuad(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuad(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutQuad(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x)$
<span style="color: #b0c4de;">plot2d</span>(easeOutQuad(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuad(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuad(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutQuad(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x else <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span>2$
<span style="color: #b0c4de;">plot2d</span>(easeInOutQuad(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>, x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(
  yrange<span style="color: #00ffff;">=[-</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">5</span><span style="color: #00ffff;">]</span>,
  col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Cubic <span style="color: #00ffff;">*/</span>
easeInCubic(x) <span style="color: #00ffff;">:=</span> x<span style="color: #00ffff;">^</span>3$
<span style="color: #b0c4de;">plot2d</span>(easeInCubic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInCubic(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInCubic(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutCubic(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x)<span style="color: #00ffff;">^</span>3$
<span style="color: #b0c4de;">plot2d</span>(easeOutCubic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutCubic(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutCubic(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutCubic(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">4</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span> else <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span>3$
<span style="color: #b0c4de;">plot2d</span>(easeInOutCubic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">4</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span>, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span>, x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">4</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Quart <span style="color: #00ffff;">*/</span>
easeInQuart(x) <span style="color: #00ffff;">:=</span> x<span style="color: #00ffff;">^</span>4$
<span style="color: #b0c4de;">plot2d</span>(easeInQuart(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuart(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuart(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutQuart(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x)<span style="color: #00ffff;">^</span>4$
<span style="color: #b0c4de;">plot2d</span>(easeOutQuart(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuart(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuart(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutQuart(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">8</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">4</span> else <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span>4$
<span style="color: #b0c4de;">plot2d</span>(easeInOutQuart(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">8</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">4</span>, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">4</span>, x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">8</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">4</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">4</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Quint <span style="color: #00ffff;">*/</span>
easeInQuint(x) <span style="color: #00ffff;">:=</span> x<span style="color: #00ffff;">^</span>5$
<span style="color: #b0c4de;">plot2d</span>(easeInQuint(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuint(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInQuint(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutQuint(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x)<span style="color: #00ffff;">^</span>5$
<span style="color: #b0c4de;">plot2d</span>(easeOutQuint(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuint(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutQuint(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutQuint(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">16</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">5</span> else <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span>5$
<span style="color: #b0c4de;">plot2d</span>(easeInOutQuint(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">16</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">5</span>, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">5</span>, x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">16</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">5</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue, explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">5</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Expo <span style="color: #00ffff;">*/</span>
easeInExpo(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">0</span> then <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) else 0$
<span style="color: #b0c4de;">plot2d</span>(easeInExpo(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInExpo(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInExpo(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutExpo(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">1</span> then <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x) else 1$
<span style="color: #b0c4de;">plot2d</span>(easeOutExpo(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutExpo(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutExpo(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutExpo(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">or</span> x <span style="color: #00ffff;">=</span> <span style="color: #7fffd4;">1</span>) then x else <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) else <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>))$
<span style="color: #b0c4de;">plot2d</span>(easeInOutExpo(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>), x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>)), x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>)), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Circ <span style="color: #00ffff;">*/</span>
easeInCirc(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>);
<span style="color: #b0c4de;">plot2d</span>(easeInCirc(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInCirc(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInCirc(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutCirc(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>);
<span style="color: #b0c4de;">plot2d</span>(easeOutCirc(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutCirc(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutCirc(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutCirc(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>)) else <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>);
<span style="color: #b0c4de;">plot2d</span>(easeInOutCirc(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>)), x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>), x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>)), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #b0c4de;">sqrt</span>(<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> (<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Back <span style="color: #00ffff;">*/</span>
easeInBack(x) <span style="color: #00ffff;">:=</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> x<span style="color: #00ffff;">^</span>2$
<span style="color: #b0c4de;">plot2d</span>(easeInBack(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInBack(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeInBack(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutBack(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">+</span> (<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">3</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span>2$
<span style="color: #b0c4de;">plot2d</span>(easeOutBack(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutBack(x), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(easeOutBack(x), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutBack(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(<span style="color: #00ffff;">[</span>c2<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span><span style="color: #00ffff;">]</span>,
  <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>
  then <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((c2 <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> c2)
  else <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((c2 <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> c2) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>)
  )$
<span style="color: #b0c4de;">plot2d</span>(easeInOutBack(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span>), x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>), x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(
    <span style="color: #b0c4de;">diff</span>(
      <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">70158</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">525</span>) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">2</span>),
      x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Elastic <span style="color: #00ffff;">*/</span>
easeInElastic(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(<span style="color: #00ffff;">[</span>c4<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span><span style="color: #00ffff;">]</span>,
  <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">or</span> x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">1</span>)
  then <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> c4)
  else x
  )$
<span style="color: #b0c4de;">plot2d</span>(easeInElastic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span>)), x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span>)), x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeOutElastic(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(<span style="color: #00ffff;">[</span>c4<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span><span style="color: #00ffff;">]</span>,
  <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">or</span> x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">1</span>)
  then <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> c4) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>
  else x
  )$
<span style="color: #b0c4de;">plot2d</span>(easeOutElastic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span>)) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>, x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">plot2d</span>(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">10</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">3</span>)) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>, x, <span style="color: #7fffd4;">2</span>), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$

easeInOutElastic(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(<span style="color: #00ffff;">[</span>c5<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span><span style="color: #00ffff;">]</span>,
  <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">0</span> <span style="color: #00ffff;">or</span> x <span style="color: #00ffff;">#</span> <span style="color: #7fffd4;">1</span>)
  then
  <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> c5) else <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> c5) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>
  else x
  )$
<span style="color: #b0c4de;">plot2d</span>(easeInOutElastic(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>)), x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>)) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>, x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(
    <span style="color: #b0c4de;">diff</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>)), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">^</span>(<span style="color: #00ffff;">-</span><span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">10</span>) <span style="color: #00ffff;">*</span> <span style="color: #b0c4de;">sin</span>((<span style="color: #7fffd4;">20</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">11</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">125</span>) <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">%pi</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>)) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">1</span>)
  )$


<span style="color: #00ffff;">/*</span> Bounce <span style="color: #00ffff;">*/</span>
easeInBounce(x) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> easeOutBounce(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> x)$
<span style="color: #b0c4de;">plot2d</span>(easeInBounce(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, x), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>, x), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>, x), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$

easeOutBounce(x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(<span style="color: #00ffff;">[</span>n1<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span>, d1<span style="color: #00ffff;">:</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span><span style="color: #00ffff;">]</span>,
  <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> d1) then n1 <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x
  else <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> d1) then n1 <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> d1)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>
  else <span style="color: #00ffff;">if</span> (x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> d1) then n1 <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> d1)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>
  else n1 <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> d1)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>
  )$
<span style="color: #b0c4de;">plot2d</span>(easeOutBounce(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x, x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, x), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>, x), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>, x), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> x, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>, x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$

easeInOutBounce(x) <span style="color: #00ffff;">:=</span> <span style="color: #00ffff;">if</span> x <span style="color: #00ffff;">&lt;</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> then <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> easeOutBounce(<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)) else <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> easeOutBounce(<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>))$
<span style="color: #b0c4de;">plot2d</span>(easeInOutBounce(x), <span style="color: #00ffff;">[</span>x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">]</span>)$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>), x), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>), x), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=or</span>ange,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>), x), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>), x), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>), x), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$
<span style="color: #b0c4de;">draw2d</span>(col<span style="color: #00ffff;">or=</span>red,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>green,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>),
  col<span style="color: #00ffff;">or=or</span>ange,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span>, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>blue,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">25</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">9375</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>),
  col<span style="color: #00ffff;">or=</span>yellow,
  explicit(<span style="color: #b0c4de;">diff</span>(<span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">7</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5625</span> <span style="color: #00ffff;">*</span> ((<span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">1</span>) <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">625</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>)<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">984375</span>), x, <span style="color: #7fffd4;">2</span>), x, <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">5</span> <span style="color: #00ffff;">/</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">75</span>, <span style="color: #7fffd4;">1</span>)
  )$
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org17cdc5d" class="outline-2">
<h2 id="org17cdc5d">基础噪声</h2>
<div class="outline-text-2" id="text-org17cdc5d">
<p>
从这里开始会不断介绍 <code>ShaderToy</code> 中常见的噪声算法, 掌握之后就可以看懂相当一部分的 <code>ShaderToy</code> 项目了.
</p>
</div>
<div id="outline-container-orgeb5d13b" class="outline-3">
<h3 id="orgeb5d13b">随机函数</h3>
<div class="outline-text-3" id="text-orgeb5d13b">
<blockquote>
<p>
参考资料如下:
</p>

<p>
<a href="https://thebookofshaders.com/10/">https://thebookofshaders.com/10/</a>
</p>

<p>
<a href="https://iquilezles.org/articles/sfrand/">https://iquilezles.org/articles/sfrand/</a>
</p>

<p>
在讨论随机函数前先了解一下什么是随机, 人们口中的随机一般是指数学中定义的随机: 不可预测(<code>unpredictable</code>)和不可重现.
</p>

<p>
可预测就意味着可以确定一个事件必定发生或不发生, 可重现意味着可以通过固定方法使得一个事件发生或不发生.
</p>

<p>
而计算机中的代码是死板且可以预测的, 那又是如何产生随机数呢?
</p>

<p>
对于计算机, 有两种随机, 分别如下:
</p>

<p>
<b>确定性随机 (<code>deterministic random</code>)</b>
</p>

<p>
用算法生成一个数列, 该数列的特性接近随机数列的特性, 然后根据参数从该数列获取一个数字作为随机数, 通过相同参数可以获得相同随机数,
</p>

<p>
这种随机可以通过算法和参数来预测随机数, 因此也被称为伪随机 (<code>pseudo-random</code>). 数据结构中的哈希函数 (<code>hash</code>) 就属于伪随机函数.
</p>

<p>
<b>非确定性随机 (<code>non-deterministic random</code>)</b>
</p>

<p>
这种随机是不可预测和不可重现的, 可以被认为是真随机(<code>truely random</code>), 它的随机数不是通过算法来生成的, 而是来源于物理现象, 比如电子噪声, 量子效应, 大气噪声和用户输入等等.
</p>

<p>
<code>Linux</code> 的 <a href="https://en.wikipedia.org/wiki//dev/random">/dev/random</a> 就是从环境噪声获取随机数.
</p>

<p>
若感兴趣, 可以看一下这个<a href="https://www.bilibili.com/video/BV1rA411Z7eP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9fdcd332c2d3e867a2fe257ff4f28e30">视频: 计算机如何生成(伪)随机</a>.
</p>
</blockquote>

<p>
<code>Shader</code> 里用的是确定性随机函数, 需要开发人员自己实现的, 确定性随机函数本质上是一个周期函数,
</p>

<p>
比如 \(\sin\), 并把它的值域限定在 \([0, 1]\) 上.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> rand = <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(x));  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#38480;&#21046;&#22312; [0, 1] &#30340;&#33539;&#22260;&#20869;</span>
</pre>
</div>


<div id="org0ecf03b" class="figure">
<p><img src="../../../files/fract-sin.png" alt="fract-sin.png" width="500px">
</p>
</div>

<p>
你可能觉得这个随机数看作不够随机, 那就让它们看起来更加混乱吧.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> rand = <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(x) * 10000.0);
</pre>
</div>


<div id="org4b257af" class="figure">
<p><img src="../../../files/fract-sin-100000.png" alt="fract-sin-100000.png" width="504px">
</p>
</div>

<p>
即便它看着混乱随机, 但仍是可以预测.
</p>

<blockquote>
<p>
随机数的生成并不只有一种算法, 你可以充分使用自己的知识去创建随机函数.
</p>

<p>
比如, <a href="https://iquilezles.org/">Iquilezles</a> 提供了一个<a href="https://iquilezles.org/articles/sfrand/">更好的随机数方案</a>, 有兴趣的可以看一下.
</p>
</blockquote>

<p>
一般来说, 编程语言中提供的随机函数都是像这个 \(rand\) 一样服从均匀分布的.
</p>

<p>
在实际开发中偶尔想让随机函数服从特定分布, 想要控制随机数的分布, 根据均匀分布的普遍性,
</p>

<p>
可以对服从均匀分布的随机数 \(X\) 进行变换成服从其它分布的随机数 \(Y\), 这需要掌握一定的概率论知识,
</p>

<p>
在我的概率论学习笔记中有写到具体的<a href="../../2024/11/introduction-to-probability.html#implement-pdf-random-function">程序实现思路</a>, 以下是符合指数分布的随机函数的 <code>GLSL</code> 实现:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> inverse_cdf_exponential(<span style="color: #98fb98;">float</span> u, <span style="color: #98fb98;">float</span> lambda) {
  <span style="color: #00ffff;">return</span> -<span style="color: #b0c4de;">log</span>(1.0 - u) / lambda;
}

<span style="color: #98fb98;">float</span> exponential_random(<span style="color: #98fb98;">float</span> x, <span style="color: #98fb98;">float</span> lambda) {
  <span style="color: #98fb98;">float</span> u = <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(x) * 10000.0);
  <span style="color: #00ffff;">return</span> inverse_cdf_exponential(u, lambda);
}
</pre>
</div>

<p>
另外, <code>Pixelero</code> 也发布了一片<a href="https://pixelero.wordpress.com/2008/04/24/various-functions-and-various-distributions-with-mathrandom/">文章</a>来介绍服从一些分布的随机数函数.
</p>
</div>
<div id="outline-container-org491d238" class="outline-4">
<h4 id="org491d238">高维随机函数</h4>
<div class="outline-text-4" id="text-org491d238">
<p>
在 <code>Shader</code> 开发中通常需要根据纹理坐标来生成随机数, 而上面介绍的 \(rand\) 是一个 <code>1D</code> 随机函数, 并不能很好地满足需求, 这需要 <code>2D</code> 随机函数.
</p>

<p>
同理, 也存在 <code>3D</code> 和 <code>4D</code> 甚至更高维的随机函数.
</p>

<p>
假设高维随机函数 \(f\) 是一个以 \(n\) 维向量 \(v \in \mathbb{R}^n\) 作为输入, 以标量 \(r\) 作为输出: \(r = f(v)\).
</p>

<p>
其实高维随机函数的实现思路其实和 <code>1D</code> 随机函数差不多, 只不过要对 \(v\) 做计算, 其计算结果是一个标量 \(i\) , 最后用 \(i\) 作为 <code>1D</code> 随机函数 \(g\) 的输入得出 \(r = g(i)\).
</p>

<p>
把向量转换成标量的话, 首先想到的是点积运算, 来看一个例子:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> rand(<span style="color: #98fb98;">vec2</span> st) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(<span style="color: #b0c4de;">dot</span>(st.xy, <span style="color: #98fb98;">vec2</span>(12.9898, 78.233))) * 43758.5453123);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge21d4a9" class="outline-4">
<h4 id="orge21d4a9">向量值函数形式的随机函数</h4>
<div class="outline-text-4" id="text-orge21d4a9">
<p>
这种随机函数是用来生成向量的, 在 <code>Shader</code> 开发中通常是用来根据坐标计算出对应片元的颜色, 这种函数既可以用标量, 也可以用向量作为输入, 最后以向量作为输出.
</p>

<p>
比如下面这个例子, 以 <code>2D</code> 向量作为输入和输出:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://www.shadertoy.com/view/lldyDn
</span><span style="color: #98fb98;">vec2</span> rand(<span style="color: #98fb98;">vec2</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3 = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec3</span>(p.xyx) * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx+19.19);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xx+p3.yz) * p3.zy);
}
</pre>
</div>

<p>
比如以 <code>3D</code> 向量作为输入和输出:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec3</span> rand(<span style="color: #98fb98;">vec3</span> v) {
  <span style="color: #98fb98;">vec3</span> p = <span style="color: #98fb98;">vec3</span>(<span style="color: #b0c4de;">dot</span>(v, <span style="color: #98fb98;">vec3</span>(127.1, 311.7, 74.7)), <span style="color: #b0c4de;">dot</span>(v, <span style="color: #98fb98;">vec3</span>(269.5, 183.3, 246.1)), <span style="color: #b0c4de;">dot</span>(v, <span style="color: #98fb98;">vec3</span>(113.5, 271.9, 124.6)));
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(p) * 43758.5453123);
}
</pre>
</div>

<p>
比如以 <code>2D</code> 向量作为输入, 以 <code>3D</code> 向量作为输出:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec3</span> rand(<span style="color: #98fb98;">vec2</span> v) {
  v -= 0.00001727738;
  <span style="color: #98fb98;">float</span> z = <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">tan</span>(v.x*3.14+v.y))*10.751135;
  <span style="color: #98fb98;">vec3</span> a = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec3</span>(v.x/1.000383,v.y/1.000401,z)*3.14)*10.8372611876;
  <span style="color: #98fb98;">float</span> w = <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">dot</span>(a, <span style="color: #98fb98;">vec3</span>(1.3774, 8.2446, 2.2883)))*10.0973326;
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(7.817082*<span style="color: #b0c4de;">tan</span>(9.726749*<span style="color: #b0c4de;">reflect</span>(a, <span style="color: #98fb98;">vec3</span>(w, z, <span style="color: #b0c4de;">fract</span>(z*43.28)*10.114865))));
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orge214715" class="outline-4">
<h4 id="orge214715">三角函数的缺陷</h4>
<div class="outline-text-4" id="text-orge214715">
<p>
在 <code>WebGL</code> 或 <code>OpenGL</code> 中, \(\sin\) 的实现取决于机器, 这导致了同一段 <code>Shader</code> 代码在不同平台上的效果不一样.
</p>

<p>
<code>Iquilezles</code> 后来总结了一些算法来规避这个问题:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://www.shadertoy.com/view/llGSzw
</span><span style="color: #98fb98;">float</span> hash11 ( <span style="color: #98fb98;">uint</span> n ) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">integer hash copied from Hugo Elias
</span>  n = (n &lt;&lt; 13U) ^ n;
  n = n * (n * n * 15731U + 789221U) + 1376312589U;
  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">float</span>( n &amp; <span style="color: #98fb98;">uint</span>(0x7fffffffU))/<span style="color: #98fb98;">float</span>(0x7fffffff);
}

<span style="color: #98fb98;">vec3</span> hash13( <span style="color: #98fb98;">uint</span> n )
{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">integer hash copied from Hugo Elias
</span>  n = (n &lt;&lt; 13U) ^ n;
  n = n * (n * n * 15731U + 789221U) + 1376312589U;
  <span style="color: #98fb98;">uvec3</span> k = n * <span style="color: #98fb98;">uvec3</span>(n,n*16807U,n*48271U);
  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">vec3</span>( k &amp; <span style="color: #98fb98;">uvec3</span>(0x7fffffffU))/<span style="color: #98fb98;">float</span>(0x7fffffff);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://www.shadertoy.com/view/4tXyWN
</span><span style="color: #98fb98;">uint</span> hash21( <span style="color: #98fb98;">uvec2</span> p )
{
  p *= <span style="color: #98fb98;">uvec2</span>(73333,7777);
  p ^= (<span style="color: #98fb98;">uvec2</span>(3333777777)&gt;&gt;(p&gt;&gt;28));
  <span style="color: #98fb98;">uint</span> n = p.x*p.y;
  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">float</span>(n^(n&gt;&gt;15)) * (1.0 / <span style="color: #98fb98;">float</span>(0xffffffffU));
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">https://www.shadertoy.com/view/XlXcW4
</span><span style="color: #98fb98;">vec3</span> hash33( <span style="color: #98fb98;">uvec3</span> p ) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">uint</span> k = 1103515245U;    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">GLIB C
</span>  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">const uint k = 134775813U;   // Delphi and Turbo Pascal
</span>  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)
</span>  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">const uint k = 1664525U;     // Numerical Recipes
</span>  p = ((p&gt;&gt;8U)^p.yzx) * k;
  p = ((p&gt;&gt;8U)^p.yzx) * k;
  p = ((x&gt;&gt;8U)^p.yzx) * k;

  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">vec3</span>(x) * (1.0 / <span style="color: #98fb98;">float</span>(0xffffffffU));
}
</pre>
</div>

<p>
不过这些随机函数还不够齐全, 所以从 <a href="https://tips.orels.sh/optimized-hash-for-shaders">Orels' Tips</a> 摘抄了一个较为全面的实现, 并进行了调整:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">1 out, 1 in...
</span><span style="color: #98fb98;">float</span> chash11(<span style="color: #98fb98;">float</span> p)
{
  p = <span style="color: #b0c4de;">fract</span>(p * .1031);
  p *= p + 33.33;
  p *= p + p;
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(p);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">1 out, 2 in...
</span><span style="color: #98fb98;">float</span> chash12(<span style="color: #98fb98;">vec2</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3  = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec3</span>(p.xyx) * .1031);
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx + 33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.x + p3.y) * p3.z);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">1 out, 3 in...
</span><span style="color: #98fb98;">float</span> chash13(<span style="color: #98fb98;">vec3</span> p3)
{
  p3  = <span style="color: #b0c4de;">fract</span>(p3 * .1031);
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.zyx + 31.32);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.x + p3.y) * p3.z);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">2 out, 1 in...
</span><span style="color: #98fb98;">vec2</span> chash21(<span style="color: #98fb98;">float</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3 = <span style="color: #b0c4de;">fract</span>( p * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973) );
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx + 33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xx+p3.yz)*p3.zy);

}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">///  </span><span style="color: #ff7f24;">2 out, 2 in...
</span><span style="color: #98fb98;">vec2</span> chash22(<span style="color: #98fb98;">vec2</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3 = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec3</span>(p.xyx) * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xx+p3.yz)*p3.zy);

}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">///  </span><span style="color: #ff7f24;">2 out, 3 in...
</span><span style="color: #98fb98;">vec2</span> chash23(<span style="color: #98fb98;">vec3</span> p3)
{
  p3 = <span style="color: #b0c4de;">fract</span>(p3 * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xx+p3.yz)*p3.zy);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">//  </span><span style="color: #ff7f24;">3 out, 1 in...
</span><span style="color: #98fb98;">vec3</span> chash31(<span style="color: #98fb98;">float</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3 = <span style="color: #b0c4de;">fract</span>(p * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yzx+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xxy+p3.yzz)*p3.zyx);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">///  </span><span style="color: #ff7f24;">3 out, 2 in...
</span><span style="color: #98fb98;">vec3</span> chash32(<span style="color: #98fb98;">vec2</span> p)
{
  <span style="color: #98fb98;">vec3</span> p3 = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec3</span>(p.xyx) * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yxz+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xxy+p3.yzz)*p3.zyx);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">///  </span><span style="color: #ff7f24;">3 out, 3 in...
</span><span style="color: #98fb98;">vec3</span> chash33(<span style="color: #98fb98;">vec3</span> p3)
{
  p3 = <span style="color: #b0c4de;">fract</span>(p3 * <span style="color: #98fb98;">vec3</span>(.1031, .1030, .0973));
  p3 += <span style="color: #b0c4de;">dot</span>(p3, p3.yxz+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p3.xxy + p3.yxx)*p3.zyx);

}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 out, 1 in...
</span><span style="color: #98fb98;">vec4</span> chash41(<span style="color: #98fb98;">float</span> p)
{
  <span style="color: #98fb98;">vec4</span> p4 = <span style="color: #b0c4de;">fract</span>( p * <span style="color: #98fb98;">vec4</span>(.1031, .1030, .0973, .1099));
  p4 += <span style="color: #b0c4de;">dot</span>(p4, p4.wzxy+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p4.xxyz+p4.yzzw)*p4.zywx);

}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 out, 2 in...
</span><span style="color: #98fb98;">vec4</span> chash42(<span style="color: #98fb98;">vec2</span> p)
{
  <span style="color: #98fb98;">vec4</span> p4 = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec4</span>(p.xyxy) * <span style="color: #98fb98;">vec4</span>(.1031, .1030, .0973, .1099));
  p4 += <span style="color: #b0c4de;">dot</span>(p4, p4.wzxy+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p4.xxyz+p4.yzzw)*p4.zywx);

}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 out, 3 in...
</span><span style="color: #98fb98;">vec4</span> chash43(<span style="color: #98fb98;">vec3</span> p)
{
  <span style="color: #98fb98;">vec4</span> p4 = <span style="color: #b0c4de;">fract</span>(<span style="color: #98fb98;">vec4</span>(p.xyzx)  * <span style="color: #98fb98;">vec4</span>(.1031, .1030, .0973, .1099));
  p4 += <span style="color: #b0c4de;">dot</span>(p4, p4.wzxy+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p4.xxyz+p4.yzzw)*p4.zywx);
}

<span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">----------------------------------------------------------------------------------------
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">4 out, 4 in...
</span><span style="color: #98fb98;">vec4</span> chash44(<span style="color: #98fb98;">vec4</span> p4)
{
  p4 = <span style="color: #b0c4de;">fract</span>(p4  * <span style="color: #98fb98;">vec4</span>(.1031, .1030, .0973, .1099));
  p4 += <span style="color: #b0c4de;">dot</span>(p4, p4.wzxy+33.33);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>((p4.xxyz+p4.yzzw)*p4.zywx);
}
</pre>
</div>

<p>
按照哈希函数去实现的随机函数也很常见, 这种函数方便预计算:
</p>



<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> mod289(<span style="color: #98fb98;">float</span> x) {
  <span style="color: #00ffff;">return</span> x - <span style="color: #b0c4de;">floor</span>(x * (1.0 / 289.0)) * 289.0;
}

<span style="color: #98fb98;">vec2</span> mod289(<span style="color: #98fb98;">vec2</span> x) {
  <span style="color: #00ffff;">return</span> x - <span style="color: #b0c4de;">floor</span>(x * (1.0 / 289.0)) * 289.0;
}

<span style="color: #98fb98;">vec3</span> mod289(<span style="color: #98fb98;">vec3</span> x) {
  <span style="color: #00ffff;">return</span> x - <span style="color: #b0c4de;">floor</span>(x * (1.0 / 289.0)) * 289.0;
}

<span style="color: #98fb98;">vec4</span> mod289(<span style="color: #98fb98;">vec4</span> x) {
  <span style="color: #00ffff;">return</span> x - <span style="color: #b0c4de;">floor</span>(x * (1.0 / 289.0)) * 289.0;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">mod(34.0 * x * x + 10.0 * x, 289.0)
</span><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">34.0 * x * x + 10.0 * x &#20026;&#38750;&#32447;&#24615;&#20989;&#25968;, &#35813;&#20989;&#25968;&#20855;&#22791;&#38634;&#23849;&#25928;&#24212;(avalanche effect),
   &#21363;&#36755;&#20837;&#21457;&#29983;&#24494;&#23567;&#25913;&#21464;&#20250;&#23548;&#33268;&#36755;&#20986;&#21457;&#29983;&#24040;&#22823;&#19988;&#19981;&#21487;&#39044;&#27979;&#30340;&#21464;&#21270;, &#25110;&#32773;&#35828;&#20855;&#22791;&#36739;&#22823;&#30340;&#38750;&#24120;&#25968;&#23548;&#25968;</span><span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">float</span> permute(<span style="color: #98fb98;">float</span> x) {
     <span style="color: #00ffff;">return</span> mod289(((x*34.0)+10.0)*x);
}

<span style="color: #98fb98;">vec2</span> permute(<span style="color: #98fb98;">vec2</span> x) {
     <span style="color: #00ffff;">return</span> mod289(((x*34.0)+10.0)*x);
}

<span style="color: #98fb98;">vec3</span> permute(<span style="color: #98fb98;">vec3</span> x) {
     <span style="color: #00ffff;">return</span> mod289(((x*34.0)+10.0)*x);
}

<span style="color: #98fb98;">vec4</span> permute(<span style="color: #98fb98;">vec4</span> x) {
     <span style="color: #00ffff;">return</span> mod289(((x*34.0)+10.0)*x);
}
</pre>
</div>

<blockquote>
<p>
个人很喜欢该实现, 因为相比前面的实现来说太简单.
</p>

<p>
该实现的理论基础是同余方程(<code>Nonlinear Congruence Equation</code>)中的二次同余: \(kx^2 + bx + c \equiv a \pmod{m}\).
</p>

<p>
奈何本人对数论不太熟悉, 所以这里就只留一个线索待日后探索.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org8fa24ce" class="outline-3">
<h3 id="org8fa24ce">噪声函数</h3>
<div class="outline-text-3" id="text-org8fa24ce">
<p>
噪声 (<code>noise</code>) 也是一种随机, 但相比一般的随机, 噪声的过度显得更加平滑, 更自然, 适合用来生成丰富的视觉效果, 因此, 噪声也被成为平滑随机性 (<code>smooth randomness</code>).
</p>

<p>
先来感受一下, 随机函数和噪音函数之间的区别, 以下是分别是随机函数 \(rand1(x)\), \(rand2(x)\) 和噪声函数 \(noise(x)\) 的 <code>Maxima</code> 的实现以及对应的函数图像:
</p>

<div class="org-src-container">
<pre class="src src-maxima">fract(x) <span style="color: #00ffff;">:=</span> x <span style="color: #00ffff;">-</span> <span style="color: #b0c4de;">floor</span>(x)$
mix(x, y, a) <span style="color: #00ffff;">:=</span> x <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">-</span> a) <span style="color: #00ffff;">+</span> y <span style="color: #00ffff;">*</span> a$
smoothstep(l, u, x) <span style="color: #00ffff;">:=</span> <span style="color: #b0c4de;">block</span>(
  t<span style="color: #00ffff;">:</span> <span style="color: #b0c4de;">min</span>(<span style="color: #b0c4de;">max</span>((x <span style="color: #00ffff;">-</span> l) <span style="color: #00ffff;">/</span> (u <span style="color: #00ffff;">-</span> l), <span style="color: #7fffd4;">0</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>), <span style="color: #7fffd4;">1</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>),
  <span style="color: #b0c4de;">return</span> (t <span style="color: #00ffff;">*</span> t <span style="color: #00ffff;">*</span> (<span style="color: #7fffd4;">3</span> <span style="color: #00ffff;">-</span> <span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">*</span> t))
  )$

r<span style="color: #00ffff;">and</span>(x) <span style="color: #00ffff;">:=</span> fract(<span style="color: #b0c4de;">sin</span>(x))$

<span style="color: #00ffff;">/*</span> &#38543;&#26426;&#31639;&#27861;&#20197;&#21450;&#23427;&#20204;&#30340;&#22270;&#20687; <span style="color: #00ffff;">*/</span>
r<span style="color: #00ffff;">and</span>1(x) <span style="color: #00ffff;">:=</span> r<span style="color: #00ffff;">and</span>(<span style="color: #b0c4de;">floor</span>(x))$
r<span style="color: #00ffff;">and</span>2(x) <span style="color: #00ffff;">:=</span> mix(r<span style="color: #00ffff;">and</span>(<span style="color: #b0c4de;">floor</span>(x)), r<span style="color: #00ffff;">and</span>(<span style="color: #b0c4de;">floor</span>(x) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>), fract(x))$
noise(x) <span style="color: #00ffff;">:=</span> mix(r<span style="color: #00ffff;">and</span>(<span style="color: #b0c4de;">floor</span>(x)), r<span style="color: #00ffff;">and</span>(<span style="color: #b0c4de;">floor</span>(x) <span style="color: #00ffff;">+</span> <span style="color: #7fffd4;">1</span>), smoothstep(<span style="color: #7fffd4;">0</span>, <span style="color: #7fffd4;">1</span>, fract(x)))$

<span style="color: #b0c4de;">plot2d</span>(<span style="color: #00ffff;">[</span>r<span style="color: #00ffff;">and</span>1(x), r<span style="color: #00ffff;">and</span>2(x), noise(x)<span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>x, <span style="color: #00ffff;">-</span><span style="color: #7fffd4;">4</span>, <span style="color: #7fffd4;">4</span><span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>col<span style="color: #00ffff;">or</span>, red, blue, green<span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>legend, <span style="color: #ffa07a;">"rand1"</span>, <span style="color: #ffa07a;">"rand2"</span>, <span style="color: #ffa07a;">"noise"</span><span style="color: #00ffff;">]</span>)$
</pre>
</div>


<div id="orgcbb8c47" class="figure">
<p><img src="../../../files/noise-functions.png" alt="noise-functions.png" width="504px">
</p>
</div>

<p>
正如图片所示, 令 \(z = floor(x)\), 从 \(rand1\) 到 \(rand2\), 为随机数 \(rand1(z)\) 和 \(rand1(z + 1.0)\) 之间引入了线性插值, 从 \(rand2\) 到 \(noise\), 为随机数 \(rand1(z)\) 和 \(rand1(z + 1.0)\) 之间引入了非线性插值, 函数图像变得越来越平滑.
</p>

<p>
\(noise\) 的算法可以看作是在一条线上的两个点之间进行插值, 这个点是根据参数 \(x\) 来决定的, 以 \([floor(x), floor(x) + 1]\) 作为插值范围来保证变化间隔为 1, 以 \(x\) 的小数部分 \(fract(x)\) 作为插值参数, 从而得出噪声值.
</p>


<div id="org1d0ff8a" class="figure">
<p><img src="../../../files/value-noise-1d-lerp.png" alt="value-noise-1d-lerp.png">
</p>
</div>

<blockquote>
<p>
在实际应用中, 可以根据自身需求替换插值方法, 比如想换函数 \(g\) 来进行插值: \(f(a, b, t) = (1 - g(t)) \cdot a - g(t) \cdot b\),
</p>

<p>
而 \(noise\) 函数里面的 \(g(t) = smoothstep(0, 1, t)\);
</p>

<p>
当 \(g(t) = \frac{1 - \cos(\pi t)}{2}\) 时, \(f\) 被叫做余弦插值 (<code>Cosine Interpolation</code>);
</p>

<p>
另外一个比较有名的插值函数是五次插值曲线: \(g(t) = 6t^5 - 15t^4 + 10t^3\), 是 \(smoothstep\) 的改进替代.
</p>
</blockquote>

<p>
<code>GLSL</code> 也提供了内置的噪音函数: <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/noise.xhtml">noise</a>, 但对于创意工作而言,
</p>

<p>
这个内置函数并不能完全满足创作者的需求, 所以基本上都是自己实现噪声函数, 或者使用第三方实现, 比如 <a href="https://github.com/patriciogonzalezvivo/lygia/tree/main/generative">lygia/generative</a>.
</p>

<p>
噪声算法有很多, 很多艺术创作者会根据需求来选择合适的噪声算法来进行艺术创作, 比如柏林噪声算法(<code>Perlin Noise Algorithm</code>),
</p>

<p>
接下来会介绍三种比较基础的噪声算法: 值噪声, 梯度噪声以及单形噪声.
</p>
</div>
<div id="outline-container-org1db0250" class="outline-4">
<h4 id="org1db0250">值噪声</h4>
<div class="outline-text-4" id="text-org1db0250">
<p>
如上面的 <code>1D</code> 噪声所示, 可以看作是一线条上 \(2^1\) 个点对应的随机数之间的插值, 而 <code>2D</code> 噪声可以看作是一个矩形上 \(2^2\) 个角对应的随机数之间的插值, 如此类推, <code>3D</code> 噪声可以看作立方体上 \(2^3\) 个角对应的随机数之间的插值.
</p>

<p>
这种对随机数进行插值得到噪声被称为值噪声 (<code>value noise</code>).
</p>

<blockquote>
<p>

</p>

<p>
<b>双线性插值法 (<code>bilinear interpolation</code>)</b>
</p>

<p>
根据平面的 4 个角进行插值的技巧需要参考双线性插值法, 这种技巧也可以解决贴图在缩放显示时出现的纹理不平滑问题,
</p>


<div id="org1fe6ebb" class="figure">
<p><img src="../../../files/bilinear-texture-weights.png" alt="bilinear-texture-weights.png" width="504px">
</p>
</div>

<p>
如图所示, 想要计算出平面中 \(C\) 的坐标, 可先从 \(X\) 轴方向(\(TL \rightarrow TR\))进行插值,
</p>

<p>
首先计算出 \(CT = (1 - f_x) \cdot TL + f_x \cdot TR\),
</p>

<p>
再计算出 \(CB = (1 - f_x) \cdot BL + f_x \cdot BR\),
</p>

<p>
最后从 \(Y\) 轴方向进行插值计算出 \(C = (1 - f_y) \cdot CT + f_y \cdot CB\).
</p>

<p>
或者也可以先从 \(Y\) 轴方向(\(TL \rightarrow BL\))进行插值, 最后再从 \(X\) 轴方向进行插值, 结果都一样, 就不赘述了.
</p>

<p>
其 <code>GLSL</code> 如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> ct = <span style="color: #b0c4de;">mix</span>(tl, tr, fx);
<span style="color: #98fb98;">float</span> cb = <span style="color: #b0c4de;">mix</span>(bl, br, fx);
<span style="color: #98fb98;">float</span> c = <span style="color: #b0c4de;">mix</span>(ct, cb, fy);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26377;&#26102;&#20505;&#20320;&#21487;&#33021;&#30475;&#21040;&#30340;&#25554;&#20540;&#23454;&#29616;&#21487;&#33021;&#26159;&#19979;&#38754;&#36825;&#26679;&#30340;
</span><span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
  ct = tl * (1 - fx) + tr * fx
  cb = bl * (1 - fx) + br * fx
  c = [tl * (1 - fx) + tr * fx] * (1 - fy) + [bl * (1 - fx) + br * fx] * fy
    = [tl * (1 - fx) + tr * fx] - [tl * (1 - fx) + tr * fx] * fy + [bl * (1 - fx) + br * fx] * fy
    = [tl * (1 - fx) + tr * fx] + [ bl * (1 - fx) + br * fx - tl * (1 - fx) - tr * fx ] * fy
    = [tl * (1 - fx) + tr * fx] + [(bl - tl) * (1 - fx) + (br - tr) * fx] * fy
    = mix(tl, tr, fx) + [(bl - tl) * (1 - fx) + (br - tr) * fx] * fy
</span><span style="color: #ff7f24;"> */</span>
</pre>
</div>

<p>
<b>三线性插值法 (<code>trilinear interpolation</code>)</b>
</p>

<p>
根据立方体的 8 个角进行插值的技巧需要参考三线性插值法, 这种方法可以看作两个对立面的双线性插值随后加上一个线性插值.
</p>


<div id="org7b4abdb" class="figure">
<p><img src="../../../files/trilinear-interpolation.png" alt="trilinear-interpolation.png" width="504px">
</p>
</div>

<p>
需要注意的是, 这张图的 \(Y\) 轴方向是 \(c000 \rightarrow c010\), 其三线性插值的 <code>GLSL</code> 实现如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#24179;&#38754; c000 - c100 - c110 - c010 &#30340;&#21452;&#32447;&#24615;&#25554;&#20540;
</span><span style="color: #98fb98;">float</span> a = <span style="color: #b0c4de;">mix</span>(c010, c110, tx);
<span style="color: #98fb98;">float</span> b = <span style="color: #b0c4de;">mix</span>(c000, c110, tx);
<span style="color: #98fb98;">float</span> e = <span style="color: #b0c4de;">mix</span>(b, a, ty);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#24179;&#38754; c001 - c101 - c111 - c011 &#30340;&#21452;&#32447;&#24615;&#25554;&#20540;
</span><span style="color: #98fb98;">float</span> c = <span style="color: #b0c4de;">mix</span>(c001, c111, tx);
<span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">mix</span>(c001, c101, tx);
<span style="color: #98fb98;">float</span> f = <span style="color: #b0c4de;">mix</span>(d, c, ty);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545; e &#21644; f &#36827;&#34892;&#32447;&#24615;&#25554;&#20540;
</span><span style="color: #98fb98;">float</span> g = <span style="color: #b0c4de;">mix</span>(e, f, tz);
</pre>
</div>
</blockquote>

<p>
以 <code>2D</code> 噪声为例, 首先, 根据纹理坐标 \(st\) 来确定其所处网格(<code>lattice</code>)的 4 个角的坐标:
</p>

<p>
\((floor(st.x), floor(st.y))\)
</p>

<p>
\((floor(st.x) + 1.0, floor(st.y))\)
</p>

<p>
\((floor(st.x), floor(st.y) + 1.0)\)
</p>

<p>
\((floor(st.x) + 1.0, floor(st.y) + 1.0)\)
</p>

<blockquote>
<p>
另外, \((fract(st.x), fract(st.y))\) 就是 \(st\) 相对于网格的坐标.
</p>
</blockquote>

<p>
然后, 以这 4 个坐标作为随机函数的参数得到 4 个随机值,
</p>

<p>
最后, 根据这 4 个随机值进行双线性插值得到 \(st\) 所对应的随机值.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26469;&#33258; https://thebookofshaders.com/11/
</span><span style="color: #98fb98;">float</span> rand(<span style="color: #98fb98;">vec2</span> st) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(<span style="color: #b0c4de;">dot</span>(st.xy, <span style="color: #98fb98;">vec2</span>(12.9898, 78.233))) * 43758.5453123);
}

<span style="color: #98fb98;">float</span> noise (<span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec2</span> st) {
  <span style="color: #98fb98;">vec2</span> i = <span style="color: #b0c4de;">floor</span>(st);
  <span style="color: #98fb98;">vec2</span> f = <span style="color: #b0c4de;">fract</span>(st);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Four corners in 2D of a tile which is created according to st.
</span>  <span style="color: #98fb98;">float</span> a = rand(i);
  <span style="color: #98fb98;">float</span> b = rand(i + <span style="color: #98fb98;">vec2</span>(1.0, 0.0));
  <span style="color: #98fb98;">float</span> c = rand(i + <span style="color: #98fb98;">vec2</span>(0.0, 1.0));
  <span style="color: #98fb98;">float</span> d = rand(i + <span style="color: #98fb98;">vec2</span>(1.0, 1.0));

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Smooth Interpolation
</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Cubic Hermine Curve.  Same as SmoothStep()
</span>  <span style="color: #98fb98;">vec2</span> u = f*f*(3.0-2.0*f);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">u = smoothstep(0.,1.,f);
</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Mix 4 coorners percentages
</span>  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">mix</span>(a, b, u.x) +
          (c - a)* u.y * (1.0 - u.x) +
          (d - b) * u.x * u.y;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> st = <span style="color: #eedd82;">gl_FragCoord</span>.xy/iResolution.xy;

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Scale the coordinate system to see
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">some noise in action
</span>  <span style="color: #98fb98;">vec2</span> pos = <span style="color: #98fb98;">vec2</span>(st * 5.0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Use the noise function
</span>  <span style="color: #98fb98;">float</span> n = noise(pos);

  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(n), 1.0);
}
</pre>
</div>

<p>
其效果如下:
</p>


<div id="orgb2d1e78" class="figure">
<p><img src="../../../files/2d-value-noise-stX5.png" alt="2d-value-noise-stX5.png">
</p>
<p><span class="figure-number">Figure 19: </span>2D 值噪声的效果</p>
</div>
</div>
</div>
<div id="outline-container-orge8770ab" class="outline-4">
<h4 id="orge8770ab">梯度噪声</h4>
<div class="outline-text-4" id="text-orge8770ab">
<p>
一般来说, 值噪声的效果就如上图所示的那样, 看起来一块一块的, 为了消除块状效果, <code>Ken Perlin</code> 在 <code>1985</code> 年开发出了另外一种噪声算法, 得到噪声的叫梯度噪声 (<code>Gradient Noise</code>), 这个算法也就是人们熟知的柏林函数.
</p>

<p>
和值噪声算法的区别在于, 梯度噪声的随机函数以方向(<code>vec2/vec3/vec4</code>)作为输出, 值噪声的随机函数以值(<code>float</code>)作为输出.
</p>

<p>
和值噪声的生成类似, 以 <code>2D</code> 梯度噪声为例, 通过随机函数为 4 个角生成梯度向量(需要归一化), 再通过点积运算把它们转换成 4 个标量,
</p>

<p>
之后的过程就与值噪声的计算一样. 在使用点积把梯度向量 \(\nabla\) 转换成标量时, 需要为每个角 \(p\) 计算出它的角指向(也称为距离向量),
</p>

<p>
假设 \(o\) 是网格内的坐标, 那么角指向为 \(v = (o.x - p.x, o.y - p.y)\), 最后计算角指向和梯度向量之间的点积 \(v \cdot \nabla\).
</p>

<p>
按照数学定义, 角指向是一个方向向量, 这个点积是方向导数, 换而言之, 梯度噪声的结果是一个方向导数.
</p>

<p>
如下图所示, 绿色箭头为黄格字的梯度向量 \(\nabla\), 黄点为 \(o\), 蓝色箭头为角指向 \(v\).
</p>


<div id="org3d3fc84" class="figure">
<p><img src="../../../files/perlin-noise.png" alt="perlin-noise.png" width="504px">
</p>
</div>

<p>
按照该思路, 下面为 <code>GLSL</code> 的实现:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2D &#21521;&#37327;&#20540;&#20989;&#25968;&#24418;&#24335;&#30340;&#38543;&#26426;&#20989;&#25968;
</span><span style="color: #98fb98;">vec2</span> rand(<span style="color: #98fb98;">vec2</span> st){
    st = <span style="color: #98fb98;">vec2</span>(<span style="color: #b0c4de;">dot</span>(st, <span style="color: #98fb98;">vec2</span>(127.1,311.7)),
              <span style="color: #b0c4de;">dot</span>(st, <span style="color: #98fb98;">vec2</span>(269.5,183.3)));
    <span style="color: #00ffff;">return</span> -1.0 + 2.0 * <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(st) * 43758.5453123);
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#24402;&#19968;&#21270;
</span>}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#31867;&#20284;&#21069;&#38754; 2D &#22122;&#22768;&#30340;&#29983;&#25104;, &#20294;&#26159; 4 &#20010;&#35282;&#30340;&#38543;&#26426;&#20540;&#38656;&#35201;&#19968;&#30058;&#28857;&#31215;&#36816;&#31639;
</span><span style="color: #98fb98;">float</span> noise(<span style="color: #98fb98;">vec2</span> st) {
  <span style="color: #98fb98;">vec2</span> i = <span style="color: #b0c4de;">floor</span>(st);
  <span style="color: #98fb98;">vec2</span> f = <span style="color: #b0c4de;">fract</span>(st);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec2 u = f * f * (3.0 - 2.0 * f);
</span>  <span style="color: #98fb98;">vec2</span> u = <span style="color: #b0c4de;">smoothstep</span>(<span style="color: #98fb98;">vec2</span>(0.0), <span style="color: #98fb98;">vec2</span>(1.0), f);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">a,b,c,d &#26159;&#22235;&#20010;&#32593;&#26684;&#19978;&#30340;&#26799;&#24230;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">va,vb,vc,vd &#26159;&#22235;&#20010;&#35282;&#25351;&#21521;
</span>  <span style="color: #98fb98;">vec2</span> a = rand(i);
  <span style="color: #98fb98;">vec2</span> va = f - <span style="color: #98fb98;">vec2</span>(0.0, 0.0);
  <span style="color: #98fb98;">vec2</span> b = rand(i + <span style="color: #98fb98;">vec2</span>(1.0, 0.0));
  <span style="color: #98fb98;">vec2</span> vb = f - <span style="color: #98fb98;">vec2</span>(1.0, 0.0);
  <span style="color: #98fb98;">vec2</span> c = rand(i + <span style="color: #98fb98;">vec2</span>(0.0, 1.0));
  <span style="color: #98fb98;">vec2</span> vc = f - <span style="color: #98fb98;">vec2</span>(0.0, 1.0);
  <span style="color: #98fb98;">vec2</span> d = rand(i + <span style="color: #98fb98;">vec2</span>(1.0, 1.0));
  <span style="color: #98fb98;">vec2</span> vd = f - <span style="color: #98fb98;">vec2</span>(1.0, 1.0);

  <span style="color: #98fb98;">float</span> dotA = <span style="color: #b0c4de;">dot</span>(a, va);
  <span style="color: #98fb98;">float</span> dotB = <span style="color: #b0c4de;">dot</span>(b, vb);
  <span style="color: #98fb98;">float</span> dotC = <span style="color: #b0c4de;">dot</span>(c, vc);
  <span style="color: #98fb98;">float</span> dotD = <span style="color: #b0c4de;">dot</span>(d, vd);

  <span style="color: #98fb98;">float</span> ab = <span style="color: #b0c4de;">mix</span>(dotA, dotB, u.x);
  <span style="color: #98fb98;">float</span> cd = <span style="color: #b0c4de;">mix</span>(dotC, dotD, u.x);

  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">mix</span>(ab, cd, u.y);
}
</pre>
</div>

<blockquote>
<p>
如果对于前面梯度和方向导数之类的名词不了解, 那么建议阅读一下这段科普, 后面很多地方都出现了它们的应用.
</p>

<p>
梯度的全称是梯度向量(<code>gradient vector</code>), 源于微积分中标量值函数, 用来表示多元标量值函数 \(f\) 在各个分量上的变化率,
</p>

<p>
这个变化率就是梯度向量, 以二维向量为例: \(\nabla f(x, y) = (\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y})\).
</p>

<p>
梯度向量 \(\nabla f(x, y)\) 表示在所有方向中使得 \(f\) 的方向导数最大的那一个方向, 而 \(|\nabla f(x, y)|\) 表示最大方向导数的变化率大小.
</p>

<p>
在几何上, \(\nabla f(x, y)\) 是 \(f\) 在点 \((x, y)\) 上的法线向量.
</p>

<p>
方向导数 \(D_u f(x, y)\) 表示 \(f\) 在某点 \((x, y)\) 上往某方向 \(u\) 的变化率:
</p>

<p>
\(D_u f(x, y) = \nabla f(x, y) \cdot u = |\nabla f(x, y)||u| \cos_{\theta}\), 其中 \(\theta\) 为 \(\nabla f(x, y)\) 和 \(u\) 之间的夹角.
</p>

<p>
当 \(\theta = 0\) 时, 换而言之当 \(\nabla f(x, y)\) 和 \(u\) 方向相同时, \(D_u f(x, y)\) 为最大.
</p>

<p>
把 \(D_{u}f(x, y)\) 看作是一个以方向 \(u\) 为参数的函数 \(g(u)\), 那么 \(\nabla f(x, y)\) 就是 \(g\) 关于 \(u\) 导数: \(\frac{\mathrm{d}g}{\mathrm{d}u}\).
</p>
</blockquote>

<p>
那么 <code>1D</code> 的梯度噪声呢? 一维空间是一条直线, 可以把直线上的点 \(p\) (<code>p</code> 是标量)看作一个一维向量 \((p)\), 一维向量之间的点积就是标量之间的乘积,
</p>

<p>
根据这些信息, 就可以实现 <code>1D</code> 梯度噪声了:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> rand(<span style="color: #98fb98;">float</span> p) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">fract</span>(<span style="color: #b0c4de;">sin</span>(p) * 43758.5453123);
}

<span style="color: #98fb98;">float</span> noise(<span style="color: #98fb98;">float</span> p) {
  <span style="color: #98fb98;">float</span> i = <span style="color: #b0c4de;">floor</span>(p);
  <span style="color: #98fb98;">float</span> f = <span style="color: #b0c4de;">fract</span>(p);
  <span style="color: #98fb98;">float</span> u = <span style="color: #b0c4de;">smoothstep</span>(0.0, 1.0, f);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36825;&#37324;&#30340; rand(i) * 2.0 - 1.0 &#26159;&#35201;&#23545;&#26799;&#24230; rand(i) &#36827;&#34892;&#24402;&#19968;&#21270;&#20351;&#20854;&#33539;&#22260;&#22312; [-1, 1] &#20043;&#38388;
</span>  <span style="color: #98fb98;">float</span> a = rand(i) * 2.0 - 1.0;
  <span style="color: #98fb98;">float</span> va = f - 0.0;
  <span style="color: #98fb98;">float</span> b = rand(i + 1.0) * 2.0 - 1.0;
  <span style="color: #98fb98;">float</span> vb = f - 1.0;

  <span style="color: #98fb98;">float</span> dotA = a * va;
  <span style="color: #98fb98;">float</span> dotB = b * vb;

  <span style="color: #00ffff;">return</span> 2.4 * <span style="color: #b0c4de;">mix</span>(dotA, dotB, u);
}
</pre>
</div>

<p>
这里给出 <code>1D</code> 梯度噪声的实现的目的是, 解释为什么梯度噪声可以消除块状, 具体解释可以参考 <a href="https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/perlin-noise-part-2/perlin-noise.html">ScratchAPixel - Perlin Noise</a> 的 <code>Why Is Perlin/Gradient Noise Better Than Value Noise</code> 部分.
</p>

<p>
首先要理解块状效果的成因, 这需要理解高频(<code>higher frequencies</code>)和低频(<code>lower frequencies</code>)的概念:
</p>

<p>
我们把连续红点之间的变化作为对比, 变化相对大的叫做高频, 变化相对小的叫做低频.
</p>


<div id="org8f933a8" class="figure">
<p><img src="../../../files/noise-value-vs-perlin1.png" alt="noise-value-vs-perlin1.png">
</p>
<p><span class="figure-number">Figure 20: </span>理想情况: 随机值关于 \(x\) 轴良好地分布, 使得噪声函数的振荡在频率上是成规律的.</p>
</div>


<div id="org0b12548" class="figure">
<p><img src="../../../files/noise-value-vs-perlin2.png" alt="noise-value-vs-perlin2.png">
</p>
<p><span class="figure-number">Figure 21: </span>最坏情况: 一些随机值在 \(x\) 轴的一定范围内连续出现多次, 也就是说噪声函数的频率分布是不成规律的.</p>
</div>

<p>
理想的噪声函数是以高频为主, 所以它看起来随机且局部变化平滑, 但总体上呈现出相当均匀的外观(<code>homogeneous look</code>), 也就是由相似频率构成.
</p>

<p>
值噪声则是由高频和低频构成, 也就是类似上面最坏情况, 低频部分就是方块效果的成因, 在低频区域内的噪声大小非常接近, 高频和低频的过度区域则把大小接近的噪声给分割开了, 导致了块状效果.
</p>

<p>
在 <code>1D</code> 噪声函数中, 梯度噪声算法很好控制着 <code>1D</code> 噪声函数图像的形状, 并且让形状成规律.
</p>


<div id="org05fc9dc" class="figure">
<p><img src="../../../files/1d-perlin-noise-func-graph.png" alt="1d-perlin-noise-func-graph.png">
</p>
<p><span class="figure-number">Figure 22: </span>1D梯度噪声的函数图像, 梯度向量控制着噪声函数形状 (图片来源: Stefan Gustavson - Simplex Noise Demystified)</p>
</div>

<p>
这里借助 <code>1D</code> 梯度函数的实现来介绍一下它是如何控制函数图像的,
</p>

<p>
首先, \(a\) 和 \(b\) 分别是 \(p\) 和 \(p + 1\) 上的梯度: \(\begin{equation*} \begin{cases} a = rand(floor(p)) \times 2 - 1 \\ b = rand(floor(p) + 1) \times 2 - 1 \end{cases} \end{equation*}\),
</p>

<p>
\(f = \frac{p - floor(p)}{floor(p) + 1 - floor(p)} = p - floor(p) = fract(p)\), \(f \in [0, 1]\).
</p>

<p>
从 \(floor(p)\) 到 \(p\) 的向量为 \(f\), 从 \(floor(p) + 1\) 到 \(p\) 的向量为 \(f - 1\),
</p>

<p>
所以在 \(floor(p)\) 上的噪声值为 \(a \cdot f\), 在 \(floor(p) + 1\) 上的噪声值为 \(b \cdot (f - 1)\),
</p>

<p>
以下是根据两个噪声值进行插值来得出 \(p\) 上的噪声值的过程:
</p>

<p>
\(u = 3f^2 - 2f^3\), 由于 \(f \in [0, 1]\), 所以 \(u \in [0, 1]\),
</p>

<p>
设 \(P\) 是以 \(f\) 为参数的噪声函数, 那么其定义为:
</p>

<p>
\(\begin{equation*}\begin{aligned} P(f) &= a \cdot f \cdot (1 - u) + b \cdot (f - 1) \cdot u \\ &= a \cdot f + [(b - a) \cdot f - b] \cdot u \\ &= a \cdot f + (b - a) \cdot (3 f^3 - 2 f^4) - b \cdot (3 f^2 - 2 f^3) \end{aligned}\end{equation*}\)
</p>

<p>
其一阶导数为: \(P^{'}(f) = a + (b - a) \cdot (9 f^2 - 8 f^3) - b \cdot (6 f - 6 f^2)\).
</p>

<p>
根据函数定义, 函数图像在整数点上的值是 \(P(0) = P(1) = 0\).
</p>

<p>
根据导数定义, 函数图像的整数点上的斜率就是它们对应的梯度: \(P^{'}(0) = a\) 以及 \(P^{'}(1) = b\).
</p>

<p>
由于 \(P\) 是一个一元四次函数且具备周期性, 因此函数图由多个抛物线组成, 使得梯度噪声相比值噪声减少低频, 消除了块状效果.
</p>

<blockquote>
<p>
一元偶次函数的图像就是抛物线.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org4cc56e9" class="outline-4">
<h4 id="org4cc56e9">单形噪声</h4>
<div class="outline-text-4" id="text-org4cc56e9">
<blockquote>
<p>
以下内容参考以下论文进行总结:
</p>

<p>
<a href="../../../files/simplexnoise.pdf">Stefan Gustavson - Simplex Noise Demystified</a>
</p>

<p>
<a href="../../../files/efficient-computational-noise-in-GLSL.pdf">Ian McEwan, Stefan Gustavson - Efficient Computational Noise In GLSL, 2012</a>
</p>

<p>
<a href="../../../files/simplex_noise_skew_factor.pdf">Kristian Nielsen - Understanding skew factors in Simplex/Improved Perlin Noise, 2015</a>
</p>

<p>
<a href="../../../files/tiling-simplex-noise-and-flow-noise-in-two-and-three-dimensions.pdf">Ian McEwan, Stefan Gustavson  - Tiling Simplex Noise and Flow Noise in Two and Three Dimensions, 2022</a>
</p>
</blockquote>

<p>
在 <code>2001</code> 年, <code>Ken Perlin</code> 开发出了另一种名为单形噪声(<code>simplex noise</code>)的噪声算法, 相比前面的算法, 单形噪声算法有以下优点:
</p>

<ul class="org-ul">
<li>拥有更低的计算复杂性和更少的乘法运算</li>
<li>能以低计算成本拓展到更高维度的噪声</li>
<li>没有明显方向性的人工痕迹</li>
<li>拥有计算简单且明确的连续梯度</li>
<li>在硬件上更容易实现</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="orgf15859e"></a>单形<br>
<div class="outline-text-5" id="text-orgf15859e">
<p>
在可视化空间时, 会用选择一种几何图形来重复地对空间进行填充, 或说, 选择一种几何图形对空间进行细分(<code>tesselation</code>), 从而形成坐标网格.
</p>

<blockquote>
<p>
为了方便说明, 这里把正交空间上的网格叫做正交网格, 单形空间上的网格叫做单形网格.
</p>
</blockquote>

<p>
<b>在细分一些空间时, 几何图形的选择会有很多种, 而几何结构最简单的那一种选择就叫做单形(<code>simplex shape</code>), 也可以理解为空间的单位.</b>
</p>

<p>
一维空间的单形是等长的线段(一维空间只有这种选择).
</p>

<p>
对于二维空间, 通常会用正方形对它进行细分, 但正方形本身就能够划分成两个三角形.
</p>

<p>
因此, 三角形才是二维空间的单形, 二维空间的最优单形是等边三角形, 这意味着要把正方形沿着主对角线 \(y = x\) 错切成菱形, 使得划分所得的三角形等边, 2 个等边三角形可以组合成一个菱形.
</p>


<div id="org065a4c0" class="figure">
<p><img src="../../../files/2d-simplex-shape.png" alt="2d-simplex-shape.png" width="504px">
</p>
<p><span class="figure-number">Figure 23: </span>等边三角形作为单形, 填充二维空间</p>
</div>

<p>
对于三维空间, 它的单形是四面体(<code>tetrahedron</code>), 正式来说应该是正四面体, 可通过把对立方体沿着主对角线 \(x = y = z\) 进行错切, 再根据对角线划分得到 6 个正四面体.
</p>


<div id="org30ec08e" class="figure">
<p><img src="../../../files/3d-simplex-shape.png" alt="3d-simplex-shape.png" width="504px">
</p>
<p><span class="figure-number">Figure 24: </span>正四面体作为单形, 填充三维空间</p>
</div>

<p>
对于四维空间, 它的单形很难可视化, 不过它有 5 个角, 并且 24 个单形可以组合成一个错切的四维超立方体(<code>hypercube</code>).
</p>

<p>
总的来说, \(N\) 维空间的单形有 \(N + 1\) 个角, \(N!\) 个单形可以填充完一个有着 \(2^{N}\) 个角的错切 \(N\) 维超立方体.
</p>

<p>
在传统噪声算法中, 随着走向更高维度, 为每个角计算随机梯度是一个复杂度为 \(O(2^{N})\) 的问题,
</p>

<p>
如果是对单形的每个角度计算随机梯度, 那么计算复杂度会变成 \(O(N^2)\), 这就是单形的好处.
</p>
</div>
</li>
<li><a id="orgfeb5a44"></a>用求和替代插值<br>
<div class="outline-text-5" id="text-orgfeb5a44">
<p>
随着维度走高, 传统噪声函数除了计算复杂度变高外, 噪声函数的解析导数也会越来越难求解, 噪声函数的解析导数有很多用处:
</p>

<p>
包括凹凸贴图(<code>bump mapping</code>), 位移贴图(<code>displacement mapping</code>), 解析抗锯齿(<code>analytical antialiasing</code>)以及使用旋度噪声(<code>curl nosie</code>)的粒子动画.
</p>

<p>
为了解决这个问题, 单形噪声不再像梯度噪声那样根据两角的贡献值进行插值, 而是对每个角的贡献值进行求和作为噪声值.
</p>


<div id="org2d9b2c4" class="figure">
<p><img src="../../../files/2d-simplex-summation-2.png" alt="2d-simplex-summation-2.png" width="504px">
</p>
</div>

<p>
在单形噪声中, 角的贡献值的计算过程如下:
</p>

<p>
\([\max(0, r^2 - |\vec{d}|^2)]^4 \times \vec{d} \cdot \vec{g}\), 其中 \(\vec{d}\) 是角指向, \(\vec{g}\) 是梯度值, \(\max(0, r^2 - |\vec{d}|^2)\) 是衰减函数, \(|\vec{d}|^2\) 是角指向的模长.
</p>

<p>
衰减函数让贡献值随着点与角之间的距离增大而减少, 通常 \(r^2 = 0.5\), 也就是以角为圆心且半径为 \(\sqrt{0.5} \approx 0.7\) 的圆,
</p>

<p>
一般来说不会让这个圆覆盖同一个单形里的其它单形角, 因此, 半径 \(r\) 应该设定为等边三角形的高, 而不是等边三角形的边长.
</p>

<p>
在后面的实现二维单形噪声时会详细说明为什么是 \(r^2 = 0.5\).
</p>


<div id="org7e4c64a" class="figure">
<p><img src="../../../files/2d-simplex-summation.png" alt="2d-simplex-summation.png" width="504px">
</p>
</div>
</div>
</li>
<li><a id="orge7f569d"></a>决定点所处的单形, 并且决定角的遍历顺序<br>
<div class="outline-text-5" id="text-orge7f569d">
<p>
在传统噪声算法中需要判断点处于哪个网格中, 在单形噪声算法中则需要判断点处于哪个单形中.
</p>

<p>
二维空间的单行是由菱形划分的等边三角形, 分上三角形和下三角形, 判断点在那个单形也就是判断它在上三角形还是下三角形.
</p>


<div id="orgc69ee1d" class="figure">
<p><img src="../../../files/2d-simplex-selecting-traversing-order.png" alt="2d-simplex-selecting-traversing-order.png" width="504px">
</p>
</div>

<p>
在二维空间上, 如果点 \((x ,y)\) 满足 \(x \gt y\), 那么点处在下三角形中; 反之, 点处在上三角形中.
</p>

<p>
如果点处于下三角形中, 那么它的单形角的遍历顺序为 \((0, 0)\), \((1, 0)\) 和 \((1, 1)\).
</p>

<p>
如果点处于上三角形中, 那么它的单形角的遍历顺序为 \((0, 0)\), \((0, 1)\) 和 \((1, 1)\).
</p>

<p>
决定这个顺序很简单, 为了说明, 这里采用 \((i, j)\) 来作为单形的相对角坐标:
</p>

<p>
要对点 \((x, y)\) 的分量进行从大到小排序, 这个顺序决定了角相对坐标分量加 1 的顺序.
</p>

<p>
如果点的分量顺序是 \(x \gt y\), 那么是对上一个角相对坐标 \(a\) 的 \(i\) 分量先加 1, 得到角相对坐标 \(b\), 然后相对 \(b\) 的 \(j\) 分量加 1, 得到角相对坐标 \(c\):
</p>

<p>
\(a = (i, j), b = (i + 1, j), c = (i + 1, j + 1)\).
</p>

<p>
如果点的分量顺序是 \(y \gt z\), 那么是对上一个角相对坐标 \(a\) 的 \(j\) 分量先加 1, 得到角相对坐标 \(b\), 然后相对 \(b\) 的 \(i\) 分量加 1, 得到角相对坐标 \(c\):
</p>

<p>
\(a = (i, j), b = (i, j + 1), c = (i + 1, j + 1)\).
</p>

<p>
对于更高空间的点 \((x, y, \dots)\) 和角相对坐标 \((x, y, \dots)\) 同理.
</p>

<p>
下图是三维空间中判断所处单形的方法.
</p>


<div id="orgd46cb96" class="figure">
<p><img src="../../../files/3d-simplex-selecting-traversing-order.png" alt="3d-simplex-selecting-traversing-order.png" width="504px">
</p>
</div>
</div>
</li>
<li><a id="orgc27d788"></a>2D 单形噪声实现<br>
<div class="outline-text-5" id="text-orgc27d788">
<p>
这里是解读 <code>Simplex Noise Demystified</code> 原文中 <code>2D Simplex Noise</code> 的实现:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">2D simplex noise
</span><span style="color: #00ffff;">public</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">noise</span>(<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">xin</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">yin</span>) {
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">n0</span>, <span style="color: #eedd82;">n1</span>, <span style="color: #eedd82;">n2</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Noise contributions from the three corners
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Skew the input space to determine which simplex cell we're in
</span>    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">F2</span> = 0.5*(Math.sqrt(3.0)-1.0);
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">s</span> = (xin+yin)*F2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Hairy factor for 2D
</span>    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = fastfloor(xin+s);
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = fastfloor(yin+s);

    <span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">G2</span> = (3.0-Math.sqrt(3.0))/6.0;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t</span> = (i+j)*G2;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">X0</span> = i-t; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Unskew the cell origin back to (x,y) space
</span>    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">Y0</span> = j-t;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x0</span> = xin-X0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The x,y distances from the cell origin
</span>    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y0</span> = yin-Y0;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For the 2D case, the simplex shape is an equilateral triangle.
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Determine which simplex we are in.
</span>    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i1</span>, <span style="color: #eedd82;">j1</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for second (middle) corner of simplex in (i,j) coords
</span>    <span style="color: #00ffff;">if</span>(x0&gt;y0) {i1=1; j1=0;} <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1)
</span>    <span style="color: #00ffff;">else</span> {i1=0; j1=1;}
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1)
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">c = (3-sqrt(3))/6
</span>
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x1</span> = x0 - i1 + G2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for middle corner in (x,y) unskewed coords
</span>    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y1</span> = y0 - j1 + G2;
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x2</span> = x0 - 1.0 + 2.0 * G2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for last corner in (x,y) unskewed coords
</span>    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y2</span> = y0 - 1.0 + 2.0 * G2;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Work out the hashed gradient indices of the three simplex corners
</span>    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">ii</span> = i &amp; 255;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">jj</span> = j &amp; 255;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gi0</span> = perm[ii+perm[jj]] % 12;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gi1</span> = perm[ii+i1+perm[jj+j1]] % 12;
    <span style="color: #98fb98;">int</span> <span style="color: #eedd82;">gi2</span> = perm[ii+1+perm[jj+1]] % 12;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Calculate the contribution from the three corners
</span>    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t0</span> = 0.5 - x0*x0-y0*y0;
    <span style="color: #00ffff;">if</span>(t0&lt;0) n0 = 0.0;
    <span style="color: #00ffff;">else</span> {
        t0 *= t0;
        n0 = t0 * t0 * dot(grad3[gi0], x0, y0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">(x,y) of grad3 used for 2D gradient
</span>    }
    <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t1</span> = 0.5 - x1*x1-y1*y1;
    <span style="color: #00ffff;">if</span>(t1&lt;0) n1 = 0.0;
    <span style="color: #00ffff;">else</span> {
        t1 *= t1;
        n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
    }<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t2</span> = 0.5 - x2*x2-y2*y2;
    <span style="color: #00ffff;">if</span>(t2&lt;0) n2 = 0.0;
    <span style="color: #00ffff;">else</span> {
        t2 *= t2;
        n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
    }
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Add contributions from each corner to get the final noise value.
</span>    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The result is scaled to return values in the interval [-1,1].
</span>    <span style="color: #00ffff;">return</span> 70.0 * (n0 + n1 + n2);
}
</pre>
</div>

<p>
这段代码远没有作者口中的那么可读, 很多细节都没有说明, 不过确实如他所说的很方便的移植到其它语言上.
</p>

<p>
不过也不能怪作者, 因为原本 <code>Ken Perlin</code> 的实现就很难理解了.
</p>
</div>
<ul class="org-ul">
<li><a id="org9cc9c8d"></a>把正交网格变换成单形网格<br>
<div class="outline-text-6" id="text-org9cc9c8d">
<p>
在实现单形噪声时, 可以 <b>自由</b> 选择使用任何单形网格, 这里选择了 <code>Simplex Noise Demystified</code> 里的单形网格, 如下图:
</p>


<div id="orgfc5bb5d" class="figure">
<p><img src="../../../files/2d-simplex-grid-choice.png" alt="2d-simplex-grid-choice.png" width="504px">
</p>
</div>

<p>
这个单形网格是这么得到的:
</p>

<p>
把 \(x\) 轴 \(\left( \begin{array}{c} 1 \\ 0 \end{array} \right)\) 往逆时针方向旋转 \(15^{\circ}\) 得到 \(u\) 轴, 再把 \(y\) 轴 \(\left( \begin{array}{c} 0 \\ 1 \end{array} \right)\) 往顺时针方向旋转 \(15^{\circ}\) 得到 \(v\) 轴, 使得 \(u\) 和 \(v\) 两轴之间的夹角为 \(60^{\circ}\); 最后对 \(u\) 和 \(v\) 两轴进行统一伸缩.
</p>

<p>
这个结论是通过 <code>Simplex Noise Demystified</code> 以下代码反推的, 原文没有明确说明如何得到的单形网格, 因此, 结论可能有误.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">F2</span> = 0.5*(Math.sqrt(3.0)-1.0);
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">s</span> = (xin+yin)*F2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Hairy factor for 2D
</span><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i</span> = fastfloor(xin+s);
<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">j</span> = fastfloor(yin+s);

<span style="color: #00ffff;">final</span> <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">G2</span> = (3.0-Math.sqrt(3.0))/6.0;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t</span> = (i+j)*G2;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">X0</span> = i-t; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Unskew the cell origin back to (x,y) space
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">Y0</span> = j-t;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x0</span> = xin-X0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The x,y distances from the cell origin
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y0</span> = yin-Y0;
</pre>
</div>

<p>
为了方便讨论, 假设 \(\vec{u} = \left( \begin{array}{c} a \\ c \end{array} \right)\) 和 \(\vec{v} = \left( \begin{array}{c} b \\ d \end{array} \right)\) 就是旋转得到的 \(u\) 和 \(v\) 轴, 并且都是单位向量.
</p>

<p>
接下来计算得出 \(u\) 和 \(v\) 的矩阵:
</p>

<p>
\(\cos \frac{\pi}{12} = \cos(\frac{\pi}{4} - \frac{\pi}{6}) = \cos\frac{\pi}{4} \cos\frac{\pi}{6} + \sin\frac{\pi}{4} \sin\frac{\pi}{6} = \frac{\sqrt{3}}{2 \sqrt{2}} + \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} + 1)\)
</p>

<p>
\(\cos (-\frac{\pi}{12}) = \cos(\frac{\pi}{6} - \frac{\pi}{4}) = \cos\frac{\pi}{6}\cos\frac{\pi}{4} + \sin\frac{\pi}{6}\sin\frac{\pi}{4} = \frac{\sqrt{3}}{2 \sqrt{2}} + \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} + 1)\)
</p>

<p>
\(\sin \frac{\pi}{12} = \sin(\frac{\pi}{4} - \frac{\pi}{6}) = \sin\frac{\pi}{4} \cos\frac{\pi}{6} - \cos\frac{\pi}{4} \sin\frac{\pi}{6} = \frac{\sqrt{3}}{2 \sqrt{2}} - \frac{1}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(\sqrt{3} - 1)\)
</p>

<p>
\(\sin (-\frac{\pi}{12}) = \sin(\frac{\pi}{6} - \frac{\pi}{4}) = \sin\frac{\pi}{6} \cos\frac{\pi}{4} - \cos\frac{\pi}{6} \sin\frac{\pi}{4} = \frac{1}{2 \sqrt{2}} - \frac{\sqrt{3}}{2 \sqrt{2}} = \frac{1}{2 \sqrt{2}}(1 - \sqrt{3})\)
</p>

<p>
\(R(\frac{\pi}{12}) = \left( \begin{array}{c} \cos(\frac{\pi}{12}) & -\sin(\frac{\pi}{12}) \\ \sin(\frac{\pi}{12}) & \cos(\frac{\pi}{12}) \end{array} \right) = \frac{1}{2 \sqrt{2}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ \sqrt{3} - 1 & \sqrt{3} + 1 \end{array} \right)\)
</p>

<p>
\(R(-\frac{\pi}{12}) = R(\frac{\pi}{12})^{-1} = R(\frac{\pi}{12})^{T}\)
</p>

<p>
\(\vec{x}\) 轴变换得到 \(\vec{u}\) 轴: \(\vec{u} = R(\frac{\pi}{12}) \left( \begin{array}{c} 1 \\ 0 \end{array} \right) = \frac{1}{2\sqrt{2}}\left( \begin{array}{c} \sqrt{3} + 1 \\ \sqrt{3} - 1 \end{array} \right)\).
</p>

<p>
\(\vec{y}\) 轴变换得到 \(\vec{v}\) 轴: \(\vec{v} = R(-\frac{\pi}{12}) \left( \begin{array}{c} 0 \\ 1 \end{array} \right) = \frac{1}{2\sqrt{2}} \left(\begin{array}{c} \sqrt{3} - 1 \\ \sqrt{3} + 1 \end{array} \right)\).
</p>

<p>
所以, 可以得出 \(\begin{equation*} \begin{cases} a = d = \frac{1}{2\sqrt{2}}(\sqrt{3} + 1) \\ b = c = \frac{1}{2\sqrt{2}}(\sqrt{3} - 1) \\ \end{cases} \end{equation*}\), 这个变换可以用矩阵 \(M_{r} = \frac{1}{2\sqrt{2}} \left( \begin{array}{c} \sqrt{3} + 1 & \sqrt{3} - 1 \\ \sqrt{3} - 1 & \sqrt{3} + 1 \end{array} \right)\) 表示.
</p>

<p>
仅凭这些是没办法看出与代码有什么关系, 这是因为文中代码做了性能优化,
</p>

<p>
非常感谢 <code>Kristian Nielsen</code> 的贡献, 不然破头也想不出来.
</p>

<p>
先来看一下从 \(xy\) 到 \(uv\) 之间变换: \(\begin{equation*} \begin{cases} u = ax + by \\ v = cx + dy \end{cases} \end{equation*}\), 因为 \(a = d\) 并且 \(b = c\), 所以该关系可以写成 \(\begin{equation*} \begin{cases} u = ax + by \\ v = bx + ay \end{cases} \end{equation*}\).
</p>

<p>
整个变换需要 4 次乘法, 文中引入 "Fancy version of zero" 对变换进行重组得到: \(\begin{equation*} \begin{cases} u = ax - bx + bx  + by = (a - b)x + b(x + y) \\ v = bx - by + by + ay = (a - b)y + b(x + y) \end{cases} \end{equation*}\),
</p>

<p>
其中 \(b(x + y)\) 是重复运算, 可以减少 1 次乘法运算; 再使得 \(a - b = 1\), 则可以再去掉 2 次乘法运算 \(\begin{cases} (a - b)x \\ (a - b)y \end{cases}\),
</p>

<p>
那么整个变换只需要 1 次乘法运算 \(b(x + y)\).
</p>

<p>
因为 \(a - b = \frac{\sqrt{2}}{2}\), 所以只要让 \(a\) 和 \(b\) 同时除以 \(\frac{\sqrt{2}}{2}\) 或乘以 \(\sqrt{2}\) 即可使得 \(a - b = 1\), 对应了开头说的统一缩放变换,
</p>

<p>
可以用矩阵 \(M_{s} = \sqrt{2} \left( \begin{array}{c} 1 & 0 \\ 0 & 1 \end{array} \right)\) 表示.
</p>

<p>
同时说明了最终的单形网格空间的基向量并非单位向量: \(\begin{equation*} \begin{cases} \sqrt{2} \times \frac{1}{2\sqrt{2}} = \frac{1}{2} \\ a_{1} = d_{1} = \frac{1}{2}(\sqrt{3} + 1) \\ b_{1} = c_{1} = \frac{1}{2}(\sqrt{3} - 1) \end{cases} \end{equation*}\).
</p>

<p>
再回过头来对比整个变换过程 \(M = M_{s}M_{r}\) 和上面的代码, 其中 \(b_{1}(x + y)\) 对应 \(\mathrm{(xin + yin) * F2}\), 并且 \(b_{1} = \mathrm{F2} = \frac{\sqrt{3} - 1}{2}\).
</p>

<p>
把单形网格空间上的点还原到正交网格上, 就是求 \(M\) 的逆矩阵 \(M^{-1} = M_{r}^{-1}M_{s}^{-1} = \left( \begin{array}{c} a_2 & b_2 \\ c_2 & d_2 \end{array} \right)\),
</p>

<p>
该变换也可以像上面那样写成: \(\begin{equation*} \begin{cases} x = a_{2}u - b_{2}u + b_{2}u  + b_{2}v = (a_{2} - b_{2})u + b_{2}(u + v) \\ y = b_{2}u - b_{2}v + b_{2}v + a_{2}v = (a_{2} - b_{2})v + b_{2}(u + v) \end{cases} \end{equation*}\).
</p>

<p>
\(M_{s}^{-1} = \frac{\sqrt{2}}{2} \left( \begin{array}{c} 1 & 0 \\ 0 & 1 \end{array} \right)\)
</p>

<p>
\(M_{r}^{-1} = \frac{1}{ad - bc} \left( \begin{array}{c} d & -c \\ -b & a \end{array} \right) = \frac{1}{\sqrt{6}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right)\)
</p>

<p>
\(M^{-1} = M_{r}^{-1}M_{s}^{-1} = \frac{\sqrt{2}}{2} \times \frac{1}{\sqrt{6}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right) = \frac{1}{2\sqrt{3}} \left( \begin{array}{c} \sqrt{3} + 1 & 1 - \sqrt{3} \\ 1 - \sqrt{3} & \sqrt{3} + 1 \end{array} \right)\)
</p>

<p>
所以, 得出 \(\begin{equation*} \begin{cases} a_{2} = d_{2} = \frac{\sqrt{3} + 1}{2\sqrt{3}} = \frac{3 + \sqrt{3}}{6} \\ b_{2} = c_{2} = \frac{1 - \sqrt{3}}{2 \sqrt{3}} = \frac{\sqrt{3} - 3}{6} \end{cases} \end{equation*}\), 对比代码中的 \(\mathrm{(i + j) * G2}\) 可发现 \(-b_2 = \mathrm{G2} = \frac{3 - \sqrt{3}}{6}\),
</p>

<p>
为什么是转负, 因为代码的上下文是这样的:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t</span> = (i + j) * G2;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">X0</span> = i - t;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">Y0</span> = j - t;
</pre>
</div>

<p>
\(i\) 和 \(j\) 是单形中第一个被遍历到的角相对坐标 \((0, 0)\) 的分量, \((\mathrm{X0}, \mathrm{Y0})\) 是该单形角对应的正交网格空间坐标, \((\mathrm{x0}, \mathrm{y0})\) 是单形角正交网格空间中上的角指向, 同时是点在单形中的相对坐标.
</p>

<p>
到了这里就开始进入下一个环节了: 遍历单形角.
</p>

<blockquote>
<p>
<code>Ian McEwan</code> 和 <code>Stefan Gustavson</code> 后来又写了 <code>Tiling Simplex Noise and Flow Noise in Two and Three Dimensons</code>, 里面采用了另一种方便计算的二维单形网格, 不过它的单形并非等边的等腰三角形:
</p>


<div id="orgfbe9832" class="figure">
<p><img src="../../../files/2d-simplex-grid-efficient-choice.png" alt="2d-simplex-grid-efficient-choice.png" width="504px">
</p>
</div>

<p>
这个单形也提高了后续遍历单形角的计算效率.
</p>
</blockquote>
</div>
</li>
<li><a id="org8a0a9a7"></a>遍历单形角并求和贡献值<br>
<div class="outline-text-6" id="text-org8a0a9a7">
<div class="org-src-container">
<pre class="src src-java"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">For the 2D case, the simplex shape is an equilateral triangle.
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Determine which simplex we are in.
</span><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">i1</span>, <span style="color: #eedd82;">j1</span>; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for second (middle) corner of simplex in (i,j) coords
</span><span style="color: #00ffff;">if</span>(x0&gt;y0) {i1=1; j1=0;} <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1)
</span><span style="color: #00ffff;">else</span> {i1=0; j1=1;}
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1)
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">c = (3-sqrt(3))/6
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x1</span> = x0 - i1 + G2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for middle corner in (x,y) unskewed coords
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y1</span> = y0 - j1 + G2;
<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x2</span> = x0 - 1.0 + 2.0 * G2; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Offsets for last corner in (x,y) unskewed coords
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y2</span> = y0 - 1.0 + 2.0 * G2;
</pre>
</div>

<p>
首先是判断点位于哪个单形中, 这里通过点 \(\mathrm{(x0, y0)}\) 在正交网格空间的分量进行判断,
</p>

<p>
如果 \(\mathrm{x0} \gt \mathrm{y0}\) 就是菱形的下三角形, 否则就是上三角形.
</p>

<p>
因为第二个单形角的相对坐标是 \((0, 1)\) 或 \((1, 0)\), 代码中的 \(\mathrm{x1 = x0 - i1 + G2}\) 完整写法是 \(\mathrm{x0 - [i1 - (1 + 0) \times G2]}\),
</p>

<p>
表示第二个单形角在正交网格空间上的角指向 \(x\) 分量, 同理, \(\mathrm{y1}\) 表示对应的 \(y\) 分量.
</p>

<p>
因此, \((\mathrm{x1}, \mathrm{y1})\) 是第二个单形角在正交网格空间上的角指向.
</p>

<p>
第三个单形角的相对坐标是 \((1, 1)\) 代码中的 \(\mathrm{x2 = x0 - 1 + 2 \times G2}\) 完整写法是 \(\mathrm{x2 = x0 - [1 - (1 + 1) \times G2]}\),
</p>

<p>
其中 \(\mathrm{1 - (1 + 1) \times G2}\) 是该单形角的 \(x\) 分量, 所以 \(\mathrm{x2}\) 表示第三个单形角在正交网格空间上的角指向 \(x\) 分量; 同理, \(\mathrm{y2}\) 是对应的 \(y\) 分量.
</p>

<p>
因此, \((\mathrm{x2}, \mathrm{y2})\) 是第三个单形角在正交网格空间上的角指向.
</p>

<p>
在计算出所有角指向后, 可以开始计算每个角的贡献值了, 下面是原文中的参考代码:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Calculate the contribution from the three corners
</span><span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t0</span> = 0.5 - x0*x0-y0*y0;
<span style="color: #00ffff;">if</span>(t0&lt;0) n0 = 0.0;
<span style="color: #00ffff;">else</span> {
    t0 *= t0;
    n0 = t0 * t0 * dot(grad3[gi0], x0, y0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">(x,y) of grad3 used for 2D gradient
</span>}

<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t1</span> = 0.5 - x1*x1-y1*y1;
<span style="color: #00ffff;">if</span>(t1&lt;0) n1 = 0.0;
<span style="color: #00ffff;">else</span> {
    t1 *= t1;
    n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
}

<span style="color: #98fb98;">double</span> <span style="color: #eedd82;">t2</span> = 0.5 - x2*x2-y2*y2;
<span style="color: #00ffff;">if</span>(t2&lt;0) n2 = 0.0;
<span style="color: #00ffff;">else</span> {
    t2 *= t2;
    n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Add contributions from each corner to get the final noise value.
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">The result is scaled to return values in the interval [-1,1].
</span><span style="color: #00ffff;">return</span> 70.0 * (n0 + n1 + n2);
</pre>
</div>

<p>
这里的 \(\mathrm{n0}\) 正式第一个单形角的贡献值, \(\mathrm{t0}\) 的 4 次方是衰减系数.
</p>

<p>
这个衰减系数是用在正交网格空间上的, 正如之前所说的, 衰减函数也代表着一个圆, 它半径为 \(r = \sqrt{0.5}\).
</p>

<p>
这个值是如何得到的呢?
</p>

<p>
首先在单形网格上求得第一个单形角到它对面边的垂直线, 由于单形是等边三角形, 所以垂直线与对面边的交点正好是对面边的中点, 这样可以确定该边上中点的相对坐标为 \((1, \frac{1}{2})\) 或 \((\frac{1}{2}, 1)\).
</p>

<blockquote>
<p>
以下三角形为例, 从第一个单形角开始, 往 \(\vec{u}\) 方向增加一个单位, 往 \(\vec{v}\) 方向增加 \(\frac{1}{2}\) 个单位, 最终到达的角相对坐标为 \((1, \frac{1}{2})\).
</p>

<p>
如果是上三角形, 最终到达的角相对坐标为 \((\frac{1}{2}, 1)\). 不管哪种情况, 都不影响后续的计算.
</p>

<p>
这里以第一个单形角对面边的中点作为例子, 是因为第一个单形角的相对坐标为 \((0, 0)\), 该边中点 \(m_{uv}\) 等于垂直线的向量 \(\vec{m_{uv}} = m_{uv} - (0, 0)\), 垂直线的长度等于 \(|m_{uv}|\).
</p>
</blockquote>

<p>
这里以下三角形为例, 中点为 \(m_{uv} = (1, \frac{1}{2})\), 接下来把他转换到正交网格空间上, 得到点 \(m_{xy}\):
</p>

<p>
\((1 + \frac{1}{2}) \times \mathrm{G2} = \frac{3}{2} \times \frac{3 - \sqrt{3}}{6} = \frac{3 - \sqrt{3}}{4}\)
</p>

<p>
\(m_{xy} = (1 - \frac{3 - \sqrt{3}}{4}, \frac{1}{2} - \frac{3 - \sqrt{3}}{4}) = (\frac{1 + \sqrt{3}}{4}, \frac{\sqrt{3} - 1}{4})\)
</p>

<p>
最后得到它模长的平方: \(|m_{xy}|^2 = (\frac{1}{4})^2 [(\sqrt{3} + 1)^2 + (\sqrt{3} - 1)^2] = \frac{1}{2}\), 正好就是 \(r^2 = 0.5 = \frac{1}{2}\).
</p>

<p>
所以, \(r^2 = 0.5\) 就是单形网格上等边三角形的高在正交网格空间上的长度的平方.
</p>

<p>
\(\mathrm{grad3[gi0]}\) 是从预计算好的梯度表格中获取梯度:
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #98fb98;">int</span> <span style="color: #eedd82;">grad3</span>[][] = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},
                 {1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},
                 {0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};
</pre>
</div>

<p>
原文中的二维单形噪声的梯度是三维向量, 而我们在实现时可以完全参考梯度噪声中的梯度计算生成二维梯度向量:
</p>

<p>
\(\mathrm{dot(grad3[gi0], x0, y0)}\) 就是梯度的 \(xy\) 分量和角指向之间的点积, \(\mathrm{n1}\) 和 \(\mathrm{n2}\) 的贡献值计算同理.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #00ffff;">private</span> <span style="color: #00ffff;">static</span> <span style="color: #98fb98;">double</span> <span style="color: #87cefa;">dot</span>(<span style="color: #98fb98;">int</span> <span style="color: #eedd82;">g</span>[], <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">x</span>, <span style="color: #98fb98;">double</span> <span style="color: #eedd82;">y</span>) {
    <span style="color: #00ffff;">return</span> g[0]*x + g[1]*y;
}
</pre>
</div>

<p>
代码中 \(\mathrm{70 \times (n0 + n1 + n2)}\) 就是单形噪声值, 正如代码的注释所示, \(70\) 是用来把结果归一化成 \([-1, 1]\) 的.
</p>

<p>
为什么是 \(70\), 这需要讨论 \(\mathrm{n0 + n1 + n2}\) 的最大值是多少.
</p>

<p>
\(\sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 \vec{g_{i}}\vec{d_{i}} = \sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 |\vec{g_{i}}||\vec{d_{i}}|\cos\theta\)
</p>

<p>
想让 \(\vec{g_{i}} \cdot \vec{d_{i}}\) 最大, 要满足两个条件:
</p>

<ol class="org-ol">
<li>\(\vec{g_{i}}\) 和 \(\vec{d_{i}}\) 之间的夹角 \(\theta\) 为 0, 换而言之满足这样的关系: \(\vec{g_{i}} = \lambda \vec{d_{i}}\), 其中 \(\lambda \gt 0\);</li>

<li>两者的模长达到各自的最大值. 由于梯度向量 \(\vec{g}\) 是预设的, 所以可以确定它的最大模长为 \(\sqrt{2}\).</li>
</ol>


<p>
假设同时满足这两个条件, 上面的等式可以写成 \(\sqrt{2} \sum\limits_{i=0}^{2} (0.5 - |\vec{d_{i}}|^2)^4 |\vec{d_{i}}|\).
</p>

<p>
分别讨论三种情况: 输入点位于任意单形角, 位于等边三角形中心以及位于任意边中点.
</p>

<blockquote>
<p>
这个问题没法直接用费马点(<code>Fermat point</code>)来解决.
</p>

<p>
所谓费马点是位于三角形内的一个点, 这个点到三个顶点的距离之和比从其它点算起都要小, 每个三角形只有一个费马点.
</p>

<p>
假设三角形的三个顶点分别为 \(A, B, C\), 费马点为 \(P\), 那么距离之和为 \(|\vec{PA}| + |\vec{PB}| + |\vec{PC}|\).
</p>

<p>
因为 \(f(x) = (0.5 - x^2)^4 x\) 不是线性关系, 所以 \(\sqrt{2}[f(|\vec{PA}|) + f(|\vec{PB}|) + f(|\vec{PC}|)] \ne \sqrt{2}f(|\vec{PA}| + |\vec{PB}| + |\vec{PC}|)\).
</p>
</blockquote>


<div id="org933fe06" class="figure">
<p><img src="../../../files/2d-simplex-summation.png" alt="2d-simplex-summation.png" width="504px">
</p>
</div>

<p>
从图中可得知:
</p>

<p>
当点处于其中一个角上, 点与对应角的距离为 0, 其贡献值为 \(\sqrt{2} (0.5 - 0)^4 \times 0 = 0\) 其它两个角的贡献值也同样为 0,
</p>

<p>
所以 \(\mathrm{n0 + n1 + n2} = 0\);
</p>

<p>
当点处于等边三角形的中心, 点到每个角的距离都相等, 中点正好是其高的三等分点, 点到角的距离为 \(\frac{2}{3} \sqrt{\frac{1}{2}} = \frac{\sqrt{2}}{3}\),
</p>

<p>
所以 \(\mathrm{n0 + n1 + n2 = 3 \times \sqrt{2}(0.5 - (\frac{\sqrt{2}}{3})^2)^4 \frac{\sqrt{2}}{3}} = 2 (\frac{5}{18})^4 = \frac{625}{52488} \approx \frac{1}{84}\);
</p>

<p>
当点处于任意边的中点, 点距离每个角的距离分别为 \(\sqrt{\frac{1}{2}}\), \(\sqrt{\frac{1}{6}}\) 以及 \(\sqrt{\frac{1}{6}}\),
</p>

<p>
所以 \(\mathrm{n0 + n1 + n2} = \sqrt{2} [(0.5 - \frac{1}{2})^4 \sqrt{\frac{1}{2}} + (0.5 - \frac{1}{6})^4 \sqrt{\frac{1}{6}} + (0.5 - \frac{1}{6})^4 \sqrt{\frac{1}{6}}] = 2 \sqrt{2} \times \frac{1}{3}^4 \sqrt{\frac{1}{6}} = \frac{2}{81}\sqrt{\frac{1}{3}} \approx \frac{1}{70}\).
</p>

<blockquote>
<p>
这三个距离中, \(\sqrt{\frac{1}{2}}\) 已经在求 \(m_{xy}\) 时得到了, 另外两个可以根据等边三角形和三角函数得到,
</p>

<p>
又或者通过单形网格空间上 \((1, 0)\) 或 \((0, 1)\) 变换到正交网格空间上再进行求模长得出单形的边长, 再除以 2 得到, 这里就不详细说了.
</p>
</blockquote>

<p>
在对比之下发现, 点处于等边三角形边的中心时贡献值最大.
</p>

<p>
然而, 该归一化系数 \(70\) 并不严谨, 目前没找到关于"点处于等边三角形边的中心时贡献值最大"的数学证明, 该结论是通过实验得到的, 后面会提到这个问题.
</p>
</div>
</li>
</ul>
</li>
<li><a id="org35067d2"></a>更高维度的单形噪声<br>
<div class="outline-text-5" id="text-org35067d2">
<p>
从 <code>2D</code> 单噪声的实现中可以看到里面涉及了大量复杂的推导, 那么对于更高维度的单形噪声是不是也要这样呢?
</p>

<p>
可以不用, 因为上面推导结果基本上可以在<a href="https://polytope.miraheze.org/wiki/Simplex">正单形(regular simplex)性质</a>找到.
</p>

<p>
这里只讨论几个东西: \(\mathrm{F2}\) 的高维版本 \(F_N\), \(\mathrm{G2}\) 的高维版本 \(G_N\), 正单形的边长 \(L\), 正单形的高 \(H\), 以及更高维度的归一化系数 \(NF\) 如何得到.
</p>

<p>
在 \(N\) 维空间上:
</p>

<p>
\(F_N = \frac{\sqrt{N + 1} - 1}{N}\)
</p>

<p>
\(G_N = \frac{(N + 1) - \sqrt{N+1}}{N^2 + N} = \frac{1 - \frac{1}{\sqrt{N + 1}}}{N}\);
</p>

<p>
\(L = \frac{N}{\sqrt{N^2 + N}} = \sqrt{\frac{N}{N + 1}}\);
</p>

<blockquote>
<p>
这个公式是从 <a href="../../../files/constructing-a-regular-n-simplex.pdf">Constructing a regular n-simplex</a> 里面得到的.
</p>
</blockquote>

<p>
\(H = \sqrt{\frac{N + 1}{2N}} \cdot L = \sqrt{\frac{N + 1}{2N}} \cdot \sqrt{\frac{N}{N + 1}} = \frac{\sqrt{2}}{2}\);
</p>

<p>
\(NF(d, r, m, n) = \frac{1}{2m(r^2 - d^2)^n}\), 其中:
</p>

<p>
\(d\) 是角指向的模;
</p>

<p>
\(r\) 是衰减函数里的半径, 通常是单形角到对边/面的垂直距离;
</p>

<p>
\(m\) 是梯度向量的最大模, 为 \(\sqrt{N}\);
</p>

<p>
\(n\) 是衰减函数的幂.
</p>

<p>
这里的归一化系数的计算方式是基于这个结论得到的: 当点处于单形中的一条边上的中点时, 贡献值达到最大.
</p>

<p>
目前我没有找到该支撑该结论的数学证明, 该结论是<a href="http://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36">Sharpe 通过实验得到的 (在评论区里面)</a>得到的.
</p>

<p>
需要注意是, <code>Sharpe</code> 计算方式和这里的有些出入, 这里的考虑上了梯度向量的模长不为 1.
</p>

<p>
还有, 不管用 <code>Sharpe</code> 的还是说这里的计算方式, 高维 \(NF\) 的计算结果与 <code>Simplex Noise Demystified</code> 的有出入, 考虑到原文中就有不少错误, 因此这里我决定相信 <code>Sharpe</code>.
</p>

<p>
这里附上 \(S_N\) 的 <code>Maxima</code> 实现:
</p>

<div class="org-src-container">
<pre class="src src-maxima">NF(x, r, m, n) <span style="color: #00ffff;">:=</span> <span style="color: #7fffd4;">1</span> <span style="color: #00ffff;">/</span> ((r<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span> <span style="color: #00ffff;">-</span> x<span style="color: #00ffff;">^</span><span style="color: #7fffd4;">2</span>)<span style="color: #00ffff;">^</span>n <span style="color: #00ffff;">*</span> x <span style="color: #00ffff;">*</span> m <span style="color: #00ffff;">*</span> <span style="color: #7fffd4;">2</span><span style="color: #00ffff;">.</span><span style="color: #7fffd4;">0</span>);
</pre>
</div>

<p>
另外, 为了防止链接失效, 这里还是备份一下评论的内容:
</p>

<blockquote>
<p>
The way to work out the normalization factor is to think of what the maximum possible value would be generated if given the right conditions. So this would be by taking some sample within the simplex triangle, while having all gradient vectors pointing at that sample. To generate the maximum value it turns out that this sample is halfway along any one of the triangle edges. ( so this means the equal combination of two surflets )
</p>

<p>
In 2D, half the edge length of a simplex triangle is…
</p>

<p>
x = ( sqrt( 0.5 )/sqrt( 0.75 ) ) * 0.5
</p>

<p>
So our 2D normalization factor becomes…
</p>

<p>
2DNF = 1.0 / ( x * ( ( 0.5 – x*x ) ^ 4 ) * 2.0 ) = ~99.2043345….
</p>

<p>
In 3D, half the edge length of a simplex tetrahedron is…
</p>

<p>
x = sqrt( 0.75 ) * 0.5
</p>

<p>
So our 3D normalization factor becomes…
</p>

<p>
3DNF = 1.0 / ( x * ( ( 0.5 – x*x ) ^ 3 ) * 2.0 ) = ~37.8372272…..
</p>

<p>
Something to note: 2D simplex triangles ( as generated by perlins skew/unskew method ) are equilateral. But the 3D simplex tetrahedrons are NOT. They’re slightly skewed…. So the 3D math I’m using here starts to deviate ever so slightly from the actual results. But because it is so minor and to keep math simplicity+sanity, I’ve chosen to ignore this issue.
</p>
</blockquote>

<p>
(PS: 归一化系数应该是单形噪声中最不严谨的部分了, 在网上找了好几天的相关解释, 发现每个实现的 \(NF\) 都不一样, 着实心累, 考虑到实现中用上近似了, 就不太纠结准确性了.)
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org91c5f46" class="outline-4">
<h4 id="org91c5f46">细胞噪声</h4>
<div class="outline-text-4" id="text-org91c5f46">
<blockquote>
<p>
施工中
</p>
</blockquote>

<p>
细胞噪声 (<code>Cellular Noie</code>) 还有其它叫法: 沃洛诺伊噪声 (<code>Voronoi Noise</code>), 威利噪声 (<code>Worley Noise</code>).
</p>

<p>
<a href="https://www.youtube.com/watch?v=vcfIJ5Uu6Qw&amp;ab_channel=SuboptimalEngineer">https://www.youtube.com/watch?v=vcfIJ5Uu6Qw&amp;ab_channel=SuboptimalEngineer</a>
</p>

<p>
<a href="https://www.shadertoy.com/view/llsGWl">https://www.shadertoy.com/view/llsGWl</a>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org19b4108" class="outline-2">
<h2 id="org19b4108">SDF</h2>
<div class="outline-text-2" id="text-org19b4108">
<blockquote>
<p>
施工中
</p>
</blockquote>

<p>
全称符号距离函数(<code>Signed Distance Function</code>) 或符号距离场(<code>Signed Distance Field</code>), 这里用函数 \(f\) 表示.
</p>

<p>
\(f\) 用来计算点 \(p\) 到几何体 \(G\) 的正交距离(<code>orthogonal distance</code>), 也就是找到点到几何体的垂线,
</p>

<p>
再计算垂线的长度 \(l\), \(l\) 就是正交距离, 并且通过正负号来表示 \(p\) 是否位于 \(G\) 内.
</p>

<p>
\(G\) 可以看作是集合 \(P\) 的子集: \(G \subset P\), 包含了几何体上所有的点, \(\partial G\) 则是几何体的边界集合, \(\partial G \subset G\),
</p>

<p>
\(P\) 拥有一个函数 \(d(p_1, p_2) \ge 0\) 可用于计算任意 \(p_1 \in P\) 和 \(p_2 \in P\) 之间的距离,
</p>

<p>
\(P\) 和 \(d\) 的有序对 (<code>ordered pair</code>): \((P, d)\) 形成一个度量空间(<code>metric space</code>).
</p>

<p>
\(G\) 的 <code>SDF</code> 的定义为 \(f(p) = \begin{cases} d(p, \partial G) & \text{if } p \in G \\ -d(p, \partial G) & \text{if } p \notin G \end{cases}\).
</p>

<p>
如果 \(f(p) > 0\), 那么 \(p\) 在 \(G\) 内; 如果 \(f(p) = 0\), 那么 \(p\) 正好位于 \(G\) 的边界上; 如果 \(f(p) < 0\), 那么 \(p\) 在 \(G\) 外.
</p>

<p>
定义 \(f\) 的关键在于掌握点和几何体之间的<a href="https://en.wikipedia.org/wiki/Perpendicular_distance">正交距离</a>计算, 需要形成一套通用方法.
</p>
</div>
<div id="outline-container-orgde7d658" class="outline-3">
<h3 id="orgde7d658">估算点与几何解析式的距离</h3>
<div class="outline-text-3" id="text-orgde7d658">
<blockquote>
<p>
这部分内容是对 <code>Inigo Quilez</code> 的 <a href="https://iquilezles.org/articles/distance/">Approximating the distance to implicits</a> 的文章进行总结和补充, 原文有些地方对于我来说过于简洁了.
</p>

<p>
其实 <code>Inigo Quilez</code> 很多文章都要求读者有着扎实的数学基础的, 特别是微积分, 线性代数和概率论, 满足条件了的话, 他的文章就是一个优秀的图形学学习资源.
</p>
</blockquote>

<p>
试想一下, 现在想计算点 \(p\) 和 \(s = g(P = (x, y, \dots))\) 的距离, 具体应该怎么求呢?
</p>

<p>
通常判断一个点是否在一个函数上都会通过该函数的隐函数的值来进行判断的,
</p>

<p>
比如这里可以把 \(g\) 改写成隐函数 \(f(P, s) = g(P) - s\), 如果 \(p\) 在函数 \(g\) 上, 那么 \(f(p, s=g(p)) = 0\),
</p>

<p>
为了方便说明, 这假设 \(s\) 是一个固定值来得到一个确定的曲线/表面, 因此, 接下来看到的 \(f(P)\) 就等同于 \(f(P, s)\).
</p>

<p>
那么是不是可以用 \(f(p)\) 来表示 \(p\) 和 \(g\) 之间的距离呢? 答案是不能.
</p>

<p>
从几何角度来看, 点到函数 \(g\) 的距离是从 \(g\) 上找出距离 \(p\) 最短的点 \(p_0\), 那么 \(|p_0 - p|\) 就是 \(p\) 和函数 \(g\) 的距离.
</p>

<p>
最短意味着 \(\vec{\varepsilon} = p_0 - p\) 与点 \(p\) 上的切线/切平面垂直,
</p>

<p>
对于二元标量值函数而言, 点上的梯度向量正好也与该点上的切线/切平面垂直, 可以看作是切线/切平面上的法线.
</p>

<p>
在实际运算中不可能找出 \(p_0\) 的, 因为通常来说函数 \(g\) 都是连续且可微的, 在该函数上有无数种取点可能, 所以穷举法取点是无法处理的.
</p>

<p>
可以转换一下角度, 把问题转化成求两个等值表面/等值线之间的距离, 这就是为什么我们需要隐函数了.
</p>

<p>
来观察一下点与表面的关系:
</p>

<p>
\(p_0\) 在等值表面/等值线 \(f(P) = 0\) 上: \(f(p_0) = f(p + \vec{\varepsilon}) = 0\), \(p\) 则是在某一个等值表面/等值线 \(f(P) = c\) 上, 其中 \(c\) 为常数.
</p>

<p>
\(f(P) = 0\) 与 \(f(P) = c\) 两个等值表面/等值线之间的差异 \(c\) 可以在线性逼近(或一阶泰勒展开)的结果中找到,
</p>

<p>
对 \(f(p_0) = f(p + \vec{\varepsilon})\) 进行线性逼近得到 \(f(p + \vec{\varepsilon}) \approx f(p) + \nabla f(p) \cdot \vec{\varepsilon}\), 其中 \(c = \nabla f(p) \cdot \vec{\varepsilon}\), 也就是 \(\vec{\varepsilon}\) 在梯度向量方向上的投影.
</p>

<blockquote>
<p>
因为这里只进行了一阶泰勒展开, 所以最终所得的距离是不准确的, 这也是为什么标题是估算是而不是计算.
</p>

<p>
后面会给出一个例子来更好地印证这个事实.
</p>
</blockquote>


<div id="org9a42157" class="figure">
<p><img src="../../../files/isocurve-distance.png" alt="isocurve-distance.png">
</p>
<p><span class="figure-number">Figure 25: </span>等值线之间的距离</p>
</div>

<p>
但 \(c\) 并非我们想要的, 想要的是 \(p\) 和 \(p_0\) 之间的距离: \(|\vec{\varepsilon}|\), 为此需要找到求解 \(\vec{\varepsilon}\) 的方法.
</p>

<blockquote>
<p>
三角不等式(<code>triangle inequality</code>): \(|a + b| \le |a| + |b|\).
</p>

<p>
如果 \(a\) 和 \(b\) 满足 \(\frac{a}{b} \gt 0\) (同时为正或同时为负) 或者 \(a = b = 0\), 那么 \(|a + b| = |a| + |b|\);
</p>

<p>
如果满足 \(\frac{a}{b} \lt 0\), 那么 \(|a + b| \lt |a| + |b|\).
</p>
</blockquote>

<p>
根据三角不等式 \(|a + b| \le |a| + |b|\), \(a\) 和 \(b\) 可以是任何实数, 为了方便找到 \(\vec{\varepsilon}\) 的范围,
</p>

<p>
这里假设 \(\begin{cases} a = s + t \\ b = -t \\ a + b = s \end{cases}\), 可以推导出该不等式: \(\begin{equation*} \begin{aligned} |s| \le |s + t| + |t| \Rightarrow |s| - |t| \le |s + t| \end{aligned} \end{equation*}\),
</p>

<p>
接下来分两种假设: \(\begin{cases} s = f(p) \\ t = \nabla f(p) \cdot \vec{\varepsilon} \end{cases}\) 和 \(\begin{cases} s = \nabla f(p) \cdot \vec{\varepsilon} \\ t = f(p) \end{cases}\).
</p>

<p>
<b>在第一种假设下,</b> 可以得到 \(|f(p)| - |\nabla f(p) \cdot \vec{\varepsilon}| \le |f(p) + \nabla f(p) \cdot \vec{\varepsilon}|\),
</p>

<p>
因为 \(|f(p) + \nabla f(p) \cdot \vec{\varepsilon}| = 0\), 所以 \(|f(p)| \le |\nabla f(p) \cdot \vec{\varepsilon}|\),
</p>

<p>
根据点积的定义 \(\vec{u} \vec{v} = |\vec{u}||\vec{v}| \cos\theta_{uv}\), 其中夹角 \(\theta_{uv} \in [0, \pi]\), 所以 \(\cos\theta_{uv} \in [-1, 1]\), 可得出 \(|\nabla f(p) \cdot \vec{\varepsilon}| \le |\nabla f(p)||\vec{\varepsilon}|\),
</p>

<p>
所以 \(|f(p)| \le |\nabla f(p)||\vec{\varepsilon}| \Rightarrow \frac{|f(p)|}{|\nabla f(p)|} \le |\vec{\varepsilon}|\).
</p>

<p>
<b>在第二种假设下,</b> 可以得到 \(|\nabla f(p) \cdot \vec{\varepsilon}| - |f(p)| \le |f(p) + \nabla f(p) \cdot \vec{\varepsilon}|\);
</p>

<p>
因为 \(|f(p) + \nabla f(p) \cdot \vec{\varepsilon}| = 0\), 所以 \(|\nabla f(p) \cdot \vec{\varepsilon}| \le |f(p)|\),
</p>

<p>
根据点积的定义, 可得出 \(|\vec{\varepsilon}| \le \frac{|f(p)|}{|\nabla f(p)|}\).
</p>

<p>
第一种假设只能讨论得到 \(|\vec{\varepsilon}|\) 的下界, 第二种假设则只能讨论得到 \(|\vec{\varepsilon}|\) 的上界,
</p>

<p>
不管是哪种假设, 现在可以得到估算 \(\vec{\varepsilon}\) 的方法: \(|\vec{\varepsilon}| = \frac{|f(p)|}{|\nabla f(p)|}\).
</p>

<p>
另外一种求导数(梯度向量)近似值方法叫做<a id="org72bb5bb"></a>中心差商法(<code>central difference method</code>), 这种方法不需要我们求出函数的导数解析式.
</p>

<p>
它来源于导数的定义: \(f^{'}(x) = \lim\limits_{h \to 0} \frac{f(x + h) - f(x)}{h} \rightarrow \lim\limits_{h \to 0} \frac{f(x + \frac{h}{2}) - f(x - \frac{h}{2})}{h}\), 对 \(h\) 任取一个很小的值即可: \(f^{'}(x) \approx \frac{f(x + \frac{h}{2}) - f(x - \frac{h}{2})}{h}\).
</p>

<p>
如果函数 \(y = f(x)\) 是一元标量值函数, 那么要先把它转成隐函数 \(F(x, y) = f(x) - y = 0\), 因为一元标量值函数的导数是斜率, 而不是梯度向量.
</p>

<p>
所以使用中心差商法计算梯度向量的方法如下:
</p>

<p>
\(\begin{equation*} \begin{aligned} & \nabla f(x, y, \dots) \\ = & (\frac{f(x + \frac{h}{2}, y) - f(x - \frac{h}{2}, y)}{h}, \frac{f(x, y + \frac{h}{2}) - f(x, y - \frac{h}{2})}{h}, \dots) \\ = & \frac{1}{h} (f(x + \frac{h}{2}, y) - f(x - \frac{h}{2}, y), f(x, y + \frac{h}{2}) - f(x, y - \frac{h}{2}), \dots) \end{aligned} \end{equation*}\)
</p>

<p>
以下是它的 <code>GLSL</code> 实现:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> grad( <span style="color: #98fb98;">vec2</span> v ) {
  <span style="color: #98fb98;">vec2</span> h = <span style="color: #98fb98;">vec2</span>( 0.01, 0.0 );
  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">vec2</span>( f(v + h.xy) - f(v - h.xy), f(v + h.yx) - f(v - h.yx) ) / (2.0 * h.x);
}
</pre>
</div>

<p>
其实在 <a href="#org4fe9c50">The Book Of Shaders 的 smoothstep 函数绘制 Shader 解析</a> 就已经运用到中心差商法了, 只不过并没有除以 \(h\) 把导数算出来, 直接用的 \(df(x)\).
</p>

<p>
此外, 中心差商法还有另一个用处: 快速估算几何解析式 \(f\) 在点 \(v\) 上的法线向量, 以下是其 <code>GLSL</code> 实现:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec2</span> calcNormal( <span style="color: #98fb98;">vec2</span> v ) {
  <span style="color: #98fb98;">vec2</span> h = <span style="color: #98fb98;">vec2</span>( 0.01, 0.0 );
  <span style="color: #98fb98;">vec2</span> n = <span style="color: #98fb98;">vec2</span>( f(v + h.xy) - f(v - h.xy), f(v + h.yx) - f(v - h.yx) );
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">normalize</span>(n);
}
</pre>
</div>
</div>
<div id="outline-container-org9decf7f" class="outline-4">
<h4 id="org9decf7f">案例一: 估算点与曲线之间的距离</h4>
<div class="outline-text-4" id="text-org9decf7f">
<p>
\(f(r, a) = r - 1 + \frac{\sin(3a + 2r^2)}{2}\), 其中 \(\begin{cases} r = \sqrt{x^2 + y^2} \\ a = \mathrm{atan}(\frac{y}{x}) \end{cases}\).
</p>

<p>
\(\nabla f(r, a) = (\frac{\partial f(r, a)}{\partial r}, \frac{\partial f(r, a)}{\partial a})\), 其中 \(\begin{cases} \frac{\partial f(r, a)}{\partial r} = 1 + 2r \cdot \cos(3a + 2r^2) \\ \frac{\partial f(r, a)}{\partial a} = \frac{3}{2} \cdot \cos(3a + 2r^2)\end{cases}\).
</p>

<p>
在 \(\nabla f(r, a)\) 的基础上, 使用多元函数的链式法则可以求出 \(\nabla f(x, y) = (\frac{\partial f(x, y)}{\partial x}, \frac{\partial f(x, y)}{\partial y})\).
</p>

<p>
先分别求出 \(r\) 和 \(a\) 的偏导数:
</p>

<p>
\(\begin{cases} \frac{\partial r}{\partial x} = x(x^2 + y^2)^{-\frac{1}{2}} = \frac{x}{r} \\ \frac{\partial r}{\partial y} = y(x^2 + y^2)^{-\frac{1}{2}} = \frac{y}{r} \\ \frac{\partial a}{\partial x} = -\frac{y}{x^2 + y^2} = -\frac{y}{r^2} \\ \frac{\partial a}{\partial y} = \frac{x}{x^2 + y^2} = \frac{x}{r^2} \end{cases}\)
</p>

<p>
最后使用链式法则:
</p>

<p>
\(\begin{cases} \frac{\partial f(x, y)}{\partial x} = \frac{\partial f(r, a)}{\partial r} \frac{\partial r}{\partial x} + \frac{\partial f(r, a)}{\partial a} \frac{\partial a}{\partial x} = \nabla f(r, a) \cdot (\frac{\partial r}{\partial x}, \frac{\partial a}{\partial x}) = \frac{x}{r} + 2x \cdot \cos(3a + 2r^2) - \frac{3}{2} \cdot \frac{y}{r^2} \cdot \cos(3a + 2r^2) \\ \frac{\partial f(x, y)}{\partial y} = \frac{\partial f(r, a)}{\partial r} \frac{\partial r}{\partial y} + \frac{\partial f(r, a)}{\partial a} \frac{\partial a}{\partial y} = \nabla f(r, a) \cdot (\frac{\partial r}{\partial y}, \frac{\partial a}{\partial y}) = \frac{y}{r} + 2y \cdot \cos(3a + 2r^2) + \frac{3}{2} \cdot \frac{x}{r^2} \cdot \cos(3a + 2r^2) \end{cases}\)
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f( <span style="color: #98fb98;">vec2</span> x ) {
    <span style="color: #98fb98;">float</span> r = <span style="color: #b0c4de;">length</span>(x);
    <span style="color: #98fb98;">float</span> a = <span style="color: #b0c4de;">atan</span>(x.y, x.x);
    <span style="color: #00ffff;">return</span> r - 1.0 + 0.5 * <span style="color: #b0c4de;">sin</span>(3.0 * a + 2.0 * r * r);
}

<span style="color: #98fb98;">vec2</span> grad( <span style="color: #98fb98;">vec2</span> x ) {
    <span style="color: #98fb98;">float</span> r = <span style="color: #b0c4de;">length</span>(x);
    <span style="color: #98fb98;">float</span> a = <span style="color: #b0c4de;">atan</span>(x.y, x.x);
    <span style="color: #98fb98;">vec2</span> da = <span style="color: #98fb98;">vec2</span>(-x.y, x.x) / (r * r);
    <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#21407;&#25991;&#26159;: vec2 da = vec2(x.y, -x.x) / (r * r), &#20272;&#35745;&#26159;&#20351;&#29992;&#20102;&#26059;&#36716; 90 &#24230;&#30340;&#22352;&#26631;&#31995;.
</span><span style="color: #ff7f24;">     */</span>
    <span style="color: #00ffff;">return</span> (x / r) + (1.5 * da + 2.0 * x) * <span style="color: #b0c4de;">cos</span>(3.0 * a + 2.0 * r * r);
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  uv *= 2.0;
  <span style="color: #98fb98;">float</span> v = f(uv);
  <span style="color: #98fb98;">vec2</span> g = grad(uv);
  <span style="color: #98fb98;">float</span> de = <span style="color: #b0c4de;">abs</span>(v) / <span style="color: #b0c4de;">length</span>(g);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">float de = v / length(g); v &#30340;&#31526;&#21495;&#21487;&#20197;&#29992;&#26469;&#21028;&#26029;&#28857;&#22312;&#22270;&#24418;&#20869;&#36824;&#26159;&#22270;&#24418;&#22806;, &#21435;&#25481; abs &#21487;&#20197;&#24471;&#21040;&#19968;&#20010;&#23454;&#24515;&#22270;&#24418;
</span>  <span style="color: #98fb98;">float</span> lw = 1.0 / 32.0;        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32447;&#31895;, &#20934;&#30830;&#26469;&#35828;&#26159;&#32447;&#31895;&#21344;&#20998;&#36776;&#29575;&#30340;&#30334;&#20998;&#27604;, &#22914;&#26524;&#24819;&#30830;&#23450;&#21040;&#20687;&#32032;: float lw = 1.0 / iResolution.x;
</span>  <span style="color: #98fb98;">float</span> c = <span style="color: #b0c4de;">smoothstep</span>(0.0, lw, de);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(c), 1.0);
}
</pre>
</div>

<p>
接下来估算点与圆之间的距离, 这个例子是为了更好地说明: 这种方法对于计算点与曲线/曲面之间的距离是不准确的.
</p>

<p>
假设现在一个半径为 0.5 的圆的隐函数: \(g(x, y) = x^2 + y^2 - (0.5)^2\).
</p>

<p>
它的梯度向量为 \(\nabla g(x, y) = (\frac{\partial g(x, y)}{\partial x}, \frac{\partial g(x, y)}{\partial y}) = (2x, 2y)\).
</p>

<p>
现在想估算点 \((0, 0.6)\) 到该圆的距离, 这个距离其实一眼就能看出来是 0.1, 最后估算出来的距离为 \(\frac{|g(0, 0.6)|}{|\nabla g(0, 0.6)|} = 0.25\).
</p>

<p>
遇到这种典型的几何解析式, 请根据它们特有的性质来计算距离.
</p>

<p>
比如这里的圆, 计算 \((0, 0.6)\) 到圆心的距离 \(d\) , 再用 \(d\) 减去圆的半径 \(0.5\) 得到点到圆的距离.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f( <span style="color: #98fb98;">vec2</span> x ) {
    <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">dot</span>(x, x) - 0.25;
}

<span style="color: #98fb98;">vec2</span> grad( <span style="color: #98fb98;">vec2</span> x ) {
  <span style="color: #00ffff;">return</span> 2.0 * x;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">float</span> v = f(uv);
  <span style="color: #98fb98;">vec2</span> g = grad(uv);
  <span style="color: #98fb98;">float</span> de = <span style="color: #b0c4de;">abs</span>(v) / <span style="color: #b0c4de;">length</span>(g);
  <span style="color: #98fb98;">float</span> lw = 1.0 / 32.0;        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32447;&#31895;
</span>  <span style="color: #98fb98;">float</span> c = <span style="color: #b0c4de;">smoothstep</span>(0.0, lw, de);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(c), 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org046c655" class="outline-4">
<h4 id="org046c655">案例二: 估算点与直线之间的距离</h4>
<div class="outline-text-4" id="text-org046c655">
<p>
对于任意线性函数 \(f(x) = kx + b\), 它的切向量为 \((1, f^{'}(x))\),
</p>

<p>
要求它的梯度向量, 需要先把它转换成隐函数 \(F(x, y) = kx + b - f(x) = 0\),
</p>

<p>
然后梯度向量为 \(\nabla F(x, y) = (\frac{\partial F(x, y)}{\partial x}, \frac{\partial F(x, y)}{\partial y}) = (f^{'}(x) = k, -1)\).
</p>

<p>
根据线性函数的特性: \(f(a) + f(b) = f(a + b)\), 估算的结果必定是准确的.
</p>

<p>
假设现在有一条直线的隐函数: \(g(x, y) = 3x + 0.1 - y\), 它的梯度向量为 \(\nabla g(x, y) = (\frac{\partial g(x, y)}{\partial x}, \frac{\partial g(x, y)}{\partial y}) = (3, -1)\).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f( <span style="color: #98fb98;">vec2</span> x ) {
  <span style="color: #00ffff;">return</span> 3.0 * x.x + 0.1 - x.y;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">float</span> v = f(uv);
  <span style="color: #98fb98;">vec2</span> g = <span style="color: #98fb98;">vec2</span>(3.0, -1.0);
  <span style="color: #98fb98;">float</span> de = <span style="color: #b0c4de;">abs</span>(v) / <span style="color: #b0c4de;">length</span>(g);
  <span style="color: #98fb98;">float</span> lw = 1.0 / 32.0;        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32447;&#31895;
</span>  <span style="color: #98fb98;">float</span> c = <span style="color: #b0c4de;">smoothstep</span>(0.0, lw, de);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(c), 1.0);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org3223fb2" class="outline-4">
<h4 id="org3223fb2">初识 SDF</h4>
<div class="outline-text-4" id="text-org3223fb2">
<p>
我们可以把解析式封装成一个返回正交距离的函数, 这个函数就是 <code>SDF</code>.
</p>

<p>
以下是解析式的 <code>SDF</code> 的基本形式.
</p>

<p>
<code>2D SDF</code>:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f2D (<span style="color: #98fb98;">vec2</span> x) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">...</span><span style="color: #ff7f24;"> */</span> }             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35299;&#26512;&#24335;&#21407;&#20989;&#25968;
</span>
<span style="color: #98fb98;">vec2</span> grad2D (<span style="color: #98fb98;">vec2</span> x) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">...</span><span style="color: #ff7f24;"> */</span> }           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35299;&#26512;&#24335;&#30340;&#23548;&#25968;
</span>
<span style="color: #98fb98;">float</span> sdf2D (<span style="color: #98fb98;">vec2</span> p) {                       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">SDF
</span>  <span style="color: #98fb98;">float</span> v = f2D(x);
  <span style="color: #98fb98;">float</span> g = grad2D(x);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">abs</span>(v) / <span style="color: #b0c4de;">length</span>(g);
}
</pre>
</div>

<p>
<code>3D SDF</code>:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> f3D (<span style="color: #98fb98;">vec3</span> x) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">...</span><span style="color: #ff7f24;"> */</span> }             <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35299;&#26512;&#24335;&#21407;&#20989;&#25968;
</span>
<span style="color: #98fb98;">vec3</span> grad3D (<span style="color: #98fb98;">vec3</span> x) { <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">...</span><span style="color: #ff7f24;"> */</span> }           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35299;&#26512;&#24335;&#30340;&#23548;&#25968;
</span>
<span style="color: #98fb98;">float</span> sdf3D (<span style="color: #98fb98;">vec3</span> p) {                       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">SDF
</span>  <span style="color: #98fb98;">float</span> v = f3D(x);
  <span style="color: #98fb98;">float</span> g = grad3D(x);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">abs</span>(v) / <span style="color: #b0c4de;">length</span>(g);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1bf9685" class="outline-4">
<h4 id="org1bf9685"><a id="org0cafc34"></a> 对 SDF 描述的图形进行变换</h4>
<div class="outline-text-4" id="text-org1bf9685">
<p>
在定义 <code>SDF</code> 时应该默认图形是基于原点进行定义的, 这样做的好处是:
</p>

<p>
一是可在无记忆负担的情况下保证所有的 <code>SDF</code> 在坐标系上的一致, 这也是很多图形软件的做法;
</p>

<p>
二是可在不触碰 <code>SDF</code> 定义的情况下对图形进行变换, 只需在传入参数时对点 \(p\) 进行变换即可.
</p>

<p>
就像下面的代码:
</p>

<div class="org-src-container">
<pre class="src src-glsl">
<span style="color: #98fb98;">void</span> main() {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>  <span style="color: #98fb98;">vec2</span> p = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">mat3</span> trans = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    -0.3, -0.3, 1.0);
  <span style="color: #98fb98;">float</span> v = trans * <span style="color: #98fb98;">vec3</span>(<span style="color: #98fb98;">vec2</span>(p), 1.0);
  <span style="color: #98fb98;">float</span> d = sdf2D(v.xy);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...
</span>}

</pre>
</div>

<p>
这里面把 <code>sdf2D</code> 所描述的图形往右平移 \(0.3\) 个单位, 往上平移 \(0.3\) 个单位.
</p>

<p>
关于变换相关的内容, 可以参考我的另外一篇笔记: <a href="../../2020/06/graphics-geometric-transformation.html">图形学 - 几何变换</a>.
</p>

<p>
但看过笔记后你会发现上面的 <code>trans</code> 实际上是一个相反的平移, 所以直接把笔记中的变换应用到 <code>SDF</code> 上会产生相反的效果.
</p>

<p>
这因为上面代码的不是对线段的端点进行变换, 而是对 \(p\) 点进行平移, 所以你可能认为图像的平移为 \((-0.3, -0.3)\), 实际上是 \((0.3, 0.3)\).
</p>

<p>
\(p\) 点往左边平移 \(0.3\) 个单位, 往下平移 \(0.3\) 个单位才显得 <code>SDF</code> 往反方向平移. 这个问题可以这么思考:
</p>

<p>
把所有图像看作是在三维空间上的一个平面, 比如 \(xy\) 平面, 而图像的上方有一个位于 \(O = (0, 0, 0)\) 的 "相机"(我们的双眼)往方向 \((0, 0, 1)\) 观察着图像,
</p>

<p>
\(p - O\) 是"相机"发出的视线射线, 所以 \(p - O\) 是视点坐标系上的, 对 \(p\) 进行变换相当于对"相机"进行变换, 而对"相机"进行变换与物体变换是相反的,
</p>

<p>
这个规律在我的 <a href="../../2020/06/graphics-opengl-transformation.html#from-world-to-view">图形学-OpenGL坐标变换</a> 有提到, 在后面的 <code>3D SDF</code> 中的 <a href="#ray-marching">Ray Marching</a> 可以更好地体会到这一点.
</p>

<p>
比如说, 想让镜头中的物体就往右偏, 那么"相机"得往左移; 如果想让镜头中的物体就往右转, 那么"相机"应该往左转.
</p>

<p>
所以, 在对 <code>SDF</code> 的变换时, 先根据物体变换写下矩阵 \(M = M_1 \times M_0\), 再对 \(M\) 求逆 \(M^{-1} = M_0^{-1} \times M_1^{-1}\) 并 \(M^{-1}\) 应用到点 \(p\) 上: \(M^{-1}p\).
</p>
</div>
</div>
<div id="outline-container-org65fb9b1" class="outline-4">
<h4 id="org65fb9b1">图形组合 - 布尔操作符 (boolean operators)</h4>
<div class="outline-text-4" id="text-org65fb9b1">
</div>
<ul class="org-ul">
<li><a id="org49a0ece"></a>并集 (Union)<br></li>
<li><a id="org8469189"></a>交集 (Intersection)<br></li>
<li><a id="org0e7abbf"></a>差集 (Subtraction)<br></li>
<li><a id="orgafd52ad"></a>异或 (XOR)<br></li>
<li><a id="org216f9fa"></a>平滑并集 (Smooth Union)<br></li>
<li><a id="orgc1643c7"></a>平滑交集 (Smooth Intersection)<br></li>
<li><a id="orgcc49a2d"></a>平滑差集 (Smooth Subtraction)<br></li>
</ul>
</div>
</div>
<div id="outline-container-orgddc17a2" class="outline-3">
<h3 id="orgddc17a2">2D SDF</h3>
<div class="outline-text-3" id="text-orgddc17a2">
<p>
前面估算点与隐函数距离的方法, 除了结果不太准确以外, 只要能找到几何的隐函数, 基本上都可以用这种方法定义出该几何的 <code>SDF</code>,
</p>

<p>
最终得到的图形除了大小与想象中的有些误差意外, 形状是没有问题的, 比如上面案例一里面的圆形.
</p>

<p>
当然如果想精确计算一些典型几何的距离, 那么还是得特殊情况特殊处理.
</p>

<p>
下面的内容是对 <code>Inigo Quilez</code> 的 <a href="https://iquilezles.org/articles/distfunctions2d/">2D SDFs</a> 的代码进行理解,
</p>

<p>
里面的代码很多都是几个步骤合成一句的, 光看代码很难理解其中的思路, 所以才写笔记对其中的思路进行整理.
</p>
</div>
<div id="outline-container-orgfb905a7" class="outline-4">
<h4 id="orgfb905a7">计算点与线段之间的距离</h4>
<div class="outline-text-4" id="text-orgfb905a7">
<p>
计算点 \(p\) 与端点为 \(a\) 和 \(b\) 的线段之间的距离.
</p>

<p>
有两种情况:
</p>

<p>
如果 \(\vec{ap}\) 的投影 \(\vec{ao}\) 不在在线段 \(ab\) 上, 那么 \(p\) 和 \(ab\) 之间的距离是 \(|\vec{ap}|\);
</p>


<div id="orge0291cf" class="figure">
<p><img src="../../../files/segment-sdf.png" alt="segment-sdf.png">
</p>
</div>

<p>
如果 \(\vec{ap}\) 的投影 \(\vec{ao}\) 正好在线段 \(ab\) 上, 那么 \(p\) 和 \(ab\) 之间的距离是 \(|\vec{op}|\).
</p>


<div id="org6455ca1" class="figure">
<p><img src="../../../files/segment-sdf-2.png" alt="segment-sdf-2.png">
</p>
</div>

<p>
我们可以通过 \(\vec{ap} \cdot \vec{ab} = |\vec{ap}||\vec{ab}|\cos\theta\) 来判断, 两个向量之间的夹角 \(\theta\) 范围是 \([0, 180^{\circ}]\),
</p>

<p>
当 \(90^{\circ} \lt \theta \le 180^{\circ}\) 时, 投影 \(\vec{ao}\) 不在线段上, 所以 \(\vec{ap}\) 在线段 \(ab\) 上的投影长度为 0;
</p>

<p>
当 \(0 \le \theta \lt 90^{\circ}\) 时, 投影 \(\vec{ao}\) 处于线段上, 并且 \(\vec{ao}\) 的长度最多为 \(ab\) 的长度, 不能超过 \(ab\).
</p>

<p>
当 \(\theta = 90^{\circ}\) 时, \(\vec{ap}\) 在 \(\vec{ab}\) 上的投影长度为 0, 所以在线段上不占任何长度.
</p>

<p>
<b>从这里会把投影 \(|\vec{ao}|\) 定义为在线段 \(ab\) 上的长度</b>, 也就是 \(|\vec{ao}(\theta)| = \begin{cases} \frac{|\vec{ao}|}{|\vec{ab}|} & \text{ if } 0 \le \theta \lt 90^{\circ} \\ 0 & \text{ if } 90^{\circ} \le \theta \le 180^{\circ} \end{cases}\),
</p>

<p>
为此不要把它看作是直线上的投影, 直线和线段是两种概念.
</p>

<p>
不管 \(\theta\) 在什么范围, 都要先计算出 \(|\vec{ao}|\) 以及 \(\frac{|\vec{ao}|}{|\vec{ab}|}\) 才能计算出 \(\vec{op}\).
</p>

<p>
根据三角函数: \(\cos\theta = \frac{|\vec{ao}|}{|\vec{ap}|}\), 所以 \(|\vec{ao}| = |\vec{ap}|\cos\theta\).
</p>

<p>
根据已知条件, 计算出 \(\frac{|\vec{ao}|}{|\vec{ab}|}\) 的最简单方法是 \(\frac{|\vec{ao}|}{|\vec{ab}|} = \frac{\vec{ap} \cdot \vec{ab}}{\vec{ab} \cdot \vec{ab}} = \frac{|\vec{ap}||\vec{ab}|\cos\theta}{|\vec{ab}||\vec{ab}|}\).
</p>

<p>
而 \(\vec{ao}\) 和 \(\vec{op}\) 是 \(\vec{ap}\) 的分量, 所以 \(\vec{op} = \vec{ap} - \vec{ao}\), 其中 \(\vec{ao} = \frac{\vec{ab}}{|\vec{ab}|}(|\vec{ab}| \times \frac{|\vec{ao}|}{|\vec{ab}|}) = \vec{ab} \frac{|\vec{ao}|}{|\vec{ab}|}\).
</p>

<p>
\(\vec{op} = \vec{ap} - \vec{ab} \frac{|\vec{ao}|}{|\vec{ab}|}\), 别忘记了当 \(\theta \ge 90^{\circ}\) 时, \(\vec{ap}\) 在线段 \(ab\) 上的投影为 0, 所以 \(\frac{|\vec{ao}|}{|\vec{ab}|} = 0\).
</p>

<p>
这时正好 \(\vec{op} = \vec{ap} \rightarrow |\vec{op}| = |\vec{ap}|\).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> sdfSegment(<span style="color: #98fb98;">vec2</span> p, <span style="color: #98fb98;">vec2</span> a, <span style="color: #98fb98;">vec2</span> b) {
  <span style="color: #98fb98;">vec2</span> ap = p - a;
  <span style="color: #98fb98;">vec2</span> ab = b - a;
  <span style="color: #98fb98;">float</span> ratio = <span style="color: #b0c4de;">clamp</span>(<span style="color: #b0c4de;">dot</span>(ap, ab) / <span style="color: #b0c4de;">dot</span>(ab, ab), 0.0, 1.0);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(ap - ab * ratio);
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">float</span> c = sdfSegment(uv, <span style="color: #98fb98;">vec2</span>(0.3, -0.1), <span style="color: #98fb98;">vec2</span>(-0.4, 0.2));
  <span style="color: #98fb98;">float</span> l = <span style="color: #b0c4de;">smoothstep</span>(0.0, 1.0 / iResolution.x, c); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">1px &#32447;&#31895;
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(l), 1.0);
}
</pre>
</div>

<p>
根据图形的特点, 分区域来讨论点与图形的距离, 这就是定义 <code>SDF</code> 的总体思路.
</p>

<p>
而圆的 <code>SDF</code> 是最为简单的, 因为在任意区域上, 点到圆的距离都是一个算法, 无需分区域讨论.
</p>
</div>
</div>
<div id="outline-container-org28ae747" class="outline-4">
<h4 id="org28ae747">计算点与矩形之间的距离</h4>
<div class="outline-text-4" id="text-org28ae747">

<div id="org3691968" class="figure">
<p><img src="../../../files/sdf_box.png" alt="sdf_box.png">
</p>
<p><span class="figure-number">Figure 26: </span>中心位于原点且尺寸为 \(W \times H\) 的矩形与点之间的距离 (图片来源于 <a href="https://numbersmithy.com/signed-distance-function-to-oriented-2d-boxes/#org958ce36">Number-Smithy</a>)</p>
</div>

<p>
从图中可以看到, 对其中一个象限而言, 一个点 \((x, y)\) 所处的位置可以分为 4 类:
</p>

<ul class="org-ul">
<li><p>
\(P_1\): \(x \gt y\), \(x \gt \frac{W}{2}\) 并且 \(y \le \frac{H}{2}\)
</p>

<p>
点在矩形外, 距离为 \(\sqrt{(x - \frac{W}{2})^2 + (y - y)^2} = x - \frac{W}{2}\).
</p></li>

<li><p>
\(P_2\): \(x \lt y\), \(y \gt \frac{H}{2}\) 并且 \(x \le \frac{W}{2}\)
</p>

<p>
点在矩形外, 距离为 \(\sqrt{(x - x)^2 + (y - \frac{H}{2})^2} = y - \frac{H}{2}\).
</p></li>

<li><p>
\(P_3\): \(x \gt \frac{W}{2}\) 并且 \(y \gt \frac{H}{2}\)
</p>

<p>
点在矩形外, 距离为 \(\sqrt{(x - \frac{W}{2})^2 + (y - \frac{H}{2})^2}\).
</p></li>

<li><p>
\(P_4\): \(x \le \frac{W}{2}\) 并且 \(y \le \frac{H}{2}\)
</p>

<p>
在矩形内或矩形边上.
</p>

<p>
如果 \(x = \frac{W}{2}\) 并且 \(y \le \frac{H}{2}\), 又或 \(y = \frac{H}{2}\) 并且 \(x \le \frac{W}{2}\), 那么点在矩形边上, 点到矩形的距离为 0.
</p>

<p>
如果 \(x \lt \frac{W}{2}\) 并且 \(y \lt \frac{H}{2}\), 那么点在矩形内, 点到矩形的距离为 \(\max(x - \frac{W}{2}, y - \frac{H}{2})\).
</p>

<p>
其实点在边上的距离也可以用 \(\max(x - \frac{W}{2}, y - \frac{H}{2})\) 来进行计算.
</p></li>
</ul>


<p>
对于 \(P_1\), \(P_2\) 和 \(P_3\), 点与矩形的距离计算可以统一成 \(\sqrt{\max(x - \frac{W}{2}, 0)^2 + \max(y - \frac{H}{2}, 0)^2}\).
</p>

<p>
仔细观察的话, 可以发现矩形外和矩形里的距离计算可以结合在一起:
</p>

<p>
\(\sqrt{\max(x - \frac{W}{2}, 0)^2 + \max(y - \frac{H}{2}, 0)^2} + \min(\max(x - \frac{W}{2}, y - \frac{H}{2}), 0)\).
</p>

<p>
当点在矩形内时, \(\sqrt{\max(x - \frac{W}{2}, 0)^2 + \max(y - \frac{H}{2}, 0)^2} = 0\), 此时,距离为 \(\min(\max(x - \frac{W}{2}, y - \frac{H}{2}), 0)\);
</p>

<p>
当点在矩形外时, \(\min(\max(x - \frac{W}{2}, y - \frac{H}{2}), 0) = 0\), 此时, 距离为 \(\sqrt{\max(x - \frac{W}{2}, 0)^2 + \max(y - \frac{H}{2}, 0)^2}\).
</p>

<p>
对于其他象限, 可以通过绝对值把点映射到第一象限上, 所以最终的距离计算公式为:
</p>

<p>
\(\sqrt{\max(|x| - \frac{W}{2}, 0)^2 + \max(|y| - \frac{H}{2}, 0)^2} + \min(\max(|x| - \frac{W}{2}, |y| - \frac{H}{2}), 0)\).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> sdfBox(<span style="color: #98fb98;">vec2</span> p, <span style="color: #98fb98;">vec2</span> size) {
  <span style="color: #98fb98;">vec2</span> d = <span style="color: #b0c4de;">abs</span>(p) - size;
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(<span style="color: #b0c4de;">max</span>(d, 0.0) + <span style="color: #b0c4de;">min</span>(<span style="color: #b0c4de;">max</span>(d.x, d.y), 0.0));
}

<span style="color: #98fb98;">void</span> main() {
<span style="color: #b0c4de;">  #define</span> PI 3.14
<span style="color: #b0c4de;">  #define</span> ANGLE (PI / 3.0)
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36825;&#37324;&#23545;&#22270;&#24418;&#26059;&#36716; 60 &#24230;
</span>  <span style="color: #98fb98;">mat2</span> rotation = <span style="color: #98fb98;">mat2</span>(<span style="color: #b0c4de;">cos</span>(ANGLE), -<span style="color: #b0c4de;">sin</span>(ANGLE),
                       <span style="color: #b0c4de;">sin</span>(ANGLE), <span style="color: #b0c4de;">cos</span>(ANGLE));
  uv = rotation * uv;
  <span style="color: #98fb98;">float</span> c = sdfBox(uv, <span style="color: #98fb98;">vec2</span>(0.3, 0.1));
  <span style="color: #98fb98;">float</span> l = <span style="color: #b0c4de;">smoothstep</span>(0.0, 1.0 / iResolution.x, c);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(l), 1.0);
}
</pre>
</div>

<p>
绝对值是常用的对称操作, \(|x|\) 是让点关于 \(y\) 轴对称, \(|y|\) 是让点关于 \(x\) 轴对称, \((|x|, |y|)\) 是让其它象限全部映射到第一象限上.
</p>
</div>
</div>
<div id="outline-container-org5ea0a5f" class="outline-4">
<h4 id="org5ea0a5f">计算点与不规则多边形之间的距离</h4>
<div class="outline-text-4" id="text-org5ea0a5f">
<p>
点与不规则多边形之间距离的计算方法可以总结如下:
</p>

<ol class="org-ol">
<li>先计算点与每条边之间的距离, 这个可以参考前面的<a href="#orgfb905a7">计算点与线段之间的距离</a></li>
<li>在所有的点边距离中选取最短的一个作为点与不规则多边形之间的距离</li>
<li>判断点在多边形的里还是在外</li>
</ol>


<p>
这套算法的重点在于如何判断点在多边形里面还是外面, 这是一个比计算几何中较常见的话题: <a href="https://en.m.wikipedia.org/wiki/Point_in_polygon">Point In Polygon</a>, 简称 <code>PIP</code>.
</p>

<p>
总体上来说, 目前常用的判断方法是: 射线投影算法 (<code>Ray-Casting Algorithm</code>) 和 回转数算法 (<code>Winding Number Algorithm</code>).
</p>

<p>
射线投影算法是从判定点在任意方向上发出一条射线, 统计射线穿过多边形边的次数, 如果次数为偶数, 那么判定点就在多边形的外面, 单数则表明判定点在多边形里面.
</p>

<p>
所以这个算法也叫交叉数算法 (<code>crossing number algorithm</code>) 或奇偶规则算法 (<code>even-odd rule algorithmn</code>).
</p>

<p>
比如下图, 射线与多边形有两个交点, 因此, 点在多边形外面.
</p>


<div id="org9c7b0d3" class="figure">
<p><img src="../../../files/self-intersecting-polygon-with-holes.png" alt="self-intersecting-polygon-with-holes.png">
</p>
<p><span class="figure-number">Figure 27: </span>空心的自交多变形</p>
</div>

<p>
但是射线投影算法对于这种自交多边形 (<code>self-intersecting polygon</code>) 的判断可能会出现问题, 所谓自交多边形是指多边形的边之间存在相交的情况.
</p>

<p>
想象一下, 这个多边形的自交边所形成的区域为实心, 那么点就是在多边形里, 然而射线和多边形相交的点数依然是偶数, 这显然和射线投影算法矛盾.
</p>


<div id="orgb73e6bd" class="figure">
<p><img src="../../../files/self-intersecting-polygon-without-holes.png" alt="self-intersecting-polygon-without-holes.png">
</p>
<p><span class="figure-number">Figure 28: </span>实心的自交多边形</p>
</div>

<p>
而环绕数算法是计算判定点对于多边形的环绕数, 如果环绕数不为 0, 那么判定点就在多边形内, 所以环绕数算法也被称做非零规则算法(<code>nonzero-rule algorithm</code>).
</p>

<p>
所谓环绕数是指平面上的闭合曲线/多边形绕过判定点的总次数, 如果一个闭合曲线/多边形往逆时针方向绕过判定点 \(n\) 次, 那么判定点的环绕数为 \(n\), 如果是往顺时针方向旋转 \(n\) 次, 那么环绕数是 \(-n\).
</p>


<div id="org90ca5d6" class="figure">
<p><img src="../../../files/Winding_Number_Animation_Small.gif" alt="Winding_Number_Animation_Small.gif">
</p>
<p><span class="figure-number">Figure 29: </span>环绕数为 2</p>
</div>


<div id="org2dacec5" class="figure">
<p><img src="../../../files/winding-number.png" alt="winding-number.png">
</p>
</div>

<p>
因此, 环绕数 \(\omega\) 的计算方式大概是沿着闭合曲线/多边形围绕着判定点走过的角度和 \(\varphi\) 除以 \(2 \pi\): \(\omega = \frac{\varphi}{2 \pi}\).
</p>

<p>
现在问题就变成如何求解角度和 \(\omega\), 先假设闭合曲线的参数方程为 \(C(t) = (x(t), y(t))\), \(t \in [a, b]\), \(C(a) = C(b)\),
</p>

<p>
当沿着曲线移动到点 \(C(t)\) 上时, 想知道该点到判定点 \(R = (x_0, y_0)\) 的角度, 可以通过 \(\varphi(t) = \mathrm{atan} (\frac{y(t) - y_0}{x(t) - x_0})\) 求得.
</p>


<div id="org9945204" class="figure">
<p><img src="../../../files/subtended-angle.png" alt="subtended-angle.png">
</p>
<p><span class="figure-number">Figure 30: </span>\(R\) 是判定点, \(C(t)\) 是曲线上的点</p>
</div>

<p>
计算角度和 \(\varphi\) 就是一个连续问题, 因此需要用到积分, 为了让公式看起来简洁, 这里假设判定点 \(R\) 在 \((0, 0)\) 上,
</p>

<p>
首先需要求出 \(\frac{d}{d t}(\varphi(t))\), 然后运用积分 \(\varphi(t) = \int_{a}^{b} \frac{d}{d t} (\varphi(t)) dt\).
</p>

<p>
令 \(g(t) = \frac{y(t)}{x(t)}\), 分别计算出 \(\frac{d}{d t} (g(t))\) 和 \(\frac{d}{d t} (\mathrm{atan}(g))\), 再使用链式法则求的 \(\frac{d}{dt} (\varphi(t))\):
</p>

<p>
\(\begin{cases} \frac{d}{d t}(g(t)) = \frac{d}{d t} (\frac{y(t)}{x(t)}) = \frac{y^{'}(t) \cdot x(t) - y(t) \cdot x^{'}(t)}{[x(t)]^2} \\ \frac{d}{d g}(\mathrm{atan}(g)) = \frac{1}{1 + g^2} = \frac{1}{1 + \frac{y(t)}{x(t)}^2} = \frac{[x(t)]^2}{[x(t)]^2 + [y(t)]^2} \\ \frac{d}{d t}(\varphi(t)) = \frac{d}{d t}(\mathrm{atan}(\frac{y(t)}{x(t)})) = \frac{d}{dg} (\mathrm{atan}(g)) \cdot \frac{d}{d t}(g(t)) = \frac{y^{'}(t) \cdot x(t) - y(t) \cdot x^{'}(t)}{[x(t)]^2 + [y(t)]^2} \end{cases}\)
</p>

<p>
因此, 对于曲线 \(C\) 对于判定点 \(R = (0, 0)\) 的环绕数计算为: \(\omega(R = (0, 0), C = (x(t), y(t))) = \frac{1}{2 \pi} \int_{a}^{b} \frac{y^{'}(t) \cdot x(t) - y(t) \cdot x^{'}(t)}{[x(t)]^2 + [y(t)]^2} dt\).
</p>

<blockquote>
<p>
对于 \(R = (x_0 \ne 0, y_0 \ne 0)\) 的情况, \(\omega(R = (x_0, y_0), C = (x(t), y(t))) = \frac{1}{2 \pi} \int_{a}^{b} \frac{y^{'}(t) \cdot (x(t) - x_0) - (y(t) - y_0) \cdot x^{'}(t)}{(x(t) - x_0)^2 + (y(t) - y_0)^2} dt\).
</p>
</blockquote>

<p>
那么对于多边形该如何计算呢?
</p>

<p>
我们定义多边形 \(P\) 为一个点数组: \(P_0, P_1, \dots, P_{n - 1}, P_n = P_0\), 可以把多边形看做分段线性曲线(也就是线段), 由 \(P_i\) 到 \(P_{i + 1}\) 作为端点的边:
</p>

<p>
\(L_{P_i P_{i+1}}(t) = (x_{i}(t - i), y_{i}(t - i))\), \(t \in [i, i + 1]\), 在边 \(L_{P_i P_{i+1}}\) 上点的计算为 \((x_{i}(t), y_{i}(t)) = t P_{i + 1} + (1 - t) P_i\).
</p>


<div id="org1271237" class="figure">
<p><img src="../../../files/signed-angle-for-polygons.png" alt="signed-angle-for-polygons.png">
</p>
</div>

<p>
\(\omega(R, P) = \frac{1}{2 \pi} \sum\limits_{i = 0}^{n - 1} \mathrm{acos} \frac{\vec{R P_i} \cdot \vec{P_{i+1} R}}{|\vec{R P_i}| |\vec{R P_{i+1}}|} \mathrm{sign}(\vec{R P_{i}} \times \vec{R P_{i+1}}) = \frac{1}{2 \pi} \sum\limits_{i = 0}^{n - 1} \varphi_{i}\), 其中 \(\mathrm{sign}(x) = \begin{cases} 1 & \text{if } x > 0 \\ 0 & \text{if } x = 0 \\ -1 & \text{if } x < 0 \end{cases}\).
</p>

<blockquote>
<p>
多边形的环绕数公式可以从直觉上看出来, 但这样不够严谨, 它的证明过程来自 <a href="../../../files/The-point-in-polygon-problem-for-arbitrary-polygons.pdf">参考资料</a>, 这里进行一些总结和补充.
</p>

<p>
下面这个三角形由判断点 \(R\) 和多边形的其中一条边 \(PQ\) 的两个端点组成, 边的生成方向是从 \(P\) 到 \(Q\), \(\alpha\) 就是想求的环绕角度.
</p>


<div id="org17b5993" class="figure">
<p><img src="../../../files/triangle-RPQ.png" alt="triangle-RPQ.png">
</p>
</div>

<p>
目前知道的下条件有:
</p>

<p>
\(R = (0, 0)\)
</p>

<p>
\(\begin{cases} \vec{RP} = (x_p, y_p) \\ \vec{RQ} = (x_q, y_q) \\ \vec{RP} \cdot \vec{RQ} = x_p x_q + y_p y_q \\ \vec{RP} \times \vec{RQ} = x_p y_q - x_q y_p \\ \cos \alpha = \frac{\vec{RP} \cdot \vec{RQ}}{|\vec{RP}| |\vec{RQ}|} \end{cases}\)
</p>

<p>
\(\begin{cases} \vec{QP} = (x_{p} - x_{q}, y_{p} - y_{q}) \\ \vec{RP} = (x_{p}, y_{p}) \\ \vec{QP} \times \vec{RP} = (x_{p} - x_{q})y_{p} - (y_{p} - y_{q})x_{p} = x_{p}y_{p} - x_{q}y_{p} - y_{p}x_{p} + y_{q}x_{p} = x_{p}y_{q} - x_{q}y_{p} \\ \cot \beta = \frac{\vec{QP} \cdot \vec{RP}}{|\vec{QP} \times \vec{RP}|} = \frac{|\vec{QP}| |\vec{RP}| \cos \beta}{|\vec{QP}| |\vec{RP}| \sin \beta} \end{cases}\)
</p>

<p>
\(\begin{cases} \vec{PQ} = (x_{q} - x_{p}, y_{q} - y_{p}) \\ \vec{RQ} = (x_{q}, y_{q}) \\ \vec{PQ} \times \vec{RQ} = (x_{q} - x_{p})y_{q} - (y_{q} - y_{p})x_{q} = x_{q}y_{q} - x_{p}y_{q} - x_{q}y_{q} + x_{q}y_{p} = -(x_{p}y_{q} - x_{q}y_{p}) \\ \vec{RQ} \times \vec{PQ} = x_p y_q - x_q y_p \\ \cot \gamma = \frac{\vec{PQ} \cdot \vec{RQ}}{|\vec{PQ} \times \vec{RQ}|} = \frac{|\vec{PQ}||\vec{RQ}|\cos \gamma}{|\vec{PQ}||\vec{RQ}|\sin \gamma} \end{cases}\)
</p>

<p>
可以发现 \(\vec{RP} \times \vec{RQ} = \vec{QP} \times \vec{RP} = \vec{RQ} \times \vec{PQ} = x_{p}y_{q} - x_{q}y_{p}\).
</p>

<p>
令 \(D = x_{p}y_{q} - x_{q}y_{p}\),
</p>

<p>
在整个环绕数计算中, 会运用大量的 <code>2D</code> 向量叉积运算,
</p>

<p>
比如 \(\vec{RP} \times \vec{RQ}\) 的结果可以用来判断 \(\vec{RP}\) 围绕点 \(R\) 往哪个方向旋转最小的角度可以到达 \(\vec{RQ}\) 上:
</p>

<p>
如果 \(\vec{RP} \times \vec{RQ} \gt 0\), 那么 \(\vec{RP}\) 需要往逆时针方向旋转;
</p>

<p>
如果 \(\vec{RP} \times \vec{RQ} \lt 0\), 那么 \(\vec{RP}\) 需要往顺时针方向旋转;
</p>

<p>
如果 \(\vec{RP} \times \vec{RQ} = 0\), 那么 \(\vec{RP}\) 和 \(\vec{RQ}\) 对齐.
</p>

<p>
对于线性曲线 \(PQ = (x(t), y(t)) = t Q + (1 - t)P\), \(t \in [0, 1]\),
</p>

<p>
\(\begin{equation*} \begin{aligned} & tQ + (1 - t)P \\ = & tQ + P - tP \\ = & t(Q - P) + P \\ = & (t(x_q - x_p) + x_p, t(y_q - y_p) + y_p) \\ = & (t(x_q - x_p) + x_p, t(y_q - y_p) + y_p) \cdot (t(x_q - x_p) + x_p, t(y_q - y_p) + y_p) \\ = & [t(x_q - x_p) + x_p]^2 + [t(y_q - y_p) + y_p]^2 \\ = & t^2 (x_q - x_p)^2 + 2t (x_q - x_p) x_p + x_p^2 + t^2 (y_q - y_p)^2 + 2t(y_q - y_p)y_p + y_p^2 \\ = & t^2 [(x_q - x_p)^2 - (y_q - y_p)^2] + 2t [(x_q - x_p)x_p + (y_q - y_p)y_p] + x_p^2 + y_p^2 \end{aligned} \end{equation*}\)
</p>

<p>
\(\begin{equation*} \begin{aligned} & [x(t)]^2 + [y(t)]^2 \\ = & (t(x_q - x_p) + x_p, t(y_q - y_p) - y_p) \cdot (t(x_q - x_p) + x_p, t(y_q - y_p) + y_p) \\ = & [t(x_q - x_p) + x_p]^2 + [t(y_q - y_p) + y_p]^2 \\ = & t^2 (x_q - x_p)^2 + 2t (x_q - x_p) x_p + x_p^2 + t^2 (y_q - y_p)^2 + 2t(y_q - y_p)y_p + y_p^2 \\ = & t^2 [(x_q - x_p)^2 - (y_q - y_p)^2] + 2t [(x_q - x_p)x_p + (y_q - y_p)y_p] + x_p^2 + y_p^2 \end{aligned} \end{equation*}\)
</p>

<p>
令 \(\vec{PQ} = Q - P = (x_q - x_p, y_q - y_p)\), 对上面的等式进行化简:
</p>

<p>
\(\begin{equation*} \begin{aligned} & t^2 (\vec{PQ} \cdot \vec{PQ}) + 2t (\vec{PQ} \cdot \vec{RP}) + \vec{RP} \cdot \vec{RP} \\ = & t^2 [(Q - P) \cdot (Q - P)] + 2t [(Q - P) \cdot (P - R)] + [(P - R) \cdot (P - R)] \\ = & t^2 |Q - P|^2 + 2t [(Q - P) \cdot (P - R)] + |P - R|^2 \end{aligned} \end{equation*}\)
</p>

<p>
求 \((x(t), y(t)) = t Q + (1 - t) P\) 的梯度向量: \(\begin{cases} x(t) = t x_q + (1 - t) x_p \\ y(t) = t y_q + (1 - t) y_p \end{cases} \xrightarrow [\text{derivate}] t \begin{cases} x^{'}(t) = x_q - x_p \\ y^{'}(t) = y_q - y_p \end{cases}\),
</p>

<p>
可以发现正好 \(\vec{PQ} = (x^{'}(t), y^{'}(t)) = (x_q - x_p, y_q - y_p)\), 而 \(\vec{RQ} = (x(t), y(t))\), 所以 \(D = \vec{RQ} \times \vec{PQ}\).
</p>

<p>
\(\begin{equation*} \begin{aligned} & \int_{0}^{1} \frac{y^{'}(t) x(t) - y(t)x^{'}(t)}{x(t)^2 + y(t)^2} dt \\ = & \int_{0}^{1} \frac{D}{t^2 \langle Q - P | Q - P \rangle + 2t \langle Q - P | P - R \rangle + \langle P - R | P - R \rangle} dt \\ = & D \int_{0}^{1} \frac{1}{t^2 \langle Q - P | Q - P \rangle + 2t \langle Q - P | P - R \rangle + \langle P - R | P - R \rangle} dt \end{aligned} \end{equation*}\)
</p>

<p>
由于括号太多导致看起来有点眼花, 为了方便阅读, 这里用 \(\langle \vec{a} | \vec{b} \rangle\) 来表示 \(\vec{a} \cdot \vec{b}\), 这种表示方法在其它地方也会经常见到.
</p>

<p>
在前面我们已经知道 \(\frac{y^{'}(t) x(t) - y(t)x^{'}(t)}{x(t)^2 + y(t)^2}\) 是 \(\mathrm{atan}(\frac{y(t)}{x(t)})\) 关于 \(t\) 的导数, 所以这个积分的解析式必然是 \(\mathrm{atan}\) 或 \(\tan^{-1}\) 函数,
</p>

<p>
通过查表可知有一个类似的公式: \(\int \frac{1}{x^2 + a^2} dx = \frac{1}{a} \tan^{-1}(\frac{x}{a}) + C\),
</p>

<p>
因此, 想要求出 \(t^2 \langle Q - P | Q - P \rangle + 2t \langle Q - P | P - R \rangle + \langle P - R | P - R \rangle\) 的反导数就得把它转换成平方和的形式: \(u^2 + v^2\).
</p>

<p>
这里令 \(\begin{cases} a = \langle Q - P | Q - P \rangle \\ b = \langle Q - P | P - R \rangle \\ c = \langle P - R | P - R \rangle \end{cases}\), 令 \(f(t) = at^2 + 2bt + c = a(t^2 + \frac{2b}{a} t) + c\),
</p>

<p>
\(t^2 + \frac{2b}{a} t\) 转换成 \(t\) 和 \(\frac{b}{a}\) 为主的完全平方和: \(t^2 + \frac{2b}{a} t + (\frac{b}{a})^2 - (\frac{b}{a})^2 = (t + \frac{b}{a})^2 - (\frac{b}{a})^2\).
</p>

<p>
\(f(t) = a(t + \frac{b}{a})^2 - \frac{b^2}{a} + c = a(t + \frac{b}{a})^2 + \frac{ac - b^2}{a} = a[(t + \frac{b}{a})^2 + \frac{ac - b^2}{a^2}]\),
</p>

<p>
令 \(u^2 = (t + \frac{b}{a})^2\) 以及 \(v^2 = \frac{ac - b^2}{a^2}\), 经过变换可以得到 \(\frac{1}{f(t)} = \frac{1}{a} \frac{1}{u^2 + v^2}\),
</p>

<p>
对 \(\int \frac{1}{f(x)} dt\) 使用换元法, 令 \(u(t) = t + \frac{b}{a}\), \(du = u^{'}(t) \cdot dt = dt\), 所以:
</p>

<p>
\(\begin{equation*} \begin{aligned} & \int \frac{1}{f(x)} dt \\ = & \frac{1}{a} \int \frac{1}{u^2 + v^2} du \\ = & \frac{1}{a v} \tan^{-1}(\frac{u}{v}) + C \\ = & \frac{1}{\sqrt{ac - b^2}} \tan^{-1} (\frac{at + b}{\sqrt{ac - b^2}}) + C \end{aligned} \end{equation*}\)
</p>

<p>
再把 \(a\), \(b\) 和 \(c\) 代入回去, 得到 \(ac - b^2 = (x_p y_q - x_q y_p)^2 = D^2\).
</p>

<p>
由于手动计算太繁琐且容易出错, 所以这条关系是通过 <code>Maxima</code> 求解得到:
</p>

<div class="org-src-container">
<pre class="src src-maxima">Q<span style="color: #00ffff;">:</span> <span style="color: #b0c4de;">matrix</span>(<span style="color: #00ffff;">[</span>xq<span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>yq<span style="color: #00ffff;">]</span>)$

P<span style="color: #00ffff;">:</span> <span style="color: #b0c4de;">matrix</span>(<span style="color: #00ffff;">[</span>xp<span style="color: #00ffff;">]</span>, <span style="color: #00ffff;">[</span>yp<span style="color: #00ffff;">]</span>)$

PQ<span style="color: #00ffff;">:</span> Q <span style="color: #00ffff;">-</span> P$

a<span style="color: #00ffff;">:</span> PQ <span style="color: #00ffff;">.</span> PQ$

b<span style="color: #00ffff;">:</span> PQ <span style="color: #00ffff;">.</span> P$

c<span style="color: #00ffff;">:</span> P <span style="color: #00ffff;">.</span> P$

<span style="color: #b0c4de;">factor</span>(a <span style="color: #00ffff;">*</span> c <span style="color: #00ffff;">-</span> b <span style="color: #00ffff;">*</span> b);
</pre>
</div>

<p>
\(\begin{equation*} \begin{aligned} & D \int_{0}^{1} \frac{1}{t^2 \langle Q - P | Q - P \rangle + 2t \langle Q - P | P - R \rangle + \langle P - R | P - R \rangle} dt \\ = & \left. D (\frac{1}{\sqrt{ac - b^2}} \tan^{-1}(\frac{at + b}{\sqrt{ac - b^2}}) + C) \right]_0^1 \\ = & \left. D (\frac{1}{D} \tan^{-1}(\frac{at + b}{D}) + C) \right]_0^1 \\ = & \tan^{-1}(\frac{a + b}{D}) - \tan^{-1}(\frac{b}{D}) \end{aligned} \end{equation*}\)
</p>

<p>
其中 \(a + b = \langle Q - P | Q - P \rangle + \langle Q - P | P - R \rangle = \langle Q - P | (Q - P + P - R) \rangle = \langle Q - P | Q - R \rangle\),
</p>

<p>
\(\begin{equation*}\begin{aligned} & \tan^{-1} \frac{a + b}{D} - \tan^{-1} \frac{b}{D} \\ = & \tan^{-1} \frac{\langle Q - P|Q - R \rangle}{D} - \tan^{-1} \frac{\langle Q - P | P - R \rangle}{D} \\ = & \tan^{-1} \frac{\langle Q - P|Q - R \rangle}{D} + \tan^{-1} \frac{\langle P - Q | P - R \rangle}{D} \\ = & \tan^{-1} \frac{\vec{PQ} \cdot \vec{RQ}}{D} + \tan^{-1} \frac{ \vec{QP} \cdot \vec{RP} }{D} \\ = & \mathrm{sign}(D) (\tan^{-1}\cot \gamma + \tan^{-1}\cot \beta) \end{aligned} \end{equation*}\)
</p>

<p>
根据三角函数的关系: \(\tan(\frac{\pi}{2} - \phi) = \cot \phi\), 可以得到:
</p>

<p>
\(\begin{equation*} \begin{aligned} & \mathrm{sign}(D)(\tan^{-1} \cot \gamma + \tan^{-1} \cot \beta) \\ = & \mathrm{sign}(D)(\pi - \gamma - \beta) \\ = & \mathrm{sign}(D) \alpha \end{aligned} \end{equation*}\)
</p>

<p>
其中, \(\alpha = \mathrm{acos} \frac{\vec{RP} \cdot \vec{RQ}}{|\vec{RP}||\vec{RQ}|}\), 所以 \(\int_0^1 \frac{y^{'}(t) \cdot x(t) - y(t) \cdot x^{'}(t)}{x(t)^2 + y(t)^2} dt = \mathrm{sign}(\vec{RP} \times \vec{RQ}) \mathrm{acos} \frac{\vec{RP} \cdot \vec{RQ}}{|\vec{RP}||\vec{RQ}|}\).
</p>

<p>
最后, 对多边形的每条边关于判定点的环绕角度进行统计, 并得出环绕数:
</p>

<p>
\(\omega(R, P) = \frac{1}{2 \pi} \sum_{i = 0}^{n - 1} \mathrm{acos} \frac{\vec{RP_i} \cdot \vec{RQ}}{|\vec{RP_i}||\vec{RQ}|} \mathrm{sign}(\vec{RP_i} \times \vec{RQ})\), 其中 \(Q = P_{i + 1}\).
</p>
</blockquote>

<p>
但是, 使用环绕角来计算环绕数的算法存在一些性能缺陷, 因为需要用到三角函数以及算一整圈的角度.
</p>

<p>
后来由 <code>Dan Sunday</code> 提出了另外一种方法来替代计算环绕角度: 从判定点发射出一条水平射线, 当这条射线与多边形的边相交时,
</p>

<p>
如果相交边关于判定点的环绕角方向逆时针方向, 或说相交边往上走, 那么环绕数增加;
</p>

<p>
如果相交边关于判定点的环绕角方向是顺时针方向, 或说相交边往下走, 那么环绕数减少.
</p>


<div id="orgba76e49" class="figure">
<p><img src="../../../files/Winding_number_algorithm_example.svg.png" alt="Winding_number_algorithm_example.svg.png" width="504px">
</p>
</div>

<p>
以上图的点 \(R\) 为例子, 以它为起点的水平射线与线段 \(P_iP_{i+1}\) 发生了一次相交, 于是计算 \(\vec{P_{i}P_{i+1}} \times \vec{P_{i}R}\),
</p>

<p>
这里令 \(\vec{P_i P_{i+1}} = (x_1, y_1)\), \(\vec{P_{i} R} = (x_2, y_2)\), 所以 \(\vec{P_{i}P_{i+1}} \times \vec{P_{i}R} = x_1 y_2 - x_2 y_1\),
</p>

<p>
如果计算结果为负数, 那么环绕数减一; 如果计算结果为正数, 那么环绕数加一; 如果计算结果是零, 那么环绕数不变.
</p>

<p>
显然, \(R\) 点的环绕数为 \(-1\), 因为 \(\vec{P_{i}P_{i+1}}\) 要往顺时针方向旋转到 \(\vec{P_{i}R}\).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> N 5

<span style="color: #98fb98;">float</span> sdfPoly(<span style="color: #98fb98;">vec2</span> p, <span style="color: #98fb98;">vec2</span>[N] vs) {
  <span style="color: #00ffff;">const</span> <span style="color: #98fb98;">int</span> num = vs.<span style="color: #b0c4de;">length</span>();
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21021;&#22987;&#21270;&#26368;&#30701;&#36317;&#31163;&#30340;&#24179;&#26041;
</span>  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">dot</span>(p - vs[0], p - vs[0]);
  <span style="color: #98fb98;">float</span> s = 1.0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0, j = num - 1; i &lt; num; j=i, i++) {
    <span style="color: #98fb98;">vec2</span> ab = vs[j] - vs[i];
    <span style="color: #98fb98;">vec2</span> ap = p - vs[i];
    <span style="color: #98fb98;">float</span> ratio = <span style="color: #b0c4de;">clamp</span>(<span style="color: #b0c4de;">dot</span>(ap, ab) / <span style="color: #b0c4de;">dot</span>(ab, ab), 0.0, 1.0);
    <span style="color: #98fb98;">vec2</span> ao = ap - ab * ratio;

    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35760;&#24405;&#26368;&#30701;&#30340;&#36317;&#31163;&#30340;&#24179;&#26041;
</span>    d = <span style="color: #b0c4de;">min</span>(d, <span style="color: #b0c4de;">dot</span>(ao, ao));

    <span style="color: #98fb98;">bvec3</span> cond = <span style="color: #98fb98;">bvec3</span>( p.y &gt;= vs[i].y, p.y &lt; vs[j].y, ab.x * ap.y &gt; ab.y * ap.x );
    <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
      &#24403; min(vs[i].y, vs[j].y) &lt;= p.y &lt; max(vs[i].y, vs[j].y), &#37027;&#20040;&#23556;&#32447;&#25165;&#21644;&#32447;&#27573; vs[i]vs[j] &#30456;&#20132;.

      &#20294;&#26159;&#21407;&#25991;&#24182;&#27809;&#26377;&#36825;&#20040;&#21028;&#26029;&#30456;&#20132;, &#36825;&#26159;&#22240;&#20026;&#36824;&#32467;&#21512;&#20102;&#20854;&#23427;&#26465;&#20214;&#26469;&#21028;&#26029;.

      &#22914;&#26524;&#36793;&#26159;&#24448;&#19978;&#36208;&#30340;, &#37027;&#20040;&#23556;&#32447;&#24819;&#19982;&#36793;&#30456;&#20132;, &#37027;&#20040;&#24517;&#39035;&#28385;&#36275; vs[i].y &lt; vs[j].y &#20197;&#21450; p.y &gt;= vs[i].y &#21644; p.y &lt; vs[j].y &#21516;&#26102;&#20026; true,

      &#22914;&#26524;&#36824;&#24819;&#35201;&#23545;&#29615;&#32469;&#25968;&#36827;&#34892;&#21464;&#21270;, &#37027;&#20040;&#36825;&#26102;&#20505;&#21482;&#33021;&#35753; cross(ab, ap) &gt; 0, &#22240;&#20026;&#36793;&#24448;&#19978;&#36208;;

      &#22914;&#26524;&#36793;&#26159;&#24448;&#19979;&#36208;, &#36824;&#24819;&#23545;&#29615;&#32469;&#25968;&#36827;&#34892;&#21464;&#21270;, &#37027;&#20040;&#25152;&#26377;&#21028;&#26029;&#24517;&#39035;&#20026; false.
</span><span style="color: #ff7f24;">    */</span>
    <span style="color: #00ffff;">if</span> ( <span style="color: #b0c4de;">all</span>(cond) || <span style="color: #b0c4de;">all</span>(<span style="color: #b0c4de;">not</span>(cond)) ) s *= -1.0;
  }
  <span style="color: #00ffff;">return</span> s * <span style="color: #b0c4de;">sqrt</span>(d);
}

<span style="color: #98fb98;">void</span> main () {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);

  <span style="color: #98fb98;">vec2</span> v0 = 0.8*<span style="color: #b0c4de;">cos</span>( 0.40 * iTime + <span style="color: #98fb98;">vec2</span>(0.0,2.00) + 0.0 );
  <span style="color: #98fb98;">vec2</span> v1 = 0.8*<span style="color: #b0c4de;">cos</span>( 0.45 * iTime + <span style="color: #98fb98;">vec2</span>(0.0,1.50) + 1.0 );
  <span style="color: #98fb98;">vec2</span> v2 = 0.8*<span style="color: #b0c4de;">cos</span>( 0.50 * iTime + <span style="color: #98fb98;">vec2</span>(0.0,3.00) + 2.0 );
  <span style="color: #98fb98;">vec2</span> v3 = 0.8*<span style="color: #b0c4de;">cos</span>( 0.55 * iTime + <span style="color: #98fb98;">vec2</span>(0.0,2.00) + 4.0 );
  <span style="color: #98fb98;">vec2</span> v4 = 0.8*<span style="color: #b0c4de;">cos</span>( 0.60 * iTime + <span style="color: #98fb98;">vec2</span>(0.0,1.00) + 5.0 );

  <span style="color: #98fb98;">vec2</span>[] polygon = <span style="color: #98fb98;">vec2</span>[](v0, v1, v2, v3, v4);

  <span style="color: #98fb98;">float</span> d = sdfPoly(uv, polygon); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-0.5, 0.5]
</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20998;&#21035;&#22810;&#36793;&#24418;&#20869;&#22806;&#35774;&#23450;&#39068;&#33394;
</span>  <span style="color: #98fb98;">vec3</span> col = (d &gt; 0.0) ? <span style="color: #98fb98;">vec3</span>(0.9,0.6,0.3) : <span style="color: #98fb98;">vec3</span>(0.65,0.85,1.0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26681;&#25454;&#36317;&#31163;&#35745;&#31639;&#20986;&#28176;&#21464;&#33394;&#30340;&#36215;&#28857;&#33394;
</span>  col *= 1.0 - <span style="color: #b0c4de;">exp</span>(-6.0 * <span style="color: #b0c4de;">abs</span>(d)); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[0.0, 1.0)
</span>  col *= 0.8 + 0.2 * <span style="color: #b0c4de;">cos</span>(140.0 * d);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36827;&#34892;&#39068;&#33394;&#28176;&#21464;
</span>  col = <span style="color: #b0c4de;">mix</span>(col, <span style="color: #98fb98;">vec3</span>(1.0), 1.0 - <span style="color: #b0c4de;">smoothstep</span>(0.0, 0.015, <span style="color: #b0c4de;">abs</span>(d)));

  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(col), 1.0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">float l = smoothstep(0.0, 1.0 / iResolution.x, abs(d));
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">gl_FragColor = vec4(vec3(l), 1.0);
</span>}
</pre>
</div>

<p>
最后来点题外话, 射线投影算法以及环绕数算法都是正确的, 当然这取决于想绘制的多边形是否带孔,
</p>

<p>
如果带孔, 那么就使用射线投影算法; 如果不带孔就使用环绕数算法.
</p>

<p>
在 <code>SVG</code> 里面, 一些元素拥有 <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/fill-rule">fill-rule</a> 属性, 这个属性的值是 <code>evenodd</code> 和 <code>nonzero</code> 两者的其中之一, 用来控制自交多边形是否带孔.
</p>
</div>
</div>
</div>
<div id="outline-container-org3cf360a" class="outline-3">
<h3 id="org3cf360a">3D SDF</h3>
<div class="outline-text-3" id="text-org3cf360a">
</div>
<div id="outline-container-ray-marching" class="outline-4">
<h4 id="ray-marching">Ray Marching</h4>
<div class="outline-text-4" id="text-ray-marching">
<blockquote>
<p>
参考资料:
</p>

<ol class="org-ol">
<li><a href="https://www.youtube.com/watch?v=PGtv-dBi2wE&amp;list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P&amp;index=2">The Art of Code - Ray Marching for Dummies</a></li>
<li><a href="https://github.com/electricsquare/raymarching-workshop?tab=readme-ov-file">Ray Marching Workshop</a></li>
</ol>
</blockquote>

<p>
光线步进(<code>Ray Marching</code>)是一种渲染成像的方案, 类似渲染成像方案的还有光线投射(<code>Ray Casting</code>)和光线追踪(<code>Ray Tracing</code>).
</p>

<p>
这三种方案在成像原理的层面上基本上是一样的, 但它们在实现手段上和实现细节上会有所区别, 最后导致实现效果也有所差别, 它们的成像原理可以通过以下图片来概括.
</p>


<div id="org830c825" class="figure">
<p><img src="../../../files/ray-tracing.jpg" alt="ray-tracing.jpg" width="504px">
</p>
</div>

<p>
从相机 \(O\) 发出数条视觉射线(<code>view ray</code>), 假设其中一条视觉射线穿过投影平面(也就是最终成像的图像)上位于位置 \(P\) 的像素, 所以射线的方向为 \(P - O = \vec{OP}\), 判断该视觉射线是否和物体相交, 如果存在多个交点 \(i_0, i_1\), 便从物体在离相机最近的相交点上获取颜色来作为位于 \(P\) 点像素的颜色; 如果不存在交点, 那么 \(P\) 上的像素将不设置任何颜色或设置默认色.
</p>

<p>
接着是阴影的形成, 原理类似, 从光源视觉射线与物体的交点 \(S\) 往光源发出一条阴影射线 \(\vec{SL} = L - S\), 再找出这条阴影射线上离 \(S\) 最近的交点 \(J_0\), 如果 \(|J_0 - S| \lt |L - S|\), 那么 \(S\) 就处于阴影之中, 在视觉射线所对应的像素上设置阴影色; 如果 \(|J_0 - S| \ge |L - S|\) (不存在交点也属于这种情况), 那么 \(S\) 不再阴影之中, 便无需设置阴影色.
</p>

<blockquote>
<p>
上面介绍内容只是比较简单的成像实现, 比如没有考虑物体投影和光线反射的情况, 但本文专注于基本的成像原理,
</p>

<p>
对额外内容有兴趣的话可以看一下相关书籍, 比如, <a href="https://www.gabrielgambetta.com/computer-graphics-from-scratch/02-basic-raytracing.html">Computer Graphics From Scratch</a> 的前五章是关于光线追踪的内容.
</p>
</blockquote>

<p>
从原理上来讲, 整个成像过程的大部分内容在于计算射线与物体的交点, 这也是这三种成像方案之间的最大不同:
</p>

<p>
光线追踪是通过解方程来算出射线与物体之间的交点;
</p>

<p>
光线投射是沿着视觉射线方向, 以固定步长不停地前进, 直到射线超出距离或与物体相交;
</p>

<p>
光线步进也是沿着视觉射线方向不停前进, 直到射线超出距离或与物体相交, 和光线投射的区别在于: 前进的步长 \(d\) 不是固定的,
</p>

<p>
每次光线前进 \(d\) 时, 需要保证在当前位置上沿着各个方向前进 \(d\) 后不会进入任何物体体内, 只是与物体表面接触.
</p>


<div id="org4a96551" class="figure">
<p><img src="../../../files/08_displacement_05.png" alt="08_displacement_05.png">
</p>
<p><span class="figure-number">Figure 31: </span>光线步进</p>
</div>

<p>
假设要判断位于 \(p_0\) 的相机在方向 \(\vec{rd}\) (是单位向量) 上发射出的一条视角射线是否与物体相交, 先在 \(p_0\) 上找到距离步长 \(d_1\) 并沿着方向 \(\vec{rd}\) 前进到 \(p_1\), 只有这个步长可以保证所有从 \(p_0\) 沿着任意方向发出的射线不会进入物体内部, 比如步长 \(e_1\) 会让某些方向的射线进入物体内, \(d_1\) 的特点是所有可选步长中最短, 后续 \(d_2\), \(d_3\) 和 \(d_4\) 的计算同理. 前进后的坐标计算为 \(p_n = p_0 + \vec{rd} \cdot \sum\limits_{i=0}^{n} d_i\), 其中 \(d_0 = 0\).
</p>

<p>
由于光线在前进时不断形成球体检查相交情况, 所以光线步进也被称为球体追踪(<code>sphere tracing</code>).
</p>

<p>
因为 \(\sum\limits_{i=0}^{n} d_i\) 是相机与场景交点的正交距离, 所以可以使用光线步进来计算 <code>3D</code> 场景的 <code>SDF</code>: 相机与场景之间的正交距离场.
</p>

<p>
接下来会实现一个简单的 <code>RayMarching</code> 渲染器, 并逐步添加特性.
</p>
</div>
<ul class="org-ul">
<li><a id="org86e24e7"></a>基础 RayMarching: 计算相机到场景的符号距离场<br>
<div class="outline-text-5" id="text-org86e24e7">
<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> MAX_STEPS 100
<span style="color: #b0c4de;">#define</span> MAX_DIST 100.0
<span style="color: #b0c4de;">#define</span> SURF_DIST 0.01

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20860;&#23481; glslViewer &#21644; ShaderToy
</span><span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#endif</span>

<span style="color: #98fb98;">float</span> sphereRadius = 1.0;
<span style="color: #98fb98;">vec3</span> sphereCenter = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 6.0);

<span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">float</span> sphereDist = <span style="color: #b0c4de;">length</span>(p - sphereCenter) - sphereRadius;
  <span style="color: #98fb98;">float</span> groundDist = p.y;

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #00ffff;">return</span> d;
}

<span style="color: #98fb98;">float</span> RayMarch(<span style="color: #98fb98;">vec3</span> p0, <span style="color: #98fb98;">vec3</span> rd) {
  <span style="color: #98fb98;">float</span> dist = 0.0;

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; MAX_STEPS; i++) {
    <span style="color: #98fb98;">vec3</span> p = p0 + dist * rd;
    <span style="color: #98fb98;">float</span> d = sdfScene(p);
    dist += d;
    <span style="color: #00ffff;">if</span> (dist &gt; MAX_DIST || d &lt; SURF_DIST) <span style="color: #00ffff;">break</span>;
  }

  <span style="color: #00ffff;">return</span> dist;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 0.0);
  <span style="color: #98fb98;">vec3</span> rd = <span style="color: #b0c4de;">normalize</span>(<span style="color: #98fb98;">vec3</span>(uv, 1.0));
  <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);
  d /= 6.0;                     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36991;&#20813; d &#36807;&#22823;&#23548;&#33268;&#30011;&#38754;&#20840;&#30333;
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(d), 1.0);
}
</pre>
</div>


<div id="orgc1d4224" class="figure">
<p><img src="../../../files/3d-sdf-example.png" alt="3d-sdf-example.png" width="504px">
</p>
<p><span class="figure-number">Figure 32: </span>3D SDF 效果</p>
</div>

<p>
值得注意的是, 整个场景都是通过视点坐标去描述的, 为左手坐标系: \(x\) 轴往右为正, \(y\) 轴往上为正, \(z\) 轴往里为正.
</p>

<p>
可以通过改变 <code>sphereCenter</code> 以及 <code>cameraPos</code> 进行观察来得到该结论.
</p>
</div>
</li>
<li><a id="orge57a4d6"></a>简单光线<br>
<div class="outline-text-5" id="text-orge57a4d6">
<p>
在实现阴影前需要先实现一个简单光线效果: <code>Phong lighting model</code> 的 <code>diffuse</code> 光计算, 具体参考我的<a href="../../2020/08/graphics-opengl-light-and-material.html#phong-lighting-model-diffuse">另一篇笔记</a>.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> MAX_STEPS 100
<span style="color: #b0c4de;">#define</span> MAX_DIST 100.0
<span style="color: #b0c4de;">#define</span> SURF_DIST 0.01

<span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">float</span> u_time;

<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iTime u_time
<span style="color: #b0c4de;">#endif</span>

<span style="color: #98fb98;">float</span> sphereRadius = 1.0;
<span style="color: #98fb98;">vec3</span> sphereCenter = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 6.0);

<span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">float</span> sphereDist = <span style="color: #b0c4de;">length</span>(p - sphereCenter) - sphereRadius;
  <span style="color: #98fb98;">float</span> groundDist = p.y;

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #00ffff;">return</span> d;
}

<span style="color: #98fb98;">float</span> RayMarch(<span style="color: #98fb98;">vec3</span> p0, <span style="color: #98fb98;">vec3</span> rd) {
  <span style="color: #98fb98;">float</span> dist = 0.0;

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; MAX_STEPS; i++) {
    <span style="color: #98fb98;">vec3</span> p = p0 + dist * rd;
    <span style="color: #98fb98;">float</span> d = sdfScene(p);
    dist += d;
    <span style="color: #00ffff;">if</span> (dist &gt; MAX_DIST || d &lt; SURF_DIST) <span style="color: #00ffff;">break</span>;
  }

  <span style="color: #00ffff;">return</span> dist;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26032;&#22686;&#20989;&#25968; 1
</span><span style="color: #98fb98;">vec3</span> GetNormal(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20351;&#29992;&#20013;&#24515;&#24046;&#21830;&#27861;&#20272;&#31639; ScendSDF &#22312; p &#28857;&#19978;&#30340;&#27861;&#32447;&#21521;&#37327;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20854;&#20182;&#35745;&#31639;&#27861;&#32447;&#30340;&#26041;&#27861;: https://iquilezles.org/articles/normalsSDF/
</span>  <span style="color: #98fb98;">vec2</span> e = <span style="color: #98fb98;">vec2</span>(0.01, 0.0);
  <span style="color: #98fb98;">float</span> d = sdfScene(p);
  <span style="color: #98fb98;">vec3</span> n = d - <span style="color: #98fb98;">vec3</span>(sdfScene(p - e.xyy),
                    sdfScene(p - e.yxy),
                    sdfScene(p - e.yyx));
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">normalize</span>(n);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26032;&#22686;&#20989;&#25968; 2
</span><span style="color: #98fb98;">float</span> GetLight(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Phong lighting model - diffuse
</span>  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(<span style="color: #b0c4de;">cos</span>(iTime), 0.0, <span style="color: #b0c4de;">sin</span>(iTime),
                      0.0, 1.0, 0.0,
                      -<span style="color: #b0c4de;">sin</span>(iTime), 0.0, <span style="color: #b0c4de;">cos</span>(iTime));
  <span style="color: #98fb98;">vec3</span> lightPos = rotateY * <span style="color: #98fb98;">vec3</span>(0.0, 5.0, 6.0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#20809;&#28304;&#36827;&#34892;&#26059;&#36716;&#20197;&#20415;&#35266;&#23519;&#25928;&#26524;
</span>  <span style="color: #98fb98;">vec3</span> l = <span style="color: #b0c4de;">normalize</span>(lightPos - p);
  <span style="color: #98fb98;">vec3</span> n = GetNormal(p);
  <span style="color: #98fb98;">float</span> diffuse = <span style="color: #b0c4de;">clamp</span>(<span style="color: #b0c4de;">dot</span>(l, n), 0.0, 1.0);
  <span style="color: #00ffff;">return</span> diffuse;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 0.0);
  <span style="color: #98fb98;">vec3</span> rd = <span style="color: #b0c4de;">normalize</span>(<span style="color: #98fb98;">vec3</span>(uv, 1.0));
  <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35745;&#31639;&#22312;&#20132;&#28857;&#19978;&#21463;&#21040;&#30340;&#20809;&#29031;&#23556;
</span>  <span style="color: #98fb98;">vec3</span> p = cameraPos + d * rd;
  <span style="color: #98fb98;">float</span> diffuse = GetLight(p);

  d /= 6.0;                     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36991;&#20813; d &#36807;&#22823;&#23548;&#33268;&#30011;&#38754;&#20840;&#30333;
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(diffuse), 1.0);
}
</pre>
</div>


<div id="orge774abd" class="figure">
<p><img src="../../../files/3d-sdf-example-diffuse.png" alt="3d-sdf-example-diffuse.png" width="504px">
</p>
<p><span class="figure-number">Figure 33: </span>3D SDF 光照</p>
</div>
</div>
</li>
<li><a id="org98a6d80"></a>阴影实现<br>
<div class="outline-text-5" id="text-org98a6d80">
<p>
有了光线位置就可以计算阴影了,
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> MAX_STEPS 100
<span style="color: #b0c4de;">#define</span> MAX_DIST 100.0
<span style="color: #b0c4de;">#define</span> SURF_DIST 0.01

<span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">float</span> u_time;

<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iTime u_time
<span style="color: #b0c4de;">#endif</span>

<span style="color: #98fb98;">float</span> sphereRadius = 1.0;
<span style="color: #98fb98;">vec3</span> sphereCenter = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 6.0);

<span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">float</span> sphereDist = <span style="color: #b0c4de;">length</span>(p - sphereCenter) - sphereRadius;
  <span style="color: #98fb98;">float</span> groundDist = p.y;

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #00ffff;">return</span> d;
}

<span style="color: #98fb98;">float</span> RayMarch(<span style="color: #98fb98;">vec3</span> p0, <span style="color: #98fb98;">vec3</span> rd) {
  <span style="color: #98fb98;">float</span> dist = 0.0;

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; MAX_STEPS; i++) {
    <span style="color: #98fb98;">vec3</span> p = p0 + dist * rd;
    <span style="color: #98fb98;">float</span> d = sdfScene(p);
    dist += d;
    <span style="color: #00ffff;">if</span> (dist &gt; MAX_DIST || d &lt; SURF_DIST) <span style="color: #00ffff;">break</span>;
  }

  <span style="color: #00ffff;">return</span> dist;
}

<span style="color: #98fb98;">vec3</span> GetNormal(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20351;&#29992;&#20013;&#24515;&#24046;&#21830;&#27861;&#20272;&#31639; ScendSDF &#22312; p &#28857;&#19978;&#30340;&#27861;&#32447;&#21521;&#37327;
</span>  <span style="color: #98fb98;">vec2</span> e = <span style="color: #98fb98;">vec2</span>(0.01, 0.0);
  <span style="color: #98fb98;">float</span> d = sdfScene(p);
  <span style="color: #98fb98;">vec3</span> n = d - <span style="color: #98fb98;">vec3</span>(sdfScene(p - e.xyy),
                    sdfScene(p - e.yxy),
                    sdfScene(p - e.yyx));
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">normalize</span>(n);
}

<span style="color: #98fb98;">float</span> GetLight(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Phong lighting model - diffuse
</span>  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(<span style="color: #b0c4de;">cos</span>(iTime), 0.0, <span style="color: #b0c4de;">sin</span>(iTime),
                      0.0, 1.0, 0.0,
                      -<span style="color: #b0c4de;">sin</span>(iTime), 0.0, <span style="color: #b0c4de;">cos</span>(iTime));
  <span style="color: #98fb98;">vec3</span> lightPos = rotateY * <span style="color: #98fb98;">vec3</span>(0.0, 5.0, 6.0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#20809;&#28304;&#36827;&#34892;&#26059;&#36716;&#20197;&#20415;&#35266;&#23519;&#25928;&#26524;
</span>  <span style="color: #98fb98;">vec3</span> l = <span style="color: #b0c4de;">normalize</span>(lightPos - p);
  <span style="color: #98fb98;">vec3</span> n = GetNormal(p);
  <span style="color: #98fb98;">float</span> diffuse = <span style="color: #b0c4de;">clamp</span>(<span style="color: #b0c4de;">dot</span>(l, n), 0.0, 1.0);

  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
    &#20174;&#20132;&#28857; p &#19978;&#21521;&#20809;&#28304;&#21457;&#23556;&#19968;&#26465;&#38452;&#24433;&#23556;&#32447;: float d = RayMarch(p, l);

    &#26412;&#24212;&#35813;&#26159;&#36825;&#26679;&#30340;, &#20294;&#26681;&#25454; RayMarch &#20989;&#25968;&#30340;&#23454;&#29616;, p &#26412;&#26469;&#23601;&#26159;&#20132;&#28857;&#20102;, &#25152;&#20197;&#24490;&#29615;&#30340;&#31532;&#19968;&#36718;&#23601;&#22240;&#20026; d &lt; SURF_DIST &#34987;&#32456;&#27490;&#20102;,

    &#25152;&#20197;&#25105;&#20204;&#38656;&#35201;&#19968;&#20010;&#30456;&#23545; p &#28857;&#31245;&#24494;&#20559;&#31227;&#19968;&#28857;&#30340;&#28857;&#36991;&#20813;&#36825;&#31181;&#24773;&#20917;, &#21482;&#35201;&#20559;&#31227;&#30340;&#22320;&#26041;&#19981;&#26159;&#36827;&#20837;&#29289;&#20307;&#20869;, &#37027;&#20040;&#24448;&#20219;&#24847;&#26041;&#21521;&#20559;&#37117;&#21487;&#20197;
</span><span style="color: #ff7f24;">  */</span>
  <span style="color: #ff7f24;">//</span><span style="color: #ff7f24;">
</span>  <span style="color: #98fb98;">float</span> d = RayMarch(p + n * SURF_DIST * 2.0, l);
  <span style="color: #00ffff;">if</span> (d &lt; <span style="color: #b0c4de;">length</span>(p - lightPos)) {
    diffuse *= 0.1;
  }

  <span style="color: #00ffff;">return</span> diffuse;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 0.0);
  <span style="color: #98fb98;">vec3</span> rd = <span style="color: #b0c4de;">normalize</span>(<span style="color: #98fb98;">vec3</span>(uv, 1.0));
  <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35745;&#31639;&#22312;&#20132;&#28857;&#19978;&#21463;&#21040;&#30340;&#20809;&#29031;&#36752;&#23556;
</span>  <span style="color: #98fb98;">vec3</span> p = cameraPos + d * rd;
  <span style="color: #98fb98;">float</span> diffuse = GetLight(p);

  d /= 6.0;                     <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36991;&#20813; d &#36807;&#22823;&#23548;&#33268;&#30011;&#38754;&#20840;&#30333;
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(diffuse), 1.0);
}
</pre>
</div>


<div id="org00f164a" class="figure">
<p><img src="../../../files/3d-sdf-example-shadow.png" alt="3d-sdf-example-shadow.png" width="504px">
</p>
<p><span class="figure-number">Figure 34: </span>3D SDF 阴影</p>
</div>
</div>
</li>
<li><a id="org17d6cda"></a>动态计算射线方向以及伽马校正<br>
<div class="outline-text-5" id="text-org17d6cda">
<p>
目前相机的位置以及观察方向都是固定的, 观察方向是 \((0, 0, 1)\).
</p>

<p>
并且是在视点空间上的, 可以通过修改 <code>cameraPos</code> 来得到这个结论.
</p>

<p>
为了实现相机的控制, 需要先定义函数来构建变换, 实时计算得出视觉射线.
</p>

<p>
构建方式类似于 <a href="../../2020/06/graphics-opengl-transformation.html#from-world-to-view">从世界坐标系到视点坐标系的变换</a> 里面矩阵 \(M_{view}\) 的构建过程.
</p>

<p>
差别在于, 上述参考是从世界空间到视点空间的变换构建出来的, 这里是直接从视点空间进行构建.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21407;&#20195;&#30721;&#26469;&#33258;: https://www.shadertoy.com/view/3ssGWj
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36825;&#37324;&#23545;&#21407;&#20195;&#30721;&#36827;&#34892;&#20102;&#19968;&#20123;&#35843;&#25972;&#26469;&#25552;&#39640;&#21487;&#35835;&#24615;
</span><span style="color: #98fb98;">vec3</span> GetRayDirection(<span style="color: #98fb98;">vec2</span> uv, <span style="color: #98fb98;">vec3</span> cameraPos, <span style="color: #98fb98;">vec3</span> lookAtPos, <span style="color: #98fb98;">float</span> near) {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#26500;&#24314;&#35270;&#28857;&#22352;&#26631;&#31995;, &#36825;&#37324;&#21644;&#19978;&#38754;&#30340;&#21442;&#32771;&#26377;&#19968;&#20123;&#21306;&#21035;,

     &#22312;&#20110; GetRayDirection &#30340;&#21442;&#25968;&#37117;&#26159;&#35270;&#28857;&#22352;&#26631;&#31995;, &#25152;&#20197;&#22312;&#26500;&#24314;&#26102;&#29992;&#24038;&#25163;&#22352;&#26631;&#31995;&#26469;&#26500;&#24314;.
</span><span style="color: #ff7f24;">  */</span>
  <span style="color: #98fb98;">vec3</span> up = <span style="color: #98fb98;">vec3</span>(0, 1, 0),
    forward = lookAtPos - cameraPos,
    f = <span style="color: #b0c4de;">normalize</span>(forward),
    right = <span style="color: #b0c4de;">cross</span>(up, forward),
    r = <span style="color: #b0c4de;">normalize</span>(right),
    u = <span style="color: #b0c4de;">cross</span>(f, r);
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#22240;&#20026; f &#21644; r &#37117;&#26159;&#21333;&#20301;&#21521;&#37327;&#19988;&#30456;&#20114;&#22402;&#30452;,
     u &#21487;&#20197;&#30475;&#20316;&#26159; f &#22260;&#32469; r &#25110; r &#22260;&#32469; f &#26059;&#36716; 90 &#24230;&#21040;&#36798;&#30340;&#26041;&#21521;,
     &#25152;&#20197; u &#26080;&#38656;&#20877; normalize</span><span style="color: #ff7f24;"> */</span>
  <span style="color: #98fb98;">vec3</span> nearPlaneCenter = cameraPos + f * near; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36817;&#35009;&#21098;&#24179;&#38754;&#30340;&#20013;&#24515;&#20301;&#32622;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">uv &#26159;&#35813;&#24179;&#38754;&#19978;&#30340; NDC &#22352;&#26631;, &#38656;&#35201;&#36716;&#25442;&#21040;&#35270;&#35273;&#22352;&#26631;&#31995;&#31354;&#38388;&#19978;
</span>  <span style="color: #98fb98;">vec3</span> p = nearPlaneCenter + uv.x * r + uv.y * u;
  <span style="color: #98fb98;">vec3</span> rd = <span style="color: #b0c4de;">normalize</span>(p - cameraPos);
  <span style="color: #00ffff;">return</span> rd;
}

<span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 0.0);
  <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, cameraPos + <span style="color: #98fb98;">vec3</span>(0.0, 0.0, 1.0), 0.5);
  <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #00ffff;">if</span> (d &lt; MAX_DIST) {           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26377;&#21487;&#33021;&#20250;&#36229;&#20986; MAX_DIST
</span>    <span style="color: #98fb98;">vec3</span> p = cameraPos + d * rd;
    <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
    col = <span style="color: #98fb98;">vec3</span>(diffuse);
  }

  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545)); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Gamma correction: [0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>

<p>
参数 \(near\) 对应着镜头的焦距, 焦距越长, \(fov\) 越小; 反之, 焦距越短, \(fov\) 越大.
</p>

<p>
换而言之, \(near\) 可以间接控制 \(fov\).
</p>

<p>
另外, 在最后的颜色输出阶段进行了调整, 这项调整被称为伽马校正(<code>gamma correction</code>). 伽马校正是最容易被人忽视的环节.
</p>

<p>
<code>Shader</code> 程序一般以线性 <code>RGB</code> (<code>linear RGB</code>)编码像素, 即像素值代表作物理光强度, 且成线性正比关系.
</p>

<p>
但像素值在显示器是被解析为电压值, 并且电压值和物理光强度成非线性关系, 比如 2 倍电压不代表 2 倍物理光强度.
</p>

<p>
电压值和物理光强度之间为幂函数关系: \(y = x^{\gamma_{\text{monitor}}}\), 称为伽马曲线(<code>gamma curve</code>),
</p>

<p>
每个显示器的 \(\gamma_{\text{monitor}}\) 都不一样, 导致它们曲线也不一样, 通常以 \(\gamma_{\text{monitor}} = 2.2\) 作为基准.
</p>

<p>
纹理和图片通常以 \((x_{\text{linear}})^{2.2}\) 方式储存像素, 其中 \(x_{\text{linear}}\) 是线性 <code>RGB</code> 编码的像素,
</p>

<p>
这种编码方案被称为标准 <code>RGB</code> (<code>sRGB/standard RGB</code>), 所以图片一般是什么颜色, 它在屏幕上显示的就是什么颜色.
</p>

<p>
但对于 <code>Shader</code> 来说就不一样了, 把 \(x_{\text{linear}}\) 直接输出到屏幕上, 最终色彩 \((x_{\text{linear}})^{\gamma_{\text{monitor}}}\) 就会偏暗.
</p>

<p>
为了输出原本颜色 \(x_{\text{linear}}\), 在被输出到显示器前要根据 \(\gamma_{\text{monitor}}\) 进行校正: \(x^{\gamma_{\text{correction}}}\), 其中 \(\gamma_{\text{correction}} = \frac{1}{\gamma_{\text{monitor}}}\).
</p>

<p>
这样在像素输出到浏览器时的色彩为: \([(x_{\text{linear}})^{\gamma_{\text{correction}}}]^{\gamma_{\text{monitor}}} = x_{\text{linear}}\).
</p>

<p>
这个处理过程被称为伽马校正(<code>gamma correction</code>).
</p>


<div id="orge95f43f" class="figure">
<p><img src="../../../files/1-gamma.svg" alt="1-gamma.svg" class="org-svg" width="504px">
</p>
</div>

<p>
代码中的 <code>.4545</code> 就是 \(\frac{1}{2.2}\).
</p>

<p>
有些渲染引擎会在输出画面前在内部对像素进行一次标准 <code>RGB</code> 编码, 因为它们默认开发者操作的是线性 <code>RGB</code>,
</p>

<p>
但这容易出现一个问题: 如果输出贴图的像素作为画面, 那么显示画面就会变暗, 这是因为贴图通常以标准 <code>RGB</code> 编码.
</p>

<p>
这种情况需要注意进行伽马校正.
</p>
</div>
</li>
<li><a id="org948a463"></a>使用鼠标控制相机<br>
<div class="outline-text-5" id="text-org948a463">
<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec2</span> uv = (2.0 * <span style="color: #eedd82;">gl_FragCoord</span>.xy - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 4.0, -5.0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#37325;&#26032;&#35774;&#32622;&#20102;&#30456;&#26426;&#20301;&#32622;
</span>
  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">iMouse &#25152;&#22788;&#30340;&#22352;&#26631;&#31995;&#20063;&#26159;&#24038;&#19979;&#35282;&#20026;&#21407;&#28857;, &#24448;&#21491;&#36793;&#20026; x+, &#24448;&#19978;&#20026; y+
</span>
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#40736;&#26631;&#19978;&#31227;&#26102;, &#30456;&#26426;&#24448;&#19978;&#25260;
</span>  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#40736;&#26631;&#24038;&#31227;&#26102;, &#38236;&#22836;&#24038;&#36716;
</span>  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#40736;&#26631;&#21160;&#20316;&#25152;&#23545;&#24212;&#30340;&#21464;&#25442;&#19981;&#19968;&#23450;&#35201;&#21644;&#36825;&#37324;&#19968;&#26679;,

     &#20320;&#21487;&#20197;&#40736;&#26631;&#19979;&#31227;, &#30456;&#26426;&#24448;&#19978;&#25260;, &#21482;&#38656;&#35201;&#25226;&#36825;&#20040;&#23450;&#20041;&#21363;&#21487;:

     float sX = sin(-m.y + 0.5);
     float cX = cos(-m.y + 0.5);

     &#20320;&#21487;&#20197;&#40736;&#26631;&#24038;&#31227;, &#30456;&#26426;&#24448;&#21491;&#36716;, &#21482;&#38656;&#35201;&#25226;&#36825;&#20040;&#23450;&#20041;&#21363;&#21487;:

     float sY = sin(-m.x * 6.2831);
     float cY = cos(-m.x * 6.2831);
</span><span style="color: #ff7f24;">   */</span>

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30456;&#26426;&#21464;&#25442;&#26159;&#29289;&#20307;&#21464;&#25442;
</span>
  <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 3.0, 0.0), 2.0); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#37325;&#26032;&#35774;&#32622;&#20102; lookAtPos, &#20197;&#21450; near
</span>  <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #00ffff;">if</span> (d &lt; MAX_DIST) {           <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26377;&#21487;&#33021;&#20250;&#36229;&#20986; MAX_DIST
</span>    <span style="color: #98fb98;">vec3</span> p = cameraPos + d * rd;
    <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
    col = <span style="color: #98fb98;">vec3</span>(diffuse);
  }

  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545)); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Gamma correction: [0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>
</div>
</li>
<li><a id="orgf1b0dd9"></a>代码结构优化<br>
<div class="outline-text-5" id="text-orgf1b0dd9">
<p>
一旦场景复杂起来, 描述场景的函数 <code>sdfScene</code> 就会难以阅读, 为了让 <code>sdfScene</code> 的结构清晰, 可把物体给封装起来,
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29699;&#20307; SDF
</span><span style="color: #98fb98;">float</span> sdfSphere (<span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">float</span> radius) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(p) - radius;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22320;&#38754; SDF
</span><span style="color: #98fb98;">float</span> sdfGround (<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #00ffff;">return</span> p.y;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">sdfScene &#23601;&#26159;&#33719;&#21462;&#36317;&#31163; p &#28857;&#26368;&#30701;&#30340;&#27491;&#20132;&#36317;&#31163;
</span><span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">float</span> sphereDist = sdfSphere(p - sphereCenter, sphereRadius);
  <span style="color: #98fb98;">float</span> groundDist = sdfGround(p);

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #00ffff;">return</span> d;
}
</pre>
</div>
</div>
</li>
<li><a id="org8c1c1c8"></a>抗锯齿 (Anti-Aliasing)<br>
<div class="outline-text-5" id="text-org8c1c1c8">
<p>
锯齿的本质就是像素之间的变化缺乏连续性, 把连续对象转换成离散对象是造成连续性缺失的原因.
</p>

<p>
比如一个像素的颜色为红色, 相邻像素的颜色为蓝色, 两者之间没有一个过渡, 导致看起来很突兀.
</p>

<p>
下面使用 <a href="https://en.wikipedia.org/wiki/Box_blur">盒状模糊</a> 对像素的颜色进行重新计算, 让像素之间的变换更加平滑, 从而实现抗锯齿:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">void</span> main() {
  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0.0, 4.0, 5.0);

  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy;
  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">AA
</span>  <span style="color: #98fb98;">float</span> AASize = 3.0;
  <span style="color: #98fb98;">float</span> rAASize = 1.0 / AASize;
  <span style="color: #98fb98;">int</span> count = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaY = -1; aaY &lt;= 1; aaY++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaX = -1; aaX &lt;= 1; aaX++) {
      <span style="color: #98fb98;">vec2</span> coord = <span style="color: #eedd82;">gl_FragCoord</span>.xy + <span style="color: #98fb98;">vec2</span>(aaX, aaY) * rAASize;
      <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#22914;&#26524; AASize = 1, &#37027;&#20040;&#23601;&#30456;&#24403;&#20110;&#25226;&#24403;&#21069;&#20687;&#32032;&#21608;&#22260;&#30340; 8 &#20010;&#20687;&#32032;&#39068;&#33394;&#28151;&#21512;, &#20351;&#24471;&#22270;&#20687;&#36807;&#24230;&#27169;&#31946;,
         &#25152;&#20197; AASize &#38656;&#35201;&#36866;&#24403;&#22823;&#23567;
</span><span style="color: #ff7f24;">       */</span>
      <span style="color: #98fb98;">vec2</span> uv = (2.0 * coord - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
      <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 3.0, 0.0), 0.5);
      <span style="color: #98fb98;">float</span> d = RayMarch(cameraPos, rd);
      <span style="color: #00ffff;">if</span> (d &lt; MAX_DIST) {
        <span style="color: #98fb98;">vec3</span> p = cameraPos + d * rd;
        <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
        col += <span style="color: #98fb98;">vec3</span>(diffuse);
      }
      count++;
    }
  }
  col /= count;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">AA ends here
</span>
  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545)); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Gamma correction: [0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>

<p>
当然, 抗锯齿会严重影响渲染效率, 效率和效果一直都要进行取舍.
</p>
</div>
</li>
<li><a id="org58253e8"></a>无 UV 贴图映射 (Texture Mapping without UVs)<br>
<div class="outline-text-5" id="text-org58253e8">
<p>
<code>RayMarching</code> 渲染器中不存在顶点数据, 也不存在与顶点关联的纹理坐标.
</p>

<p>
即便是光栅渲染器, 也有存在顶点数据当不存在纹理坐标的情况, 需要根据顶点数据计算出纹理坐标.
</p>

<p>
如何计算顶点数据取决于具体的几何体以及想要如何映射.
</p>

<p>
教材 <a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals Of Computer Graphics, 4th, 11.2.1 Geometrically Determined Coordinates</a> 中提供了简单几何体的贴图映射算法.
</p>

<p>
最简单贴图映射算法莫过于平面映射(<code>Planar Mapping</code>): 直接让贴图往几何体的一个侧面进行正交投影.
</p>


<div id="org8475ad3" class="figure">
<p><img src="../../../files/planar-mapping.png" alt="planar-mapping.png">
</p>
</div>

<p>
如果从右侧(\(X\) 轴方向)进行投影, 以顶点坐标的 \(yz\) 分量作为 \(uv\);
</p>

<p>
如果从顶部(\(Y\) 轴方向)进行投影, 以顶点坐标的 \(xz\) 分量作为 \(uv\);
</p>

<p>
如果从正面(\(Z\) 轴方向)进行投影, 以顶点坐标的 \(xy\) 分量作为 \(uv\).
</p>

<p>
这种映射算法适用于只展示几何体单面的情况, 几何体的其它面会有严重的拉伸和形变.
</p>

<p>
想要解决其它面的拉伸和形变问题, 有很多种方案, 比如很多人第一个想到的就是 <code>3D</code> 贴图,
</p>

<p>
<code>3D</code> 贴图也无需 <code>UV</code> 映射, 直接根据顶点坐标进行采样, 不过会占用更高的内存.
</p>

<p>
因此, 人们想到了一种比 <code>3D</code> 贴图更低消耗的映射方法: 三平面映射(<code>Triplanar Mapping</code>), 它是平面映射的高阶版本:
</p>

<p>
对几何体的顶点 \((x, y, z)\) 分别在 \(XYZ\) 三轴进行正交投影, 分别读取对应的纹理: \(tex_{x}\), \(tex_{y}\) 和 \(tex_{z}\), 以某种权重进行求和, 求和结果就作为该顶点的纹理.
</p>


<div id="org979fda6" class="figure">
<p><img src="../../../files/TriplanarMapping.png" alt="TriplanarMapping.png">
</p>
<p><span class="figure-number">Figure 35: </span>三平面映射, 图片来源: <a href="https://docs.otoy.com">https://docs.otoy.com</a></p>
</div>

<p>
最简单的权重分配就是求平均值: \((tex_{x} + tex_{y} + tex_{z}) / 3\).
</p>

<p>
显然平均值不太准确, 最正式做法应该是根据顶点的法线向量进行权重分配, 正好多元函数的法线向量本质上是梯度向量, 梯度向量由每个坐标轴上的偏导数(变化率)构成.
</p>

<p>
具体做法:
</p>

<ol class="org-ol">
<li>把三个纹理组合成矩阵 \(M = \left( \begin{array}{c} tex_{x} \\ tex_{y} \\ tex_{z} \end{array} \right)\),</li>
<li>以法线向量 \(n\) 的绝对值 \(abs(n)\) 作为权重, 计算 \(M \cdot abs(n)\), 计算结果作为顶点的纹理.</li>
</ol>


<p>
以下是具体代码:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec3</span> TriplanarMap(<span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">vec3</span> normal, <span style="color: #98fb98;">sampler2D</span> tex) {
  <span style="color: #98fb98;">mat3</span> triMapSamples = <span style="color: #98fb98;">mat3</span>(<span style="color: #b0c4de;">texture</span>(tex, p.yz).rgb,
                            <span style="color: #b0c4de;">texture</span>(tex, p.xz).rgb,
                            <span style="color: #b0c4de;">texture</span>(tex, p.xy).rgb);
  <span style="color: #00ffff;">return</span> triMapSamples * <span style="color: #b0c4de;">abs</span>(normal);
}
</pre>
</div>

<p>
接下来会为球体进行贴图, 还需要形成一套为每个不同对象赋予不同贴图的逻辑,
</p>

<p>
比如说, 在判断到射线与物体发生相交后, 除了获得相交距离, 还需要知道物体对应哪个贴图.
</p>

<p>
为了实现这套逻辑, 整个程序需要进行大幅度的调整, 所以这里贴出整个程序的代码:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#define</span> MAX_STEPS 100
<span style="color: #b0c4de;">#define</span> MAX_DIST 100.0
<span style="color: #b0c4de;">#define</span> SURF_DIST 0.01
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;1: &#23450;&#20041;&#31354;&#26448;&#36136;ID
</span><span style="color: #b0c4de;">#define</span> MATERIAL_NULL 0

<span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">float</span> u_time;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_mouse;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_tex0;       <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29992;&#20110;&#29699;&#20307;&#30340;&#36148;&#22270;
</span>
<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iTime u_time
<span style="color: #b0c4de;">#define</span> iMouse u_mouse
<span style="color: #b0c4de;">#define</span> iChannel0 u_tex0
<span style="color: #b0c4de;">#endif</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;2: &#23450;&#20041;&#32467;&#26500;&#20307;&#20197;&#35760;&#24405;&#20132;&#28857;&#20449;&#24687;
</span><span style="color: #00ffff;">struct</span> Intersection {
  <span style="color: #98fb98;">float</span> dist;                   <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">signed distance
</span>  <span style="color: #98fb98;">int</span> matID;                    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26448;&#36136; ID
</span>};

<span style="color: #98fb98;">float</span> sphereRadius = 1.0;
<span style="color: #98fb98;">vec3</span> sphereCenter = <span style="color: #98fb98;">vec3</span>(0.0, 1.0, 6.0);

<span style="color: #98fb98;">float</span> sdfRoundCone( <span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">float</span> r1, <span style="color: #98fb98;">float</span> r2, <span style="color: #98fb98;">float</span> h )
{
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">sampling independent computations (only depend on shape)
</span>  <span style="color: #98fb98;">float</span> b = (r1-r2)/h;
  <span style="color: #98fb98;">float</span> a = <span style="color: #b0c4de;">sqrt</span>(1.0-b*b);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">sampling dependant computations
</span>  <span style="color: #98fb98;">vec2</span> q = <span style="color: #98fb98;">vec2</span>( <span style="color: #b0c4de;">length</span>(p.xz), p.y );
  <span style="color: #98fb98;">float</span> k = <span style="color: #b0c4de;">dot</span>(q,<span style="color: #98fb98;">vec2</span>(-b,a));
  <span style="color: #00ffff;">if</span>( k&lt;0.0 ) <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(q) - r1;
  <span style="color: #00ffff;">if</span>( k&gt;a*h ) <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(q-<span style="color: #98fb98;">vec2</span>(0.0,h)) - r2;
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">dot</span>(q, <span style="color: #98fb98;">vec2</span>(a,b) ) - r1;
}

<span style="color: #98fb98;">float</span> sdfSphere (<span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">float</span> radius) {
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">length</span>(p) - radius;
}

<span style="color: #98fb98;">float</span> sdfGround (<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #00ffff;">return</span> p.y;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;3: &#23450;&#20041;&#24182;&#38598;&#36816;&#31639;&#31526;, &#20197;&#26041;&#20415;&#36820;&#22238; Intersection &#31867;&#22411;
</span>Intersection opU(Intersection a, Intersection b) {
  <span style="color: #00ffff;">return</span> a.dist &lt; b.dist ? a: b;
}

Intersection sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  Intersection sphere = Intersection(sdfSphere(p - sphereCenter, sphereRadius), 1);
  Intersection ground = Intersection(sdfGround(p), 2);
  <span style="color: #00ffff;">return</span> opU(sphere, ground);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;4: &#20462;&#25913;&#36820;&#22238;&#20540;&#31867;&#22411;
</span>Intersection RayMarch(<span style="color: #98fb98;">vec3</span> p0, <span style="color: #98fb98;">vec3</span> rd) {
  Intersection result = Intersection(0.0, MATERIAL_NULL);

  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; MAX_STEPS; i++) {
    <span style="color: #98fb98;">vec3</span> p = p0 + result.dist * rd;
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;5: &#26356;&#26032;&#20132;&#28857;&#35760;&#24405;
</span>    Intersection d = sdfScene(p);
    result.dist += d.dist;
    result.matID = d.matID;
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;6: &#35835;&#21462; dist &#23383;&#27573;
</span>    <span style="color: #00ffff;">if</span> (result.dist &gt; MAX_DIST || d.dist &lt; SURF_DIST) <span style="color: #00ffff;">break</span>;
  }

  <span style="color: #00ffff;">return</span> result;
}

<span style="color: #98fb98;">vec3</span> GetNormal(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">vec2</span> e = <span style="color: #98fb98;">vec2</span>(0.01, 0.0);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;7: &#20462;&#25913;&#36820;&#22238;&#20540;&#31867;&#22411;
</span>  Intersection d = sdfScene(p);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;8: &#35835;&#21462; dist &#23383;&#27573;
</span>  <span style="color: #98fb98;">vec3</span> n = d.dist - <span style="color: #98fb98;">vec3</span>(sdfScene(p - e.xyy).dist,
                         sdfScene(p - e.yxy).dist,
                         sdfScene(p - e.yyx).dist);
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">normalize</span>(n);
}

<span style="color: #98fb98;">float</span> GetLight(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(<span style="color: #b0c4de;">cos</span>(iTime), 0.0, <span style="color: #b0c4de;">sin</span>(iTime),
                      0.0, 1.0, 0.0,
                      -<span style="color: #b0c4de;">sin</span>(iTime), 0.0, <span style="color: #b0c4de;">cos</span>(iTime));
  <span style="color: #98fb98;">vec3</span> lightPos = rotateY * <span style="color: #98fb98;">vec3</span>(0.0, 5.0, 6.0);

  <span style="color: #98fb98;">vec3</span> l = <span style="color: #b0c4de;">normalize</span>(lightPos - p);
  <span style="color: #98fb98;">vec3</span> n = GetNormal(p);

  <span style="color: #98fb98;">float</span> diffuse = <span style="color: #b0c4de;">clamp</span>(<span style="color: #b0c4de;">dot</span>(l, n), 0.0, 1.0);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;9: &#20462;&#25913;&#36820;&#22238;&#20540;&#31867;&#22411;
</span>  Intersection d = RayMarch(p + n * SURF_DIST * 2.0, l);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;10: &#35835;&#21462; dist &#23383;&#27573;
</span>  <span style="color: #00ffff;">if</span> (d.dist &lt; <span style="color: #b0c4de;">length</span>(p - lightPos)) {
    diffuse *= 0.1;
  }

  <span style="color: #00ffff;">return</span> diffuse;
}

<span style="color: #98fb98;">vec3</span> GetRayDirection(<span style="color: #98fb98;">vec2</span> uv, <span style="color: #98fb98;">vec3</span> cameraPos, <span style="color: #98fb98;">vec3</span> lookAtPos, <span style="color: #98fb98;">float</span> near) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26500;&#24314;&#35270;&#28857;&#22352;&#26631;&#31995;, &#26159;&#24038;&#25163;&#22352;&#26631;&#31995;
</span>  <span style="color: #98fb98;">vec3</span> up = <span style="color: #98fb98;">vec3</span>(0, 1, 0),
    forward = lookAtPos - cameraPos,
    f = <span style="color: #b0c4de;">normalize</span>(forward),
    right = <span style="color: #b0c4de;">cross</span>(up, forward),
    r = <span style="color: #b0c4de;">normalize</span>(right),
    u = <span style="color: #b0c4de;">cross</span>(f, r);
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#22240;&#20026; f &#21644; r &#37117;&#26159;&#21333;&#20301;&#21521;&#37327;&#19988;&#30456;&#20114;&#22402;&#30452;,
     f &#26059;&#36716;&#21040; r &#26102;&#26159;&#22260;&#32469; Y+ &#20197;&#39034;&#26102;&#38024;&#26041;&#21521;&#26059;&#36716; 90 &#24230;&#21040;&#36798;&#30340;,
     &#25152;&#20197; u &#26080;&#38656;&#20877; normalize</span><span style="color: #ff7f24;"> */</span>
  <span style="color: #98fb98;">vec3</span> nearPlaneCenter = cameraPos + f * near; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36817;&#35009;&#21098;&#24179;&#38754;&#30340;&#20013;&#24515;&#20301;&#32622;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">uv &#26159;&#35813;&#24179;&#38754;&#19978;&#30340; NDC &#22352;&#26631;, &#38656;&#35201;&#36716;&#25442;&#21040; 3D &#31354;&#38388;&#19978;&#30340;&#22352;&#26631;
</span>  <span style="color: #98fb98;">vec3</span> p = nearPlaneCenter + uv.x * r + uv.y * u;
  <span style="color: #98fb98;">vec3</span> rd = <span style="color: #b0c4de;">normalize</span>(p - cameraPos);
  <span style="color: #00ffff;">return</span> rd;
}

<span style="color: #98fb98;">vec3</span> TriplanarMap(<span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">vec3</span> normal, <span style="color: #98fb98;">sampler2D</span> tex) {
  <span style="color: #98fb98;">mat3</span> triMapSamples = <span style="color: #98fb98;">mat3</span>(<span style="color: #b0c4de;">texture</span>(tex, p.yz).rgb,
                            <span style="color: #b0c4de;">texture</span>(tex, p.xz).rgb,
                            <span style="color: #b0c4de;">texture</span>(tex, p.xy).rgb);
  <span style="color: #00ffff;">return</span> triMapSamples * <span style="color: #b0c4de;">abs</span>(normal);
}

<span style="color: #98fb98;">void</span> main() {

  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0., 1.0, 5.);

  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy;
  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #98fb98;">float</span> AA_size = 3.0;
  <span style="color: #98fb98;">int</span> count = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaY = -1; aaY &lt;= 1; aaY++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaX = -1; aaX &lt;= 1; aaX++) {
      <span style="color: #98fb98;">vec2</span> coord = <span style="color: #eedd82;">gl_FragCoord</span>.xy + <span style="color: #98fb98;">vec2</span>(aaX, aaY) / AA_size;
      <span style="color: #98fb98;">vec2</span> uv = (2.0 * coord - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
      <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 0.0, 1.0), 2.0);
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;11: &#20462;&#25913;&#36820;&#22238;&#20540;&#31867;&#22411;
</span>      Intersection d = RayMarch(cameraPos, rd);
      <span style="color: #00ffff;">if</span> (d.dist &lt; MAX_DIST) {
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;12: &#35835;&#21462; dist &#23383;&#27573;
</span>        <span style="color: #98fb98;">vec3</span> p = cameraPos + d.dist * rd;
        <span style="color: #98fb98;">vec3</span> n = GetNormal(p);
        <span style="color: #98fb98;">vec3</span> tex = <span style="color: #98fb98;">vec3</span>(1.0);
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;13: &#36890;&#36807; matID &#23383;&#27573;&#21028;&#26029;&#23556;&#32447;&#30456;&#20132;&#30340;&#23545;&#35937;, &#20026;&#23545;&#24212;&#23545;&#35937;&#36827;&#34892;&#36148;&#22270;&#26144;&#23556;
</span>        <span style="color: #00ffff;">if</span> (1 == d.matID) {
          tex = TriplanarMap(p, n, iChannel0);
        }
        <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
        col += <span style="color: #98fb98;">vec3</span>(tex * diffuse);
      }
      count++;
    }
  }
  col /= count;
  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545));  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Gamma correction: [0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>


<div id="orgf1a9616" class="figure">
<p><img src="../../../files/raymarching-tirplanar-mapping.png" alt="raymarching-tirplanar-mapping.png" width="504px">
</p>
</div>
</div>
</li>
<li><a id="orga484c6f"></a>天空盒 (Skybox)<br>
<div class="outline-text-5" id="text-orga484c6f">
<p>
没有与任何物体相交的地方就是天空.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">void</span> main() {

  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0., 1.0, 5.);

  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy;
  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #98fb98;">float</span> AA_size = 3.0;
  <span style="color: #98fb98;">int</span> count = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaY = -1; aaY &lt;= 1; aaY++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaX = -1; aaX &lt;= 1; aaX++) {
      <span style="color: #98fb98;">vec2</span> coord = <span style="color: #eedd82;">gl_FragCoord</span>.xy + <span style="color: #98fb98;">vec2</span>(aaX, aaY) / AA_size;
      <span style="color: #98fb98;">vec2</span> uv = (2.0 * coord - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
      <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 0.0, 1.0), 2.0);
      Intersection d = RayMarch(cameraPos, rd);
      <span style="color: #00ffff;">if</span> (d.dist &lt; MAX_DIST) {
        <span style="color: #98fb98;">vec3</span> p = cameraPos + d.dist * rd;
        <span style="color: #98fb98;">vec3</span> n = GetNormal(p);
        <span style="color: #98fb98;">vec3</span> tex = <span style="color: #98fb98;">vec3</span>(1.0);
        <span style="color: #00ffff;">if</span> (1 == d.matID) {
          tex = TriplanarMap(p, n, iChannel0);
        }
        <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
        col += <span style="color: #98fb98;">vec3</span>(tex * diffuse);
      } <span style="color: #00ffff;">else</span> {
        <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22825;&#31354;&#30418;&#23601;&#26159;&#27809;&#26377;&#19982;&#23556;&#32447;&#21629;&#20013;&#30340;&#24773;&#20917;
</span>        col = <span style="color: #98fb98;">vec3</span>(0.3, 0.36, 0.6) - (rd.y * 0.4);
      }
      count++;
    }
  }
  col /= count;
  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545)); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Gamma correction: [0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>
</div>
</li>
<li><a id="org751ad18"></a>雾体 (Fog)<br>
<div class="outline-text-5" id="text-org751ad18">
<p>
雾体效果的实现方式并不固定, 每个人都可以自行建立雾体的模型, 对于初学者而言, 可以参考 <a href="https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/glFog.xml">glFog</a> 里面的 <code>GL_EXP</code> 模式的雾体.
</p>

<blockquote>
<p>
需要注意, 文档里面的公式排版有一些错误, 因此对公式进行了一些调整.
</p>
</blockquote>

<p>
首先是雾体指数的计算: \(f = e^{-\mathrm{density} \cdot d}\),
</p>

<p>
其中 \(d\) 是顶点的视点坐标的 \(z\) 分量, 换句话就是视野距离; \(\mathrm{density}\) 是雾的密度;
</p>

<p>
使用 \(C_{f}\) 表示雾体颜色, \(C_{r}\) 表示当前片元颜色, 再根据雾体指数对 \(C_{f}\) 和 \(C_{r}\) 进行混合,
</p>

<p>
视野距离越大, 就越接近雾体颜色, \(f\) 是一个随着 \(d\) 增加而减少的函数, 对它"取反": \(F(d) = 1 - f(d)\).
</p>

<p>
\(C_{r} \times (1 - F) + F \times C_{f} = C_{r} \times f + (1 - f) \times C_{f}\).
</p>

<p>
具体实现如下:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">vec3</span> applyFog(<span style="color: #98fb98;">vec3</span> fragColor, <span style="color: #98fb98;">vec3</span> fogColor, <span style="color: #98fb98;">float</span> d, <span style="color: #98fb98;">float</span> start, <span style="color: #98fb98;">float</span> density) {
  <span style="color: #98fb98;">float</span> fogExp = <span style="color: #b0c4de;">exp</span>(-(d - start) * density);
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #b0c4de;">mix</span>(fogColor, fragColor, fogExp);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25110;&#32773;
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">float fogExp = 1.0 - exp(-d * density);
</span>  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">vec3 col = mix(fragColor, fogColor, fogExp);
</span>  <span style="color: #00ffff;">return</span> col;
}

<span style="color: #98fb98;">void</span> main() {

  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0., 4.0, 3.0);

  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy;
  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #98fb98;">float</span> AA_size = 3.0;
  <span style="color: #98fb98;">int</span> count = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaY = -1; aaY &lt;= 1; aaY++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaX = -1; aaX &lt;= 1; aaX++) {
      <span style="color: #98fb98;">vec2</span> coord = <span style="color: #eedd82;">gl_FragCoord</span>.xy + <span style="color: #98fb98;">vec2</span>(aaX, aaY) / AA_size;
      <span style="color: #98fb98;">vec2</span> uv = (2.0 * coord - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
      <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 4.0, 0.0), 2.0);
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;1: &#25226;&#20132;&#28857;&#35745;&#31639;&#25343;&#20986;&#26469;
</span>      Intersection d = RayMarch(cameraPos, rd);
      <span style="color: #98fb98;">vec3</span> p = cameraPos + d.dist * rd;
      <span style="color: #00ffff;">if</span> (d.dist &lt; MAX_DIST) {
        <span style="color: #98fb98;">vec3</span> n = GetNormal(p);
        <span style="color: #98fb98;">vec3</span> tex = <span style="color: #98fb98;">vec3</span>(1.0);
        <span style="color: #00ffff;">if</span> (1 == d.matID) {
          tex = TriplanarMap(p, n, iChannel0);
        }
        <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
        col += <span style="color: #98fb98;">vec3</span>(tex * diffuse);
      } <span style="color: #00ffff;">else</span> {
        col = <span style="color: #98fb98;">vec3</span>(0.3, 0.36, 0.6) - (rd.y * 0.4);
      }
      <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35843;&#25972;2: &#36827;&#34892;&#38654;&#20307;&#35745;&#31639;
</span>      col = applyFog(col, <span style="color: #98fb98;">vec3</span>(1., 1., 1.), p.z, 8.0, 1.0 / 80.0);
      count++;
    }
  }
  col /= count;
  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545));  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>

<p>
例子中球体在原本的位置受雾体的影响不是很大, 可以把球体设置得远一点观察效果.
</p>
</div>
</li>
<li><a id="org82b7d1e"></a>环境光遮蔽 (Ambient Occlusion)<br>
<div class="outline-text-5" id="text-org82b7d1e">
<p>
环境光遮蔽用来光线在物体之间相互遮挡产生的阴影效果, 简称 <code>AO</code>.
</p>

<p>
在 <code>RayMarching</code> 渲染器中, 通常采用 <a href="https://advances.realtimerendering.com/s2006/Chapter9-Fast_Approximations_for_Global_Illumination_on_Dynamic_Scenes.pdf">Alex Evans</a> 的算法来实现 <code>AO</code>.
</p>

<p>
为了理解这套算法, 需要了解在 <code>RayMarching</code> 渲染器中如何判断物体自身或物体之间是否存在遮蔽.
</p>

<p>
原理很简单, 主要是利用了 <code>RayMarching</code> 渲染器的设计. 观察下图,
</p>


<div id="org0651997" class="figure">
<p><img src="../../../files/calc-occlusion.png" alt="calc-occlusion.png">
</p>
</div>

<p>
其中 \(P\) 点为视觉射线与地面的交点, \(N\) 为地面在 \(P\) 点上的法线向量,
</p>

<p>
\(Q\) 是射线从 \(P\) 点出发移动距离 \(d\) 后所到达的点: \(Q = P + d \cdot N\).
</p>

<p>
左图只有地面, 右图有地面和物体 \(O\).
</p>

<p>
在左图中, \(Q\) 在场景中的距离场 (\(\mathrm{sdfScene}(P + d \cdot N)\)) 远远大于 0;
</p>

<p>
在右图中, \(Q\) 在场景中的距离场非常接近 0.
</p>

<p>
换而言之, 在 \(Q\) 沿着交点 \(P\) 的法线方向 \(N\) 移动距离 \(d\) 时,
</p>

<p>
如果 \(Q\) 的距离场接近于 0 且 \(d\) 非常小, 那么可以断言 \(P\) 被遮蔽了.
</p>

<p>
在拥有判断是否遮蔽的方法后, 就得思考如何确定遮蔽的程度.
</p>

<p>
再仔细思考可以发现以下规律:
</p>

<p>
在没有遮蔽️物的情况下, \(Q\) 的距离场就等于 \(d\): \(d - \mathrm{sdfScene}(P + d \cdot N) = 0\).
</p>

<p>
在有遮蔽物的情况下, \(Q\) 的距离场就小于 \(d\): \(d - \mathrm{sdfScene}(P + d \cdot N) \gt 0\).
</p>

<p>
正好可以利用 \(d\) 与 \(\mathrm{sdfScene}(P + d \cdot N)\) 的差值作为遮蔽程度.
</p>

<p>
在没有遮蔽物的情况下 \(d\) 与 \(\mathrm{sdfScene}(P + d \cdot N )\) 的差值为 0;
</p>

<p>
遮蔽程度越高, \(d\) 与 \(\mathrm{sdfScene}(P + d \cdot N)\) 之间的差值越大.
</p>

<p>
在具体实现中, 会沿着 \(P\) 点的法线方向以固定步长移动 \(n\) 次, 对每一次的遮蔽程度进行求和, 以此求出 \(P\) 点的遮蔽程度:
</p>

<p>
\(\mathrm{occlusion} = \sum \limits_{i=0}^{n}(d_{i} - \mathrm{sdfScene}(P + d_{i} \cdot N))\)
</p>

<p>
这里参考 <a href="https://www.shadertoy.com/view/Xds3zN">Inigo Quilez 的实现</a>:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#30001;&#20110;&#21442;&#25968;&#31867;&#22411;&#30340;&#19981;&#21516;, &#36825;&#37324;&#23545;&#21407;&#20195;&#30721;&#36827;&#34892;&#20102;&#19968;&#20123;&#35843;&#25972;,
   &#25552;&#39640;&#20102;&#21487;&#35835;&#24615;, &#20294;&#25439;&#22833;&#20102;&#19968;&#20123;&#24615;&#33021;</span><span style="color: #ff7f24;"> */</span>
<span style="color: #98fb98;">float</span> calcAO( <span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec3</span> pos, <span style="color: #00ffff;">in</span> <span style="color: #98fb98;">vec3</span> normal, <span style="color: #00ffff;">in</span> <span style="color: #98fb98;">int</span> sampleCnt )
{
  <span style="color: #98fb98;">float</span> occlusion = 0.0;
  <span style="color: #98fb98;">float</span> scale = 1.0;

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#22312;&#23454;&#38469;&#24320;&#21457;&#20013;, &#37319;&#29992;&#25968;&#37327; sampleCnt &#19968;&#33324;&#26159;&#22266;&#23450;&#30340;,
     &#25152;&#20197;&#20250;&#25163;&#21160;&#35745;&#31639;&#20986; maxOcclusion &#28982;&#21518;&#30828;&#32534;&#30721;</span><span style="color: #ff7f24;"> */</span>
  <span style="color: #98fb98;">float</span> maxOcclusion = 0.0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i=0; i&lt;sampleCnt; i++) {
    maxOcclusion += 0.01 + 0.12 * <span style="color: #98fb98;">float</span>(i) / 4.0;
  }
  <span style="color: #98fb98;">float</span> iMaxOcclusion = 1.0 / maxOcclusion;

  <span style="color: #00ffff;">for</span>( <span style="color: #98fb98;">int</span> i=0; i&lt;sampleCnt; i++ ) {
    <span style="color: #98fb98;">float</span> di = 0.01 + 0.12 * <span style="color: #98fb98;">float</span>(i) / 4.0;
    <span style="color: #98fb98;">float</span> sdf = sdfScene( pos + di * normal ).dist;
    occlusion += (di - sdf) * scale;
    scale *= 0.95;
    <span style="color: #00ffff;">if</span>( occlusion &gt; maxOcclusion ) <span style="color: #00ffff;">break</span>;
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36820;&#22238;&#32467;&#26524;&#26159;"&#24320;&#25918;"&#31243;&#24230;
</span>  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">clamp</span>( 1.0 - iMaxOcclusion * occlusion, 0.0, 1.0 );
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20026;&#20102;&#23637;&#31034; AO &#25928;&#26524;, &#22312;&#22330;&#26223;&#37324;&#38754;&#28155;&#21152;&#22810;&#19968;&#20010;&#29699;&#20307;, &#20351;&#24471;&#29699;&#20307;&#20043;&#38388;&#30340;&#20301;&#32622;&#25509;&#36817;
</span>Intersection sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  Intersection sphere1 = Intersection(sdfSphere(p - sphereCenter, sphereRadius), 1);
  Intersection sphere2 = Intersection(sdfSphere(p - (sphereCenter + <span style="color: #98fb98;">vec3</span>(0, 2.1, 0)), sphereRadius), 1);
  Intersection ground = Intersection(sdfGround(p), 2);
  Intersection result = opU(sphere1, sphere2);
  result = opU(result, ground);
  <span style="color: #00ffff;">return</span> result;
}

<span style="color: #98fb98;">void</span> main() {

  <span style="color: #98fb98;">vec3</span> cameraPos = <span style="color: #98fb98;">vec3</span>(0., 4.0, 3.0);

  <span style="color: #98fb98;">vec2</span> m = iMouse.xy / iResolution.xy;
  <span style="color: #98fb98;">float</span> sX = <span style="color: #b0c4de;">sin</span>(m.y - .5);
  <span style="color: #98fb98;">float</span> cX = <span style="color: #b0c4de;">cos</span>(m.y - .5);
  <span style="color: #98fb98;">mat3</span> rotateX = <span style="color: #98fb98;">mat3</span>(1.0, 0.0, 0.0,
                      0.0, cX, sX,
                      0.0, -sX, cX);

  <span style="color: #98fb98;">float</span> sY = <span style="color: #b0c4de;">sin</span>(m.x * 6.2831);
  <span style="color: #98fb98;">float</span> cY = <span style="color: #b0c4de;">cos</span>(m.x * 6.2831);
  <span style="color: #98fb98;">mat3</span> rotateY = <span style="color: #98fb98;">mat3</span>(cY, 0.0, -sY,
                      0.0, 1.0, 0.0,
                      sY, 0.0, cY);

  cameraPos = rotateY * rotateX * cameraPos;
  <span style="color: #98fb98;">vec3</span> col = <span style="color: #98fb98;">vec3</span>(0.0);

  <span style="color: #98fb98;">float</span> AA_size = 3.0;
  <span style="color: #98fb98;">int</span> count = 0;
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaY = -1; aaY &lt;= 1; aaY++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> aaX = -1; aaX &lt;= 1; aaX++) {
      <span style="color: #98fb98;">vec2</span> coord = <span style="color: #eedd82;">gl_FragCoord</span>.xy + <span style="color: #98fb98;">vec2</span>(aaX, aaY) / AA_size;
      <span style="color: #98fb98;">vec2</span> uv = (2.0 * coord - iResolution.xy) / <span style="color: #b0c4de;">min</span>(iResolution.x, iResolution.y);
      <span style="color: #98fb98;">vec3</span> rd = GetRayDirection(uv, cameraPos, <span style="color: #98fb98;">vec3</span>(0.0, 4.0, 0.0), 2.0);
      Intersection d = RayMarch(cameraPos, rd);
      <span style="color: #98fb98;">vec3</span> p = cameraPos + d.dist * rd;
      <span style="color: #98fb98;">vec3</span> n = GetNormal(p);    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#27861;&#32447;&#35745;&#31639;&#25343;&#20986;&#26469;
</span>      <span style="color: #98fb98;">float</span> occ = calcAO(p, n, 5); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35745;&#31639;&#24320;&#25918;&#31243;&#24230;, &#25110;&#31216;&#36974;&#34109;&#20462;&#27491;&#31995;&#25968;
</span>
      <span style="color: #00ffff;">if</span> (d.dist &lt; MAX_DIST) {
        <span style="color: #98fb98;">vec3</span> tex = <span style="color: #98fb98;">vec3</span>(1.0);
        <span style="color: #00ffff;">if</span> (1 == d.matID) {
          tex = TriplanarMap(p, n, iChannel0);
        }
        <span style="color: #98fb98;">float</span> diffuse = GetLight(p);
        col += <span style="color: #98fb98;">vec3</span>(tex * diffuse);
      } <span style="color: #00ffff;">else</span> {
        col = <span style="color: #98fb98;">vec3</span>(0.3, 0.36, 0.6) - (rd.y * 0.4);
      }
      col = applyFog(col, <span style="color: #98fb98;">vec3</span>(1., 1., 1.), p.z, 8.0, 1.0 / 80.0) * occ;  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">occ &#20462;&#27491;
</span>      count++;
    }
  }
  col /= count;
  col = <span style="color: #b0c4de;">pow</span>(col, <span style="color: #98fb98;">vec3</span>(.4545));  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[0, 1]^3 to [0, 1]^3
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(col, 1.0);
}
</pre>
</div>


<div id="org6c77ee8" class="figure">
<p><img src="../../../files/raymarching-ao-example.png" alt="raymarching-ao-example.png" width="504px">
</p>
</div>

<p>
遮蔽程度的计算并非固定不变的, 对比 <code>Alex Evans</code> 的文章和 <code>Inigo Quilez</code> 的实现后会发现两者在核心原理上保持一致, 但遮蔽计算有差别.
</p>
</div>
</li>
<li><a id="orge6bc72d"></a>包围体层次结构 (Bounding Volume Hierarchy, BVH)<br>
<div class="outline-text-5" id="text-orge6bc72d">
<p>
当场景越来越复杂时, 渲染器的渲染效率会大幅度下降, 当然这是无法避免的, 但可以进行一定程度的优化.
</p>

<p>
渲染效率下降是由于 <code>sdfScene</code> 的复杂度增加, 比如增加多两个球体:
</p>

<div class="org-src-container">
<pre class="src src-glsl">Intersection sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  Intersection sphere1 = Intersection(sdfSphere(p - sphereCenter, sphereRadius), 1);
  Intersection sphere2 = Intersection(sdfSphere(p - (sphereCenter + <span style="color: #98fb98;">vec3</span>(0, 2.1, 0)), sphereRadius), 1);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26032;&#22686;&#29699;&#20307;
</span>  <span style="color: #98fb98;">vec3</span> transCenter = sphereCenter + <span style="color: #98fb98;">vec3</span>(10.0, 0.0, 0.0);
  Intersection sphere3 = Intersection(sdfSphere(p - transCenter, sphereRadius), 1);
  Intersection sphere4 = Intersection(sdfSphere(p - (transCenter + <span style="color: #98fb98;">vec3</span>(0, 2.1, 0)), sphereRadius), 1);

  Intersection ground = Intersection(sdfGround(p), 2);

  Intersection result = opU(sphere1, sphere2);
  result = opU(result, sphere3);
  result = opU(result, sphere4);
  result = opU(result, ground);
  <span style="color: #00ffff;">return</span> result;
}
</pre>
</div>


<div id="org7e14d92" class="figure">
<p><img src="../../../files/more-complicated-scene.png" alt="more-complicated-scene.png" width="504px">
</p>
</div>

<p>
目前场景还不算太复杂, 然而性能也下降不少了.
</p>

<p>
在计算其中两个球体的距离场时, 另两个球体的距离场计算是没有必要的, 因为两组球体之间的距离相差比较远, 无意义的计算就是渲染效率下降的原因.
</p>

<p>
解决这个问题的有效方法就是按照物体之间的距离把场景划分成若干个区域, 接近的物体会被划分在一个区域,
</p>

<p>
区域也可能会以同样方法划分成更多小区域, 整个场景结果最终形成一个树状结构, 比如下图:
</p>


<div id="org1108e75" class="figure">
<p><img src="../../../files/Primitives-and-hierarchy.svg" alt="Primitives-and-hierarchy.svg" class="org-svg" width="504px">
</p>
</div>

<p>
这个就是 <code>BVH</code>. 那么问题来了, <code>BVH</code> 是如何提高渲染效率呢?
</p>

<p>
其实非常简单, 当射线进入某个区域时, 就只针对这个区域里的物体进行距离场计算, 这样一来就可以避免无意义的距离场计算.
</p>

<p>
在实现中可以手动对物体进行划分, 还是以 <code>sdfScene</code> 为例, 可以把球体按照距离进行两两划分.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30830;&#23450;&#21306;&#22495;&#30340;&#24037;&#20855;
</span><span style="color: #98fb98;">float</span> sdfBox( <span style="color: #98fb98;">vec3</span> p, <span style="color: #98fb98;">vec3</span> b ) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">b = (0.5 * w, 0.5 * h, 0.5 * d)
</span>  <span style="color: #98fb98;">vec3</span> d = <span style="color: #b0c4de;">abs</span>(p) - b;
  <span style="color: #00ffff;">return</span> <span style="color: #b0c4de;">min</span>(<span style="color: #b0c4de;">max</span>(d.x,<span style="color: #b0c4de;">max</span>(d.y,d.z)),0.0) + <span style="color: #b0c4de;">length</span>(<span style="color: #b0c4de;">max</span>(d,0.0));
}

Intersection sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  Intersection result = Intersection(sdfGround(p), 2);
  <span style="color: #98fb98;">vec3</span> transCenter = sphereCenter + <span style="color: #98fb98;">vec3</span>(10.0, 0.0, 0.0);

  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">sdfBox(p - vec3(sphereCenter.x, sphereCenter.y, 2.1), vec3(2.1, 2.1, 4.2)) &#26159;&#19968;&#20010;&#30418;&#23376;,

     &#30418;&#23376;&#22312;&#20301;&#32622;&#19978;&#19982;&#31532;&#19968;&#20010;&#21644;&#31532;&#20108;&#20010;&#29699;&#20307;&#37325;&#21472;, &#22312;&#22823;&#23567;&#19978;&#21253;&#21547;&#20102;&#20004;&#20010;&#29699;&#20307;
</span><span style="color: #ff7f24;">  */</span>

  <span style="color: #00ffff;">if</span> (sdfBox(p - <span style="color: #98fb98;">vec3</span>(sphereCenter.x, 2.1, sphereCenter.z), <span style="color: #98fb98;">vec3</span>(1.05, 2.1, 1.05)) &lt; result.dist) {
    Intersection sphere1 = Intersection(sdfSphere(p - sphereCenter, sphereRadius), 1);
    Intersection sphere2 = Intersection(sdfSphere(p - (sphereCenter + <span style="color: #98fb98;">vec3</span>(0, 2.1, 0)), sphereRadius), 1);
    result = opU(result, sphere1);
    result = opU(result, sphere2);
  }

  <span style="color: #00ffff;">if</span> (sdfBox(p - <span style="color: #98fb98;">vec3</span>(transCenter.x, 2.1, sphereCenter.z), <span style="color: #98fb98;">vec3</span>(1.05, 2.1, 1.05)) &lt; result.dist) {
    Intersection sphere3 = Intersection(sdfSphere(p - transCenter, sphereRadius), 2);
    Intersection sphere4 = Intersection(sdfSphere(p - (transCenter + <span style="color: #98fb98;">vec3</span>(0, 2.1, 0)), sphereRadius), 2);
    result = opU(result, sphere3);
    result = opU(result, sphere4);
  }
  <span style="color: #00ffff;">return</span> result;
}
</pre>
</div>

<p>
这段代码使用了 <code>sdfBox</code> 对物体进行"包裹", 渲染器首先和这些盒子进行相交判断, 在确定盒子相交后再进一步与里面的物体进行相交判断.
</p>

<p>
也并非一定要用盒子对物体进行包裹, 也可以使用其它与被包裹的物体形状相近的物体进行包裹.
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4cd1da7" class="outline-4">
<h4 id="org4cd1da7">3D SDF 变换的注意事项</h4>
<div class="outline-text-4" id="text-org4cd1da7">
<p>
在 <code>2D SDF</code> 时就介绍过对 <code>SDF</code> 进行变换的<a href="#org0cafc34">方法</a>了, 具体就不赘述了.
</p>

<p>
但还是要再提醒一点, 在我们的渲染器中, 一切坐标都是视点坐标, 左手坐标系.
</p>

<p>
射线上点的 \(p\), 相机位置以及物体位置都是视点坐标.
</p>

<p>
因此, 要对物体实现 \(M = M_0 \times M_1\) 变换, 那么对 \(p\) 点应该实现 \(M^{-1} = M_{1}^{-1} \times M_{0}^{-1}\) 的变换: \(M^{-1} p\).
</p>

<p>
在实际的光栅渲染器中, 缩放变换并不被包含在视点变换中, 被认为是无意义的.
</p>

<p>
因此, 相对于平移和旋转变换, 缩放变换对于依赖视点变换的 <code>RayMarching</code> 渲染器来说同样称得上为"异类".
</p>

<p>
它也的确带来了一些问题. 用前面的 <code>sdfScene</code> 函数为例子,
</p>

<p>
对场景里面的球体进行缩小, 导致在某些视觉角度上看到球体出现一些异常.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">vec3</span> sp = <span style="color: #98fb98;">vec3</span>(1.0, 3.0, 5.0) * p; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312; y &#36724;&#26041;&#21521;&#19978;&#23545;&#29699;&#20307;&#36827;&#34892;&#32553;&#23567;
</span>  <span style="color: #98fb98;">float</span> sphereDist = sdfSphere(sp - sphereCenter, sphereRadius); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36317;&#31163;&#22330; sphereDist &#34987;&#25289;&#20280;&#20102;
</span>  <span style="color: #98fb98;">float</span> groundDist = sdfGround(p);

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #ff7f24;">/*</span><span style="color: #ff7f24;">
     &#22240;&#20026;&#21464;&#25442;&#23545;&#35937;&#19981;&#26159;&#29289;&#20307;&#26412;&#36523;, &#32780;&#26159;&#23556;&#32447;, &#20351;&#24471;&#36317;&#31163;&#22330;&#34987;&#25289;&#20280;,

     &#36317;&#31163;&#22330;&#34987;&#25289;&#20280;&#20250;&#23548;&#33268; RayMarch &#20197;&#36807;&#22823;&#30340;&#27493;&#38271;&#27493;&#36827;, &#20174;&#32780;&#36827;&#20837;&#29289;&#20307;&#20869;&#37096;&#29978;&#33267;&#26159;&#31359;&#36807;&#29289;&#20307;,

     &#25152;&#20197;&#22312;&#26576;&#20123;&#35282;&#24230;&#35266;&#30475;&#29699;&#20307;&#20250;&#21457;&#29616;&#19968;&#20123;&#38382;&#39064;.
</span><span style="color: #ff7f24;">   */</span>
  <span style="color: #00ffff;">return</span> d;
}
</pre>
</div>


<div id="org5deb5d8" class="figure">
<p><img src="../../../files/invalid-sdf-sphere.png" alt="invalid-sdf-sphere.png" width="504px">
</p>
</div>

<p>
解决方法是对距离场进行等倍缩小, 让距离场除以原缩放系数当中最大的一个来缩小步长.
</p>

<p>
缩小步长可以保证射线绝对不会找错交点, 因此除以更大系数也无所大碍, 但是这导致了需要更多的步进次数, 从而降低渲染效率.
</p>

<p>
对球体进行放大不存在这个问题, 因为它的距离场被缩小了, 不会出现步长过大的情况.
</p>

<p>
不过如果是均匀放大, 可以为了性能适当拉伸一下距离场: 让距离场除以缩小系数.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #98fb98;">float</span> sdfScene(<span style="color: #98fb98;">vec3</span> p) {
  <span style="color: #98fb98;">vec3</span> sp = <span style="color: #98fb98;">vec3</span>(1.0, 3.0, 5.0) * p; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312; y &#36724;&#26041;&#21521;&#19978;&#23545;&#29699;&#20307;&#36827;&#34892;&#32553;&#23567;
</span>  <span style="color: #98fb98;">float</span> sphereDist = sdfSphere(sp - sphereCenter, sphereRadius) / 5.0; <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21407;&#26412;&#32553;&#25918;&#30340;&#26368;&#22823;&#20998;&#37327;&#26159; 5.0, &#25152;&#20197;&#36825;&#37324;&#35201;&#22788;&#20197; 5.0
</span>  <span style="color: #98fb98;">float</span> groundDist = sdfGround(p);

  <span style="color: #98fb98;">float</span> d = <span style="color: #b0c4de;">min</span>(sphereDist, groundDist);
  <span style="color: #00ffff;">return</span> d;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org3a77868" class="outline-2">
<h2 id="org3a77868">分形 (Fractal)</h2>
<div class="outline-text-2" id="text-org3a77868">
<blockquote>
<p>
施工中
</p>
</blockquote>

<p>
<a href="https://davis.wpi.edu/~matt/courses/fractals/intro.html#Definition">https://davis.wpi.edu/~matt/courses/fractals/intro.html#Definition</a>
</p>

<p>
<a href="https://github.com/pedrotrschneider/shader-fractals">https://github.com/pedrotrschneider/shader-fractals</a>
</p>

<p>
自相似性(<code>self similarity</code>): 一个几何体的部分与整体在形状上一致, 或者说这个几何体可以划分成多个等份更小的自己.
</p>

<p>
(<code>self affine</code>)
</p>

<p>
整体与部分之间的比例为 \(R\), 构成新几何体需要用到 \(N\) 个部分, 那么这个分形的维度 \(D = \log_{R}{N}\).
</p>
</div>
<div id="outline-container-org7f597d0" class="outline-3">
<h3 id="org7f597d0">分形布朗运动 (Fractal Brownian Motion)</h3>
<div class="outline-text-3" id="text-org7f597d0">
<p>
这一次从物理层面上去看待噪声: 波(<code>waves</code>), 是随着时间发生波动的某种物理量.
</p>

<p>
比如声波(<code>audio waves</code>)是空气压力(<code>air pressure</code>)的波动, 电磁波(<code>electromagnetical waves</code>)是电磁场(<code>electrical and magnetic fields</code>)的波动.
</p>

<p>
振幅(<code>amplitude</code>)和频率(<code>frequency</code>)是波的两个重要特性.
</p>

<p>
以最简单的噪声 - 正弦波(<code>sine wave</code>)为例: \(f(x) = \mathrm{amplitude} \times \sin(\mathrm{frequency} \times (x + h)) + v\), 其中 \(h\) 是在水平方向上的偏移, 水平方向上的偏移大小和时间有关, \(v\) 是在垂直方向上的偏移.
</p>

<p>
其它噪声波的数学表达式同理: \(f(x) = \mathrm{amplitude} \times \mathrm{noise}(\mathrm{frequency} \times (x + h)) + v\).
</p>

<p>
波的另外一个重要特性是波叠加(<code>superposition</code>), 也就是把多个波进行相加, 最终得到的波会因为振幅/频率/偏移的不同产生不同的结果,
</p>

<p>
如果对这一个话题感兴趣, 可以去搜索 <code>superposition principle</code>, 相关的资料很多, 这里给出一个详略得当的<a href="https://www.acs.psu.edu/drussell/Demos/superposition/superposition.html">资料地址</a>.
</p>

<p>
在乐理中, 每个音符(<code>note</code>)都有一个特定的频率, 这些音符的频率遵守一种名为音阶(<code>scale</code>)的模式进行排列, 其中频率的加倍或减半对应一个八度(<code>octave</code>)的跳跃.
</p>

<p>
对噪声进行波叠加, 每次叠加增加固定大小的频率并减少固定大小的振幅, 可以获得更精细的噪声粒度以及更丰富的噪声细节, 这项技巧叫做分形布朗运动, 简称 <code>fBM</code>, 或者分形噪声(<code>fractal noise</code>).
</p>

<p>
每次增加固定频率大小叫做间隙度(<code>lacunarity</code>), 而每次减少的固定振幅大小叫做振幅增益(<code>gain</code>).
</p>

<p>
\(\mathrm{fBM}(x, y, z) = \sum\limits_{i=1}^{n} \mathrm{amplitude}^{i} \cdot \mathrm{noise}(\mathrm{frequency}^{i}x, \mathrm{frequency}^{i}y, \mathrm{frequency}^{i}z)\)
</p>

<p>
<a href="../../../files/fractional-Brownian-motion.pdf">../../../files/fractional-Brownian-motion.pdf</a>
</p>

<p>
概念参考资料: <a href="https://thebookofshaders.com/13/">https://thebookofshaders.com/13/</a>
</p>

<blockquote>
<ul class="org-ul">
<li><p>
Experiment by changing the frequency and amplitude for the additional waves.
</p>

<p>
pass
</p></li>

<li><p>
Is it possible to make two waves cancel each other out? What will that look like?
</p>

<p>
是的.
</p>

<p>
使得两个正弦波的频率(<code>frequency</code>)和振幅(<code>amplitude</code>)保持一直, 两者偏移(offset)相差 \(PI\).
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #98fb98;">float</span> <span style="color: #eedd82;">amplitude</span> = 4.5;
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">frequency</span> = 2.1;
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">offset</span> = PI;
<span style="color: #98fb98;">float</span> <span style="color: #eedd82;">y</span> = sin(x*frequency + t)*amplitude;
y += sin(x*frequency + t + PI)*amplitude;
</pre>
</div></li>

<li><p>
Is it possible to add waves in such a way that they will amplify each other?
</p>

<p>
是的.
</p>

<p>
有三种方法:
</p>

<ol class="org-ol">
<li>相位一致性: 确保 \(\mathrm{frequency}\) 和 \(\mathrm{offset}\) 保持一致.</li>

<li>频率匹配: 确保 \(\mathrm{frequency}\) 保持一致, \(\mathrm{offset}\) 之差不能超过 \(\mathrm{PI}\).</li>

<li>多波叠加: 使用多种波形的组合, 比如方波, 不过这超出我们的讨论范围了.</li>
</ol></li>

<li><p>
Progressively change the number of octaves to iterate from 1 to 2, 4, 8 and 10. See what happens.
</p>

<p>
线条的总体形状不发生改变, 只是会一直添加细节, 当 <code>octaves</code> 增加大于 8 时, 细节的增加也不明显了.
</p></li>

<li><p>
When you have more than 4 octaves, try changing the lacunarity value.
</p>

<p>
线条的周期会明显缩小, 振幅稍微扩大.
</p></li>

<li><p>
Also with &gt;4 octaves, change the gain value and see what happens.
</p>

<p>
线条的振幅明显扩大.
</p></li>
</ul>
</blockquote>
</div>
<div id="outline-container-org42e981f" class="outline-4">
<h4 id="org42e981f">噪声的导数解析式</h4>
<div class="outline-text-4" id="text-org42e981f">
<blockquote>
<p>
施工中
</p>
</blockquote>

<p>
参考: <a href="https://iquilezles.org/articles/morenoise/">https://iquilezles.org/articles/morenoise/</a>
</p>

<p>
以下是对链接中的 <code>3D</code> 值噪声导数解析式的求解过程进行详细补充.
</p>

<p>
这里先用 <code>Maxima</code> 得出未转换的结果, <code>Maxima</code> 代码如下:
</p>

<div class="org-src-container">
<pre class="src src-maxima"><span style="color: #00ffff;">//</span> &#31561;&#21516;&#20110; mix(a, b, t)
lerp(t, a, b) <span style="color: #00ffff;">:=</span> a <span style="color: #00ffff;">+</span> (b <span style="color: #00ffff;">-</span> a) <span style="color: #00ffff;">*</span> t;
n(u, v, w) <span style="color: #00ffff;">:=</span> lerp(w,
  lerp(v, lerp(u, a, b), lerp(u, c, d)),
  lerp(v, lerp(u, e, f), lerp(u, g, h)));
n(u, v, w);
</pre>
</div>

<p>
\(n(u, v, w) = smoothstep(vec3(0.0), vec3(1.0), fract(vec3(x, y, z)))\)
</p>

<p>
这是运行得出的结果:
</p>

<p>
\(\{[(h - g) u - (f - e) u + g - e] v - [(d - c) u - (b - a) u + c - a] v + (f - e) u - (b - a) u + e - a\} w + [(d - c) u - (b - a) u + c - a] v + (b - a) u + a\)
</p>

<p>
以下是对结果进行简化的过程:
</p>

<p>
令 \(E_1 = [(h - g) u - (f - e) u + g - e] v = (h - g - f + e)uv + (g - e)v\)
</p>

<p>
令 \(E_2 = [(d - c) u - (b - a) u + c - a] v = (d - c - b + a)uv + (c - a)v\)
</p>

<p>
令 \(E_3 = (f - e) u - (b - a) u + e - a = (f - e - b + a)u + e - a\)
</p>

<p>
\(E_1 - E_2 = (h - g - f + e - d + c + b - a)uv + (g - e - c + a)v\)
</p>

<p>
\((E_1 - E_2 + E_3) w = (h - g - f + e - d + c + b - a)uvw + (g - e - c + a)vw + (f - e - b + a)uw + (e - a)w\)
</p>

<p>
最后, 把等式剩下的部分补上就可以得到链接中的 <code>3D</code> 值噪声展开式:
</p>

<p>
\(n(u, v, w) = (h - g - f + e - d + c + b - a)uvw + (g - e - c + a)vw + (f - e - b + a)uw + (e - a)w + (d - c - b + a)uv + (c - a)v + (b - a)u + a\)
</p>

<p>
令 \(\begin{cases} k_0 = a \\ k_1 = b - a \\ k_2 = c - a \\ k_3 = e - a \\ k_4 = d - c - b + a \\ k_5 = g - e - c + a \\ k_6 = f - e - b + a \\ k_7 = h - g - f + e - d + c + b - a \end{cases} \rightarrow n(u, v, w) = k_0 + k_1 u + k_2 v + k_3 w + k_4 uv + k_5 vw + k_6 uw + k_7 uvw\)
</p>

<p>
现在计算 \(n(n, v, w)\) 的梯度向量/导数就很简单了: \(\begin{cases} \frac{\partial n(u, v, w)}{\partial u} = k_1 + k_4 v + k_6 w + k_7 vw \\ \frac{\partial n(u, v, w)}{\partial v} = k_2 + k_4 u + k_5 w + k_7 uw \\ \frac{\partial n(u, v, w)}{\partial w} = k_3 + k_5 v + k_6 u + k_7 uv \end{cases}\).
</p>
</div>
</div>
</div>
<div id="outline-container-org8635a66" class="outline-3">
<h3 id="org8635a66">谢尔宾斯基三角形 (Sierpiński Triangle)</h3>
</div>
<div id="outline-container-orgdb00242" class="outline-3">
<h3 id="orgdb00242">madelbrot set</h3>
</div>
</div>
<div id="outline-container-org3c22e8c" class="outline-2">
<h2 id="org3c22e8c">图像处理</h2>
<div class="outline-text-2" id="text-org3c22e8c">
<blockquote>
<p>
施工中
</p>
</blockquote>
</div>
<div id="outline-container-orgaeb22ab" class="outline-3">
<h3 id="orgaeb22ab">卷积 (Convolution)</h3>
<div class="outline-text-3" id="text-orgaeb22ab">
<p>
卷积在图像处理中发挥着非常重要的作用. 卷积是一种数学运算, 适用于处理连续对象和离散对象.
</p>

<p>
以连续版本的卷积运算为例, 其定义为: \((f * g)(t) = \int_{-\infty}^{\infty} f(\tau) g(-\tau + t) d\tau\).
</p>


<div id="org10e1584" class="figure">
<p><img src="../../../files/Convolution_of_spiky_function_with_box2.gif" alt="Convolution_of_spiky_function_with_box2.gif" width="504px">
</p>
<p><span class="figure-number">Figure 36: </span>连续卷积</p>
</div>

<p>
整个计算过程可以这么描述:
</p>

<p>
先对函数 \(g\) 进行变换, 围绕 \(y\) 轴进行翻转, 并往 \(x\) 轴正方向平移 \(t\) 单位作为起点;
</p>

<p>
再让经过变换后的 \(g\) 移动, 在移动期间计算 \(f\) 和 \(g\) 之间的乘积, 对乘积进行积分得出结果.
</p>

<p>
这里的函数 \(f\) 称为核(<code>kernel</code>)或滤波核(<code>filter kernel</code>), \(g\) 是输入的数据, 核对会输入的数据进行处理.
</p>

<p>
为了保证 \(f\) 能够按照数据顺序来处理数据, 所以才对 \(g\) 进行翻转, 而翻转这个动作就叫做"卷".
</p>

<p>
这里的处理内容就是 <b>计算核与数据之间的相似程度, 并根据相似程度突出两者差异</b>.
</p>

<p>
在上面动画中, 黄色区域就代表着核与数据在当前时刻的相似程度.
</p>

<p>
因此, 核与输入数据之间的乘积(其实还要乘以 \(d\tau\))可作为两者相似程度的量化, 卷积的含义就是相似度之和.
</p>

<blockquote>
<p>
不要混淆 \((f * g)(t)\) 和 \((fg)\), \((fg)(t)\) 是复合函数, 它的完整定义是 \(f(g(t))\).
</p>

<p>
这里 \(*\) 是卷积运算符, 并非乘法.
</p>
</blockquote>

<p>
在图像处理中, 使用的是(二维)离散卷积运算, 因为图片数据是离散对象, 像素间隔固定为 1.
</p>

<p>
图像处理更能体现 "计算相似程度, 突出两者差异" 这个说法.
</p>


<div id="org2135d02" class="figure">
<p><img src="../../../files/11148cnn_convolve_with_padding.gif" alt="11148cnn_convolve_with_padding.gif" width="504px">
</p>
<p><span class="figure-number">Figure 37: </span>2D 离散卷积, 使用 \(3 \times 3\) 的核来处理 \(5 \times 5\) 的数据, 为了保证卷积进行在外层填充 0</p>
</div>

<p>
该动画所使用的核是一个 \(3 \times 3\) 的矩阵, 而不是函数, 这个矩阵是在连续函数的采样结果, 近似地反应了连续函数的分布.
</p>

<p>
比如这个连续函数是 \(z = f(x, y)\), 要生成一个 \(N \times N\) 的核,
</p>

<p>
要先选定一个有限的定义域范围: \(x, y \in [- \lfloor \frac{N}{2} \rfloor, \lfloor \frac{N}{2} \rfloor]\);
</p>

<p>
再根据像素间隔对定义域范围进行离散化: \(x, y \in \{ - \lfloor \frac{N}{2} \rfloor,  - \lfloor \frac{N}{2} \rfloor + 1, \dots, -1, 0, 1, \dots, \lfloor \frac{N}{2} \rfloor - 1, \lfloor \frac{N}{2} \rfloor \}\);
</p>

<p>
在离散化的定义域内计算出全部的函数值, 最后得到的矩阵就是一个 \(N \times N\) 的核.
</p>

<blockquote>
<p>
一元连续函数离散化之后得到的核是一个向量.
</p>
</blockquote>

<p>
在获得核后, 每次需要读取一个 \(N \times N\) 局部图像数据矩阵, 让核与数据矩阵的对应行向量进行点积, 最后对点积求和作为对应像素的值.
</p>

<p>
计算过程如下:
</p>

<p>
假设核为 \(F = \left( \begin{array}{c} w_1 & w_2 & w_3 \\ w_4 & w_5 & w_6 \\ w_7 & w_8 & w_9 \end{array} \right)\), 选取像素 \(d_5\) 以及它的 8 个相邻像素的作为数据 \(G = \left( \begin{array}{c} d_1 & d_2 & d_3 \\ d_4 & d_5 & d_6 \\ d_7 & d_8 & d_9 \end{array} \right)\),
</p>

<p>
\(A = \left(\begin{array}{c} w_1 & w_2 & w_3 \end{array}\right) \cdot \left(\begin{array}{c} d_1 & d_2 & d_3 \end{array}\right) = w_1 d_1 + w_2 d_2 + w_3 d_3\)
</p>

<p>
\(B = \left(\begin{array}{c} w_4 & w_5 & w_6 \end{array}\right) \cdot \left(\begin{array}{c} d_4 & d_5 & d_6 \end{array}\right) = w_4 d_4 + w_5 d_5 + w_6 d_6\)
</p>

<p>
\(C = \left(\begin{array}{c} w_7 & w_8 & w_9 \end{array}\right) \cdot \left(\begin{array}{c} d_7 & d_8 & d_9 \end{array}\right) = w_7 d_7 + w_8 d_8 + w_9 d_9\)
</p>

<p>
最终, 像素 \(d_5\) 新的像素值为 \(F * G = A + B + C\). 如果把 \(F\) 和 \(G\) 分别展开成向量 \(v_F\) 和 \(v_G\):
</p>

<p>
\(\begin{cases} v_{F} = \left(\begin{array}{c} w_1 & w_2 & w_3 & w_4 & w_5 & w_6 & w_7 & w_8 & w_9 \end{array} \right) \\ v_{G} = \left( \begin{array}{c} d_1 & d_2 & d_3 & d_4 & d_5 & d_6 & d_7 & d_8 & d_9 \end{array} \right) \end{cases}\), 那么 \(d_5\) 就是 \(v_F\) 和 \(v_G\) 的点积.
</p>

<p>
点积可以用来表示两个向量之间的相似程度: \(v_{F} \cdot v_{G} = |v_{F}||v_{G}|\cos\theta\), 其中 \(\theta \in [-\pi, \pi]\), \(\cos\theta \in [-1, 1]\)
</p>

<p>
\(\cos\theta\) 越大, 两者相似程度越高, 该相似度称为余弦相似度. 从这个角度来看, 核的本质是权重集合.
</p>

<p>
但为什么是以这种方式进行运算呢? 在蒙特卡洛法积分法中, 求积分就是在求近似期望, 可得出关系:
</p>

<p>
\(\int f(\tau)g(-\tau + t) d \tau = \int \frac{f(\tau) g(-\tau + t)}{p(\tau)} p(\tau) d\tau \approx \frac{1}{N} \sum\limits_{i=1}^{N} \frac{f(\tau_i)g(-\tau_i + t)}{p(\tau_i)}\)
</p>

<p>
\(p(\tau_i)\) 可以是任意概率密度函数, 最简单的就是均匀分布, 这里设 \(p(\tau_i) = \frac{1}{b - a}\), \(\tau \in [a, b]\),
</p>

<p>
进一步可以得出 \(\int f(\tau)g(-\tau + t) d \tau \approx \frac{b - a}{N} \sum\limits_{i=1}^{N}f(\tau_i)g(-\tau_i + t) = \frac{b - a}{N} \sum\limits_{i=1}^{N} w_i \times d_i\), 其中 \(\begin{cases} f(\tau_i) = w_i \\ g(-\tau_i + t) = d_i \end{cases}\),
</p>

<p>
这意味着上述例子应该满足 \(\left(\begin{array}{c} w_1 & w_2 & w_3 \\ w_4 & w_5 & w_6 \\ w_7 & w_8 & w_9 \end{array}\right) = (b - a) f(\tau)\) 或者 \(\frac{1}{b - a} \left(\begin{array}{c} w_1 & w_2 & w_3 \\ w_4 & w_5 & w_6 \\ w_7 & w_8 & w_9 \end{array}\right) = f(\tau)\) 才能得出真正的 \(F * G\),
</p>

<p>
大部分会忽略系数 \(\frac{1}{b - a}\), 它只对卷积结果起到缩放作用, 这里为了说明离散卷积是对 \(\int f(\tau)g(-\tau + t)\) 的近似才不可避免地提到它,
</p>

<p>
况且, \(p(\tau)\) 不是固定的, 对于这种增加讨论情况的不确定性因数应尽可能忽略.
</p>

<p>
正因如此, 人们会把两个相乘函数的积分 \(\int f(x)g(x) dx\) 称为函数点积, 卷积就是函数点积的一种, 不过是把其中一个函数进行反转了而已.
</p>

<p>
卷积核 \(F\) 还可以看作是一个图案模式(<code>pattern</code>), 与数据 \(G\) 的图案进行比对:
</p>

<p>
权重系数的绝对值越大, 对应位置的像素对卷积结果的影响越大; 权重系数的正负分别表示为对卷积结果的增强和抑制作用;
</p>

<p>
如果权重系数为 0, 那么说明对应位置的像素不影响卷积结果; 当 \(G\) 的图案和 \(F\) 的图案模式接近时, 卷积结果就越大,
</p>

<p>
也就是像素 \(d_5\) 越亮, 反之越暗. 比如, \(F = \left( \begin{array}{c} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{array} \right)\), 意味着 \(\left(w_1, w_4, w_7 \right)\) 的像素值越比 \(\left( w_3, w_6, w_9 \right)\) 的要小,
</p>

<p>
那么卷积结果就越大, \(d_5\) 的最终颜色越亮; 如果 \(\left(w_1, w_4, w_7 \right)\) 的像素值越比 \(\left( w_3, w_6, w_9 \right)\) 的要大,
</p>

<p>
或者说两者大小接近, 那么卷积结果越小, \(d_5\) 的最终颜色约暗.
</p>

<p>
这也是为什么是每次要取一片区域的像素而不是一个像素作为处理数据, 因为单凭一个像素无法形成模式.
</p>

<p>
根据卷积的运算特性: 运算结果作为中间数据的新值, 我们可以使用核来实现像素偏移.
</p>

<p>
比如 \(F = \left( \begin{array}{c} 0 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & 0 & 0 \end{array} \right)\) 可以让数据往左偏移 1 个单位, 相当于把右边的像素复制过来一样.
</p>

<p>
而偏移的距离和会受到核尺寸的限制, 比如 \(F = \left( \begin{array}{c} 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 \end{array} \right)\) 可以让数据往左偏移 2 个单位.
</p>

<blockquote>
<p>
接下来会以这张图片作为图像处理的学习例子.
</p>


<div id="org7829991" class="figure">
<p><img src="../../../files/fallout-4k-game-artwork-80.jpg" alt="fallout-4k-game-artwork-80.jpg" width="600px">
</p>
<p><span class="figure-number">Figure 38: </span>Fallout 4K Game Artwork (<a href="https://hdqwalls.com/fallout-4k-game-artwork-wallpaper">https://hdqwalls.com/fallout-4k-game-artwork-wallpaper</a>)</p>
</div>
</blockquote>
</div>
</div>
<div id="outline-container-sobel" class="outline-3">
<h3 id="sobel">Sobel 核</h3>
<div class="outline-text-3" id="text-sobel">
<p>
<code>Sobel</code> 核用于图像边缘检测(Edge detection), <code>Sobel</code> 核的想法是计算出当前像素在所有方向上的梯度,
</p>

<p>
以这些梯度作为权重分布进行计算, 从而判断当前像素在各个方向上的平滑性.
</p>


<div id="orgbeb8019" class="figure">
<p><img src="../../../files/sobel_neighborhood_cell_distances.png" alt="sobel_neighborhood_cell_distances.png" width="504px">
</p>
<p><span class="figure-number">Figure 39: </span>相邻元素的距离</p>
</div>

<p>
\(a, b, c, d, e, f, g, h, i\) 分别是对应位置上片元的属性值, 比如强度值, 求出中心点在 8 个代表了不同方向的梯度,
</p>

<blockquote>
<p>
这里梯度的计算方式为 \(\frac{\mathbf{片元之间的属性差}}{\mathbf{片元之间的距离}} \times \mathbf{片元之间的方向向量}\).
</p>

<p>
在与轴对齐的方向上, 片元之间的距离为 1, 在对角线上, 根据勾股定理, 片元之间的距离为 \(\sqrt{2}\).
</p>

<p>
该计算方式看上去并不符合梯度向量的定义, 但其实是符合的, 在计算对角线方向上的梯度时会进行论证.
</p>
</blockquote>

<p>
在 \((1, 0)\) 方向上梯度: \(F_{(1, 0)} = (\frac{f - e}{1})\vec{i} = (f - e) \vec{i}\)
</p>

<blockquote>
<p>
\(F\) 的完整形式定义是: \(F_{(\Delta x, \Delta y)}\),
</p>

<p>
其中 \(\Delta x\) 和 \(\Delta y\) 分别是片元在 \(x\) 和 \(y\) 方向上的距离, 或者说 \((\Delta x, \Delta y)\) 是方向.
</p>
</blockquote>

<p>
在 \((-1, 0)\) 方向上梯度: \(F_{(-1, 0)} = (\frac{d - e}{1}) \times -\vec{i} = (e - d)\vec{i}\)
</p>

<p>
在 \((0, 1)\) 方向上梯度: \(F_{(0, 1)} = (\frac{b - e}{1})\vec{j} = (b - e) \vec{j}\)
</p>

<p>
在 \((0, -1)\) 方向上梯度: \(F_{(0, -1)} = (\frac{h - e}{1}) \times - \vec{j} = (e - h)\vec{j}\)
</p>

<p>
在对角线 \((1, 1)\) 方向上梯度: \(F_{(1, 1)} = \frac{(c - e) (\cos\frac{\pi}{4} \vec{i} + \sin\frac{\pi}{4} \vec{j})}{\sqrt{2}} = \frac{1}{2}(c - e)(\vec{i} + \vec{j})\)
</p>

<blockquote>
<p>
\(\vec{i} + \vec{j}\) 不是单位向量, 需要进行单位化, 可以根据旋转角 \(\theta\) 对方向进行参数化: \(( \cos\theta, \sin\theta )\),
</p>

<p>
所以指向右上角的单位向量为 \((\cos \frac{\pi}{4}, \sin \frac{\pi}{4}) = (\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}) = \frac{1}{\sqrt{2}}(\vec{i} + \vec{j})\). 既然谈到旋转,
</p>

<p>
我们可通过矩阵变换的角度看待这个问题:
</p>

<p>
把 \(\begin{cases} \vec{i} = (1, 0) \\ \vec{j} = (0, 1) \end{cases}\) 看作基变量, 使用旋转矩阵 \(M_{R} = \left( \begin{array}{c} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{array} \right)\) 对它们进行旋转,
</p>

<p>
得出新的基变量 \(\begin{cases} \vec{i}_{r} = \left( \cos\theta, -\sin\theta \right) = \cos\theta \vec{i} - \sin\theta \vec{j} \\ \vec{j}_{r} = \left( \sin\theta, \cos\theta \right) = \sin\theta \vec{i} + \cos\theta \vec{j} \end{cases}\).
</p>

<p>
目前的情况是旋转 \(45^{\circ}\) 让新基变量对齐对角线: \(\begin{cases} \vec{i}_{r} = \frac{1}{\sqrt{2}}(\vec{i} + \vec{j}) \\ \vec{j}_{r} = \frac{1}{\sqrt{2}}(\vec{i} + \vec{j}) \end{cases}\),
</p>

<p>
现有近似梯度向量的定义: \(\nabla f(x, y) \approx ( \frac{f(x + \Delta x, y) - f(x, y)}{\Delta x}, \frac{f(x, y + \Delta y) - f(x, y)}{\Delta y} ) = \frac{f(x + \Delta x, y) - f(x, y)}{\Delta x} \vec{i}_{r} + \frac{f(x, y + \Delta y) - f(x, y)}{\Delta y} \vec{j}_{r}\),
</p>

<p>
在新坐标系中 \(\Delta x = 1\) 表示片元在水平方向上的距离为 1, \(\Delta y = 1\) 表示片元在垂直方向上的距离为 1;
</p>

<p>
把参数看成是一个向量可以得到 \(f(x, y) = f(\langle x, y \rangle) = f(x \vec{i}_{r} + y \vec{j}_{r})\), 可得出新的近似梯度向量定义:
</p>

<p>
\(\begin{equation*} \begin{aligned} & \nabla f(x \vec{i}_{r} + y \vec{j}_{r}) \\ \approx & (\frac{f((x + \Delta x) \vec{i}_{r} + y \vec{j}_{r}) - f(x \vec{i}_{r} + y \vec{j}_{r})}{\Delta x}, \frac{f(x \vec{i}_{r} + (y + \Delta y) \vec{j}_{r}) - f(x \vec{i}_{r} + y \vec{j}_{r})}{\Delta y}) \\ = & ( \frac{f((x + \Delta x + y)(\vec{i} + \vec{j})) - f((x + y) (\vec{i} + \vec{j})) }{\sqrt{2} \Delta x}, \frac{f((x + y + \Delta y) (\vec{i} + \vec{j})) - f((x + y)(\vec{i} + \vec{j})) }{\sqrt{2} \Delta y} ) \\ = & (\frac{f(x + \Delta x + y, x + \Delta x + y) - f(x + y, x + y)}{\sqrt{2} \Delta x}, \frac{f(x + y + \Delta y, x + y + \Delta y) - f(x + y, x + y)}{\sqrt{2} \Delta y}) \\ = & (\frac{f(x + y + 1, x + y + 1) - f(x + y, x + y)}{\sqrt{2}}, \frac{f(x + y + 1, x + y + 1) - f(x + y, x + y)}{\sqrt{2}}) \end{aligned} \end{equation*}\)
</p>

<p>
现在可以得出梯度向量 \(\nabla f(0, 0) = (\frac{f(1, 1) - f(0, 0)}{\sqrt{2}}, \frac{f(1, 1) - f(0, 0)}{\sqrt{2}}) = \frac{1}{\sqrt{2}}(c - e) (\vec{i} + \vec{j})\),
</p>

<p>
<b>不!</b> 还需要对 \(\nabla f(0, 0)\) 进行单位化, 片元的距离为 \(\sqrt{(\Delta x)^2 + (\Delta y)^2} = \sqrt{2}\), 所以:
</p>

<p>
\(F_(1, 1) = \frac{\nabla f(0, 0)}{\sqrt{2}} = \frac{1}{2}(c - e) (\vec{i} + \vec{j})\).
</p>

<p>
这整个过程的结果与前面提到的计算方式是一致的, 并且其过程也符合梯度向量的定义.
</p>

<p>
同样思路也能用在前面的几个梯度的计算上, 比如 \(F(-1, 0) \rightarrow \begin{cases} \Delta x = -1 \\ \Delta y = 0 \end{cases}\), 所以:
</p>

<p>
\(F(1, 0) \approx (\frac{f(-1, 0) - f(0, 0)}{-1}, \frac{f(0, 0) - f(0, 0)}{0})\), 其中 \(\frac{0}{0}\) 为未定义.
</p>
</blockquote>

<p>
在对角线 \((-1, -1)\) 方向上的梯度: \(F_{(-1, -1)} = \frac{(g - e) (\cos\frac{5 \pi}{4}\vec{i} + \sin\frac{5 \pi}{4}\vec{j})}{\sqrt{2}} = \frac{1}{2}(e - g)(\vec{i} + \vec{j})\)
</p>

<p>
在对角线 \((-1, 1)\) 方向上的梯度: \(F_{(-1, 1)} = \frac{(a - e) (\cos\frac{3 \pi}{4} \vec{i} + \sin\frac{3 \pi}{4} \vec{j})}{\sqrt{2}} = \frac{1}{2}(e - a)(\vec{i} - \vec{j})\)
</p>

<p>
在对角线 \((1, -1)\) 方向上的梯度: \(F_{(1, -1)} = \frac{(i - e) (\cos\frac{7 \pi}{4} \vec{i} + \sin\frac{7 \pi}{4} \vec{j})}{\sqrt{2}} = \frac{1}{2} (i - e)(\vec{i} - \vec{j})\)
</p>

<p>
对这些梯度进行求和得到新梯度:
</p>

<p>
\(\begin{equation*}\begin{aligned} & F_{(1, 0)} + F_{(-1, 0)} + F_{(0, 1)} + F_{(0, -1)} + F_{(1, 1)} + F_{(-1, -1)} + F_{(-1, 1)} + F_{(1, -1)} \\ = & (f - d)\vec{i} + (b - h)\vec{j} + \frac{1}{2} [(c - g)(\vec{i} + \vec{j}) + (i - a)(\vec{i} - \vec{j})] \\ = & \frac{1}{2}[ 2 (f - d)\vec{i} + 2 (b - h)\vec{j} + (c - g)\vec{i} + (c - g)\vec{j} + (i - a)\vec{i} - (i - a)\vec{j}] \\ = & \frac{1}{2}[2(f - d) + (c - g) + (i - a)]\vec{i} + \frac{1}{2}[2(b - h) + (c - g) - (i - a)]\vec{j} \\ = & \frac{1}{2} [-a + c -2d + 2f - g + i]\vec{i} + \frac{1}{2} [a + 2b + c - g - 2h - i]\vec{j} \\ = & F_{x} \vec{i} + F_{y} \vec{j}\end{aligned} \end{equation*}\).
</p>

<p>
其中 \(F_{x}\) 为水平方向上的 <code>kernel</code>, \(F_{y}\) 为垂直方向上的 <code>kernel</code>;
</p>

<p>
分别计算出在水平方向和垂直方向上的匹配程度: \(\langle F_x * G, F_y * G \rangle\),
</p>

<p>
该向量模长 \(\sqrt{(F_x * G)^2 + (F_y * G)^2}\) 作为新像素值, 其中 \(G\) 是 \(3 \times 3\) 的图像数据矩阵.
</p>


<div id="org19b6deb" class="figure">
<p><img src="../../../files/sobel_G_half.png" alt="sobel_G_half.png" width="400px">
</p>
</div>

<p>
根据<a href="https://www.researchgate.net/publication/239398674_An_Isotropic_3x3_Image_Gradient_Operator">原本的论文</a>, 由于有 8 个方向, 所以需要乘以 \(\frac{1}{8}\) 进行平均, 使得最终系数是 \(\frac{1}{16} = \frac{1}{2} \times \frac{1}{8}\),
</p>

<p>
但在实际中通常会忽略该参数, 除非想要降低亮度.
</p>

<blockquote>
<p>
如果是 \(5 \times 5\) 的核, 那么就是 16 个方向了.
</p>
</blockquote>

<p>
由于灰阶图更突显物体轮廓, 所以为了使结果更准确, 通常在使用 <code>Sobel</code> 算子之前会先对图片进行灰阶处理;
</p>

<p>
在提取了边缘之后, 一些点状轮廓看起来像是噪点, 通常这不是人们想要的, 所以还会使用平滑处理(盒状模糊/高斯模糊)对边缘图进行降噪.
</p>

<p>
以下是一个结合灰阶处理的 <code>Sobel</code> 算子例子:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#version</span> 130

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">filename: dip-sobel.frag
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">run: glslViewer dip-sobel.frag textures/2999645.jpg
</span>
<span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_tex0;

<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iChannel0 u_tex0
<span style="color: #b0c4de;">#endif</span>

<span style="color: #98fb98;">vec4</span> convolution(<span style="color: #98fb98;">vec2</span> uv, <span style="color: #98fb98;">float</span>[9] kernel, <span style="color: #98fb98;">vec4</span>[9] pixels) {
  <span style="color: #98fb98;">vec4</span> conv = <span style="color: #98fb98;">vec4</span>(0.0);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt;= 2; i++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 0; j &lt;= 2; j++) {
      <span style="color: #98fb98;">int</span> index = j * 3 + i;
      conv += pixels[index] * kernel[index];
    }
  }
  <span style="color: #00ffff;">return</span> conv;
}

<span style="color: #98fb98;">void</span> main () {
  <span style="color: #98fb98;">vec2</span> uv = <span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy;
  <span style="color: #98fb98;">vec2</span> steps = 1.0 / iResolution.xy;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pixel Sampling
</span>  <span style="color: #98fb98;">vec4</span> pixels[9];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = -1; i &lt;= 1; i++) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1, 1] =&gt; [0, 2]
</span>    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 1; j &gt;= -1; j--) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[1, -1] =&gt; [0, 2]
</span>      <span style="color: #98fb98;">int</span> index = (-j + 1) * 3 + (i + 1);
      <span style="color: #98fb98;">vec4</span> c = <span style="color: #b0c4de;">texture</span>(iChannel0, uv + <span style="color: #98fb98;">vec2</span>(<span style="color: #98fb98;">float</span>(i) * steps.x, <span style="color: #98fb98;">float</span>(j) * steps.y));
      pixels[index] = c;
    }
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">GrayScale
</span>  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; pixels.<span style="color: #b0c4de;">length</span>(); i++) {
    <span style="color: #98fb98;">float</span> gray = <span style="color: #b0c4de;">dot</span>(pixels[i].rgb, <span style="color: #98fb98;">vec3</span>(0.299, 0.587, 0.114));
    pixels[i] = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(gray), pixels[i].a);
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Sobel
</span>  <span style="color: #98fb98;">float</span> kernel_x[9] = <span style="color: #98fb98;">float</span>[9](-1, 0, 1, -2, 0, 2, -1, 0, 1);
  <span style="color: #98fb98;">float</span> kernel_y[9] = <span style="color: #98fb98;">float</span>[9](1, 2, 1, 0, 0, 0, -1, -2, -1);
  <span style="color: #98fb98;">vec4</span> conv_x = convolution(uv, kernel_x, pixels);
  <span style="color: #98fb98;">vec4</span> conv_y = convolution(uv, kernel_y, pixels);
  <span style="color: #98fb98;">vec4</span> g = <span style="color: #b0c4de;">sqrt</span>(conv_x * conv_x + conv_y * conv_y);

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30456;&#20284;&#24230;&#39640;, g &#36234;&#20142;, &#25105;&#20204;&#36825;&#37324;&#24819;&#35201;&#40657;&#33394;&#36793;&#32536;&#32447;, &#25152;&#20197;&#36827;&#34892;&#21453;&#36716;
</span>  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(1. - g.rgb, 1.0);
}
</pre>
</div>


<div id="org8a1e5f3" class="figure">
<p><img src="../../../files/dip-sobel-result.png" alt="dip-sobel-result.png" width="600px">
</p>
<p><span class="figure-number">Figure 40: </span>处理结果</p>
</div>
</div>
<div id="outline-container-orgc193edb" class="outline-4">
<h4 id="orgc193edb">GlslViewer 的多阶段渲染</h4>
<div class="outline-text-4" id="text-orgc193edb">
<p>
有时候图像处理需要分好几个阶段完成, 就比如前面说到的, 先灰阶化, 再降噪, 最后才提取轮廓.
</p>

<p>
<code>GlslViewer</code> 本身也支持<a href="https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#buffers-and-doublebuffers">多阶段渲染</a>, 是通过预编译器实现的.
</p>

<p>
比如下面的代码, 判断宏 <code>BUFFER_[NUMBER]</code> 是否存在来判断渲染阶段(<code>render pass</code>) <code>NUMBER</code> 是否正在执行,
</p>

<p>
<code>uniform sampler2D u_buffer[NUMBER]</code> 储存了渲染阶段 <code>NUMBER</code> 的渲染结果;
</p>

<p>
这样就把一个 <code>Shader</code> 划分成三个渲染阶段: 先是 <code>BUFFER_0</code>, 再到 <code>BUFFER_1</code>, 最后是 <code>BUFFER_2</code>.
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#version</span> 130

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">filename: dip-sobel-buffers.frag
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">run: glslViewer dip-sobel-buffers.frag textures/fallout-4k-game-artwork-80.jpg
</span>
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_tex0;

<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iChannel0 u_tex0

<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_buffer0;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_buffer1;

<span style="color: #98fb98;">vec4</span> grayscale(<span style="color: #98fb98;">vec4</span> col) {
  <span style="color: #98fb98;">float</span> gray = <span style="color: #b0c4de;">dot</span>(col.rgb, <span style="color: #98fb98;">vec3</span>(0.299, 0.587, 0.114));
  <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(gray), col.a);
}

<span style="color: #98fb98;">vec4</span> convolution(<span style="color: #98fb98;">vec2</span> uv, <span style="color: #98fb98;">float</span>[9] kernel, <span style="color: #98fb98;">vec4</span>[9] pixels) {
  <span style="color: #98fb98;">vec4</span> conv = <span style="color: #98fb98;">vec4</span>(0.0);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt;= 2; i++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 0; j &lt;= 2; j++) {
      <span style="color: #98fb98;">int</span> index = j * 3 + i;
      conv += pixels[index] * kernel[index];
    }
  }
  <span style="color: #00ffff;">return</span> conv;
}

<span style="color: #98fb98;">void</span> main () {
  <span style="color: #98fb98;">vec2</span> uv = <span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy;

<span style="color: #b0c4de;">#if</span> defined(BUFFER_0)
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">GrayScale
</span>  <span style="color: #98fb98;">vec4</span> col = <span style="color: #b0c4de;">texture</span>(iChannel0, uv);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = grayscale(col);

<span style="color: #b0c4de;">#elif</span> defined(BUFFER_1)

  <span style="color: #98fb98;">vec2</span> steps = 1.0 / iResolution.xy;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pixel Sampling
</span>  <span style="color: #98fb98;">vec4</span> pixels[9];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = -1; i &lt;= 1; i++) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1, 1] =&gt; [0, 2]
</span>    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 1; j &gt;= -1; j--) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[1, -1] =&gt; [0, 2]
</span>      <span style="color: #98fb98;">int</span> index = (-j + 1) * 3 + (i + 1);
      <span style="color: #98fb98;">vec4</span> c = <span style="color: #b0c4de;">texture</span>(u_buffer0, uv + <span style="color: #98fb98;">vec2</span>(<span style="color: #98fb98;">float</span>(i) * steps.x, <span style="color: #98fb98;">float</span>(j) * steps.y));
      pixels[index] = c;
    }
  }

  <span style="color: #98fb98;">float</span> avg = 1.0 / 9.0;
  <span style="color: #98fb98;">float</span> kernel[9] = <span style="color: #98fb98;">float</span>[9](avg, avg, avg, avg, avg, avg, avg, avg, avg);
  <span style="color: #98fb98;">vec4</span> conv = convolution(uv, kernel, pixels);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(conv.rgb, 1.0);

<span style="color: #b0c4de;">#else</span>
  <span style="color: #98fb98;">vec2</span> steps = 1.0 / iResolution.xy;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pixel Sampling
</span>  <span style="color: #98fb98;">vec4</span> pixels[9];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = -1; i &lt;= 1; i++) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1, 1] =&gt; [0, 2]
</span>    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 1; j &gt;= -1; j--) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[1, -1] =&gt; [0, 2]
</span>      <span style="color: #98fb98;">int</span> index = (-j + 1) * 3 + (i + 1);
      <span style="color: #98fb98;">vec4</span> c = <span style="color: #b0c4de;">texture</span>(u_buffer1, uv + <span style="color: #98fb98;">vec2</span>(<span style="color: #98fb98;">float</span>(i) * steps.x, <span style="color: #98fb98;">float</span>(j) * steps.y));
      pixels[index] = c;
    }
  }
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Sobel
</span>  <span style="color: #98fb98;">float</span> kernel_x[9] = <span style="color: #98fb98;">float</span>[9](-1, 0, 1, -2, 0, 2, -1, 0, 1);
  <span style="color: #98fb98;">float</span> kernel_y[9] = <span style="color: #98fb98;">float</span>[9](1, 2, 1, 0, 0, 0, -1, -2, -1);
  <span style="color: #98fb98;">vec4</span> conv_x = convolution(uv, kernel_x, pixels);
  <span style="color: #98fb98;">vec4</span> conv_y = convolution(uv, kernel_y, pixels);
  <span style="color: #98fb98;">vec4</span> g = <span style="color: #b0c4de;">sqrt</span>(conv_x * conv_x + conv_y * conv_y);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(1. - g.rgb, 1.0);
<span style="color: #b0c4de;">#endif</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-laplacian" class="outline-3">
<h3 id="laplacian">拉普拉斯核 (Laplacian 核)</h3>
<div class="outline-text-3" id="text-laplacian">
<p>
在图像处理中, 拉普拉斯核的作用是对图像的二阶导数进行二维各向同性(<code>isotropic</code>, 在各个方向上性质相同)度量, 突出边缘以及突变区域.
</p>

<p>
因此, 拉普拉斯核也能用在边缘检查上. 与 <code>Sobel</code> 核不同的地方在于, <code>Sobel</code> 核实际上使用了两个核, 拉普拉斯核只用了一个核.
</p>

<p>
由于拉普拉斯核测量的是二阶导数, 可以找出变化速率较大的地方, 也导致了处理结果对图片的噪声非常敏感.
</p>

<p>
另外, 拉普拉斯核不像 <code>Sobel</code> 核那样依赖方向, 因此可以检查所有方向, 斜边边缘的检查效果优于 <code>Sobel</code> 核.
</p>

<p>
分别求出在 \(x\) 和 \(y\) 轴两个正交方向上的二阶导数近似:
</p>

<p>
二阶导数的近似可以通过泰勒展开推导出来, 首先有 \(\begin{cases} f(x + h) \approx f(x) + h f^{'}(x) + \frac{h^2}{2!} f^{''}(x)\\ f(x - h) \approx f(x) - h f^{'}(x) + \frac{h^2}{2!} f^{''}(x) \end{cases}\),
</p>

<p>
然后两者相加 \(f(x + h) + f(x - h) \approx 2f(x) + h^2 f^{''}(x) \rightarrow f^{''}(x) \approx \frac{f(x + h) + f(x - h) - 2f(x)}{h^2}\),
</p>

<p>
令 \(h = 1\) 可得 \(f^{''}(x) \approx f(x + 1) + f(x - 1) - 2f(x)\).
</p>

<p>
利用该方法可以快速得到两个方向上的二阶导数: \(\begin{cases} \frac{\partial^2 G(x, y)}{\partial x^2} = G(x + 1, y) + G(x - 1, y) - 2 G(x, y) \\ \frac{\partial^2 G(x, y)}{\partial y^2} = G(x, y + 1) + G(x, y - 1) - 2 G(x, y) \end{cases}\),
</p>

<p>
其中, \(G(x, y)\) 是位于 \((x, y)\) 的像素的值.
</p>

<p>
对这两个二阶导数进行求和就能得出拉普拉斯核: \(G(x + 1, y) + G(x - 1, y) + G(x, y + 1) + G(x, y - 1) - 4 G(x, y)\),
</p>

<p>
把系数按照位置整理成矩阵: \(\left( \begin{array}{c} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{array} \right)\).
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #b0c4de;">#version</span> 130

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">filename: dip-laplacian.frag
</span><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">run: glslViewer dip-laplacian.frag fallout-4k-game-artwork.jpg
</span>
<span style="color: #b0c4de;">#ifndef</span> PLATFORM_WEBGL
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec2</span> u_resolution;
<span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_tex0;

<span style="color: #b0c4de;">#define</span> iResolution u_resolution
<span style="color: #b0c4de;">#define</span> iChannel0 u_tex0
<span style="color: #b0c4de;">#endif</span>

<span style="color: #98fb98;">vec4</span> convolution(<span style="color: #98fb98;">vec2</span> uv, <span style="color: #98fb98;">float</span>[9] kernel, <span style="color: #98fb98;">vec4</span>[9] pixels) {
  <span style="color: #98fb98;">vec4</span> conv = <span style="color: #98fb98;">vec4</span>(0.0);
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt;= 2; i++) {
    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 0; j &lt;= 2; j++) {
      <span style="color: #98fb98;">int</span> index = j * 3 + i;
      conv += pixels[index] * kernel[index];
    }
  }
  <span style="color: #00ffff;">return</span> conv;
}

<span style="color: #98fb98;">void</span> main () {
  <span style="color: #98fb98;">vec2</span> uv = <span style="color: #eedd82;">gl_FragCoord</span>.xy / iResolution.xy;
  <span style="color: #98fb98;">vec2</span> steps = 1.0 / iResolution.xy;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Pixel Sampling
</span>  <span style="color: #98fb98;">vec4</span> pixels[9];
  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = -1; i &lt;= 1; i++) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[-1, 1] =&gt; [0, 2]
</span>    <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> j = 1; j &gt;= -1; j--) { <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">[1, -1] =&gt; [0, 2]
</span>      <span style="color: #98fb98;">int</span> index = (-j + 1) * 3 + (i + 1);
      <span style="color: #98fb98;">vec4</span> c = <span style="color: #b0c4de;">texture</span>(iChannel0, uv + <span style="color: #98fb98;">vec2</span>(<span style="color: #98fb98;">float</span>(i) * steps.x, <span style="color: #98fb98;">float</span>(j) * steps.y));
      pixels[index] = c;
    }
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">GrayScale
</span>  <span style="color: #00ffff;">for</span> (<span style="color: #98fb98;">int</span> i = 0; i &lt; pixels.<span style="color: #b0c4de;">length</span>(); i++) {
    <span style="color: #98fb98;">float</span> gray = <span style="color: #b0c4de;">dot</span>(pixels[i].rgb, <span style="color: #98fb98;">vec3</span>(0.299, 0.587, 0.114));
    pixels[i] = <span style="color: #98fb98;">vec4</span>(<span style="color: #98fb98;">vec3</span>(gray), pixels[i].a);
  }

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">Laplacian
</span>  <span style="color: #98fb98;">float</span> kernel[9] = <span style="color: #98fb98;">float</span>[9](0, 1, 0, 1, -4, 1, 0, 1, 0);
  <span style="color: #98fb98;">vec4</span> conv = convolution(uv, kernel, pixels);
  <span style="color: #ffc0cb; font-weight: bold;">gl_FragColor</span> = <span style="color: #98fb98;">vec4</span>(1. - conv.rgb, 1.0);
}
</pre>
</div>


<div id="orga02ee6e" class="figure">
<p><img src="../../../files/dip-laplacian-result.png" alt="dip-laplacian-result.png" width="600px">
</p>
<p><span class="figure-number">Figure 41: </span>处理结果</p>
</div>

<blockquote>
<p>
等一下, 为什么只需要 \(x\) 和 \(y\) 轴两个方向的导数就说可以检查所有方向?
</p>

<p>
这涉及到了多元标量值函数的可微定义: \(dz = \frac{\partial f(x, y)}{\partial x} dx + \frac{\partial f(x, y)}{\partial y} dy = \langle \frac{\partial f(x, y)}{\partial x}, \frac{\partial f(x, y)}{\partial y} \rangle \cdot \langle dx, dy \rangle\) 存在,
</p>

<p>
与方向导数定义的形式一致, 可微的另外一个表达正好是所有方向上都存在方向导数,
</p>

<p>
\(\langle dx, dy \rangle\) 就是一个任意的线性组合, 也就是任意方向.
</p>

<p>
这对于二阶导数也是成立的, 把一阶导数看作是一个新函数, 把二阶导数看作是新函数的一阶导数,
</p>

<p>
两个新一阶导数之和不就是拉普拉斯核吗.
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2024-03-02</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.2 (<a href="https://orgmode.org">Org</a> mode 9.7.11)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
