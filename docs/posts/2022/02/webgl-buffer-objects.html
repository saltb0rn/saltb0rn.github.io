<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-05-25 Sun 17:51 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shader 编程自救指南</title>
<meta name="author" content="saltb0rn" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"> -->
<meta name="referrer" content="same-origin">
<link rel="stylesheet" type="text/css" href="../../../css/stylesheet.css"/>
<link rel="icon" type="image/png" href="../../../img/icon.png" />
<!-- <script type="text/javascript" src="../../../js/live.js" defer></script> -->
<script src="../../../js/main.js" defer></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="../../../js/mathjax/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
    <nav>
        <a href="../../../"><img src="../../../img/logo.png" alt="Logo is on the way"/></a>
        <ul>
            <li><a accesskey="H" href="../../../"> Home </a></li>
            <li><a accesskey="T" href="../../../tags"> Tags </a></li>
            <li><a accesskey="A" href="../../../about"> About </a></li>
            <li><a accesskey="L" href="../../../todos"> Todos </a></li>
        </ul>
    </nav>
</div>
<div id="content" class="content">
<h1 class="title">Shader 编程自救指南</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#how-gl-works">Shader 是如何工作的</a>
<ul>
<li><a href="#org9ddb762">Vertex Shader</a></li>
<li><a href="#org2983e23">Vertex Shader 之后, Fragment Shader 之前</a></li>
<li><a href="#org8902a27">Fragment Shader</a></li>
<li><a href="#org951fb66">Fragment Shader 之后 - Per-Sample Processing</a></li>
</ul>
</li>
<li><a href="#orgcf51652">一个简单而完整的 Shader 程序</a>
<ul>
<li><a href="#how-cpu-upload-data">CPU 如何上传数据给 GPU</a></li>
<li><a href="#how-gl-use-data">GPU 如何从缓冲读取数据</a></li>
<li><a href="#org44589a6">如何使用缓冲的数据进行绘制</a></li>
<li><a href="#glsl-type-qualifier-overview">GLSL 变量修饰符(Variable Qualifiers / Type Qualifiers)</a>
<ul>
<li><a href="#org0eec349">attribute</a></li>
<li><a href="#orge6b5e05">uniform</a></li>
</ul>
</li>
<li><a href="#org00ef420">GLSL 内置变量</a></li>
<li><a href="#org492c943">其它常见问题</a></li>
</ul>
</li>
<li><a href="#org58a2ac2">WebGL 的 API 概览</a>
<ul>
<li><a href="#orgd9f989b">缓冲 (Buffer)</a></li>
<li><a href="#org5509707">贴图 (Texture)</a></li>
<li><a href="#org6b42b40">帧缓冲 (FrameBuffer)</a></li>
</ul>
</li>
<li><a href="#orgf85c7ed">搭建自己的 Shadertoy</a></li>
</ul>
</div>
</div>
<div class="abstract" id="orgf0e40bd">
<p>
由于去年换了工作, 生活变得充实起来了, 这里的充实并非反话, 我在这段时间调整了心态和目标, 学习了一些新的知识;
</p>

<p>
为了学习游戏开发, 定制了新的学习目标, 包括音乐, 编剧, 使用 <code>Blender</code> 建模以及 <code>Godot</code> 的使用等等;
</p>

<p>
同时由于工作繁忙的原因, 图形学学习计划搁置了一年, 当时就停留在贴图映射的阶段.
</p>

<p>
另外搁置搁置还有一个原因, 那就是当时在学习贴图映射时所在的参考书有点不太易懂,
</p>

<p>
所以需要找一本更易读的书, 我找到了 <a href="https://gabrielgambetta.com/computer-graphics-from-scratch/">Computer Graphics from Scratch</a>, 但这本书当前还没完成编写 (其实 21 年就写完了), 因此决定等它出版了再继续学.
</p>

<p>
虽然这篇文章名字叫做 <code>Shader</code> 编程自救指南, 但主要是介绍 <code>Shader</code> 程序是如何工作的, 主要涉及渲染管线的一些细节以及 <code>OpenGL/WebGL</code> 的概念和 <code>API</code>.
</p>

<p>
与 <code>Shader</code> 编程本身没有太大的关系, 有点类似与学习编程语言和学习编程之间的区别, <code>Shader</code> 编程的重点是图形学内容和数学技巧, 之后会单独写一片文章来介绍这一块.
</p>

<hr>

<p>
PS: 现在是 2023 年 12 月, 从今年的 6 月份才发现这本书已经写完了, 于是平时抽空一点一点地读了半年, 终于读完这本书, 期间使用 <code>C</code> 语言按照书上的伪代码实践了一遍.
</p>

<p>
个人感觉等待这本书的完成是一个正确的选择, 它指导了我编写两个完整的渲染器, 简单易懂地解释了图形学里面一些较为复杂的算法.
</p>

<p>
我本人在读这本书之前就已经较为深入地学习了一些 <a href="../..//2020/06/graphics-geometric-transformation.html">数学细节</a> 以及 <a href="../../2020/06/graphics-opengl-transformation.html">OpenGL的渲染管线</a>,
</p>

<p>
在跟着书本实践时特地找出这些知识和实践的对应之处, 学习效果非常地好.
</p>

<p>
这本书清晰了我在学习渲染管线时的一些迷糊之处, 而之前所学的数学细节以及渲染管线知识又很好地弥补了这本书在这方面的空缺.
</p>

<p>
现在回过头来看 <code>Shader</code> 程序如何运作时, 很多东西都豁然开朗了.
</p>

</div>
<div id="outline-container-how-gl-works" class="outline-2">
<h2 id="how-gl-works">Shader 是如何工作的</h2>
<div class="outline-text-2" id="text-how-gl-works">
<p>
为了了解 <code>Shader</code> 是如何工作的, 我们将从最简单的 <code>WebGL</code> 开始上手,
</p>

<p>
<code>WebGL</code> 和 <code>OpenGL</code> 的工作方式基本上是一致的, 主要区别在于对工具的要求上,
</p>

<p>
<code>WebGL</code> 只要求掌握一点 <code>JavaScript/HTML</code> 就可以了;
</p>

<p>
而对于 <code>OpenGL</code>, 很多教程都是要求读者使用 <code>C/C++</code> 来完成的, 而使用 <code>C/C++</code> 又掌握如何使用编译器以及 <code>makefile/cmake</code> 这样控制编译连接的工具的使用, 不是简单的事情.
</p>

<p>
要想了解 <code>Shader</code> 如何工作什么的, 其实和了解 <code>OpenGL</code> 是一样的, 离不开对渲染流程的了解.
</p>

<p>
开发人员所关心的 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 就是整个渲染流程里其中的两个环节.
</p>

<p>
我一开始是找了关于这块不错的教程来进行学习:
</p>

<p>
<a href="https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL Fundamentals 的 WebGL是如何工作的</a>
</p>

<p>
<a href="https://webgl2fundamentals.org/webgl/lessons/webgl-how-it-works.html">WebGL2 Fundamentals 的 WebGL是如何工作的</a>
</p>

<p>
但很快就发现一个问题: 初学者只看这两个阶段的话其实就是在断章取义, 是难以理解它们是如何工作的, 特别是 <code>Fragment Shader</code>, 看别人的 <code>Shader</code> 还是一头雾水.
</p>

<p>
回过头去看官方的 <a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">渲染流程概览</a>, 又发现里面的内容不太好理解, 于是乎决定把它们结合在一起进行理解, 接下来就是个人理解了.
</p>

<p>
在这之前要了解一件事情, 随着 <code>OpenGL</code> 版本的变化, 渲染流程时会发生变化的, <code>WebGL</code> 也是一样.
</p>

<p>
因此, 这篇文章里面的例子只关注特定版本的 <code>WebGL</code>: <code>WebGL 1.0</code>, 它对应的 <code>GLSL</code> 版本是 <a href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.1.20.pdf">1.20</a>.
</p>

<blockquote>
<p>
由于历史原因, <code>OpenGL/OpenGL ES/WebGL</code> 和 <code>GLSL</code> 之间的版本对应关系挺混乱的, 幸好维基百科上有列出<a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language#Versions">对应关系</a>.
</p>

<p>
如果不了解这一块的话, 你无法知道你的 <code>Shader</code> 程序能够运行在什么环境上的.
</p>
</blockquote>

<p>
接下来着重介绍 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 及其前后的几个阶段.
</p>
</div>
<div id="outline-container-org9ddb762" class="outline-3">
<h3 id="org9ddb762">Vertex Shader</h3>
<div class="outline-text-3" id="text-org9ddb762">
<p>
<code>Vertex Shader</code> 根据几何数据(geometry data)计算出裁剪空间(clip space)的顶点坐标, 也就是投影坐标.
</p>

<p>
所谓的几何数据就是指顶点数据, 这些数据来自于 <code>CPU</code> 程序的上传(后面会详细介绍), 每当接收一个几何数据, <code>Vertex Shader</code> 就运行一遍,
</p>

<p>
如下图所示:
</p>


<div id="org4ac6c5a" class="figure">
<p><img src="../../../files/vertex-shader-anim.gif" alt="vertex-shader-anim.gif">
</p>
<p><span class="figure-number">Figure 1: </span>Vertex Shader 对顶点数据进行处理 (图片来源于上述链接)</p>
</div>

<p>
由于 <code>Vertex Shader</code> 可以自定义, 所以该计算过程不是固定的.
</p>

<p>
一个顶点数据并非只有一个顶点坐标, 还可能有顶点颜色, 顶点法线以及顶点贴图坐标等等.
</p>

<p>
<code>Vertex Shader</code> 要做的事情只有两件:
</p>

<ol class="org-ol">
<li>把 <code>gl_Position</code> 的值设置为裁剪坐标, 以次把裁剪坐标传递到后面的流程中</li>
<li>定义 <code>varying</code> 类型变量, 给 <code>varying</code> 变量的值设置为可选数据, 以此把可选数据传递到后面的流程中</li>
</ol>
</div>
</div>
<div id="outline-container-org2983e23" class="outline-3">
<h3 id="org2983e23">Vertex Shader 之后, Fragment Shader 之前</h3>
<div class="outline-text-3" id="text-org2983e23">
<p>
在 <code>Vertex Shader</code> 之后并非马上就到 <code>Fragment Shader</code> 了, 这期间会发生一切其他事情.
</p>

<p>
<b>图元组装 (Primitive Assembly)</b>
</p>

<p>
在通过 <code>Vertex Shader</code> 处理完所有输入的顶点数据之后, <code>OpenGL</code> 会按照一定规律把输出的顶点组合在一起形成一个几何对象, 比如说把每三个顶点组合一个三角形, 这种由若干个顶点组合而成的几何对象就叫做图元(primitive).
</p>

<p>
在计算机中, <code>3D</code> 物体就是由多个面(或者说图元)组成的.
</p>

<blockquote>
<p>
当然 <code>OpenGL/WebGL</code> 只支持几种基本的规律, 根据这几种规律组合而成的图元叫做基本图元(<code>basic primitive</code>), 包括点 (<code>GL_POINTS</code>), 直线 (<code>GL_LINES</code>), 三角形 (<code>GL_TRIANGLES</code>) 以及它们的派生, 具体可以看 <a href="https://www.khronos.org/opengl/wiki/Geometry_Shader#Primitive_in.2Fout_specification">OpenGL 图元规范</a>.
</p>
</blockquote>

<p>
<b>裁剪 (Cliping)</b>
</p>

<p>
<code>OpenGL/WebGL</code> 会把超出视野的图元或图元部分进行裁剪, 就像人一样, 看不了视野以外的东西.
</p>

<p>
这一步会对裁剪坐标进行透视除法得到 <code>NDC</code> 坐标, 再对 <code>NDC</code> 坐标进行视口变换得到屏幕空间(<code>screen space</code>)上的坐标.
</p>

<p>
<b>面剔除 (Face Culling)</b>
</p>

<p>
<code>OpenGL/WebGL</code> 可以检测得到图元面向是正面还是背面观察者(viewer)的, 就如我们生活中看到的物体一样,
</p>

<p>
一个时间点内只能在一个角度看到它, 看得到就是正面, 看不到的就是背面, 那么背面也是在视野之外的.
</p>

<p>
<code>OpenGL/WebGL</code> 可以让开发者决定是否取消对物体背面的渲染.
</p>

<p>
<b>光栅化 (Rasterization)</b>
</p>

<p>
在阶段会把一个图元拆分成若干个片元(<code>fragments</code>), 所谓片元就是一种类像素数据(<code>pixel-like data</code>),
</p>

<p>
我们可以先把像素(pixel)定义为显示在屏幕上的一个小方块, 该小方块可以显示某个颜色.
</p>

<p>
片元可以记录小方块在画面上的位置以及颜色, 也可能和有一些与之关联的可选数据,
</p>

<p>
这些可选数据是根据 <code>Vertex Shader</code> 定义的 <code>varying</code> 变量所传递的可选数据计算得来.
</p>


<div id="org64a2119" class="figure">
<p><img src="../../../files/opengl-rasterization.gif" alt="opengl-rasterization.gif">
</p>
</div>

<p>
比如动画中的这个过程就是对一个三角形图元进行采样(sampling)得到一个由方块组成的近似三角形, 这些方块就是片元.
</p>

<blockquote>
<p>
你可以把采样理解为从一个连续对象上抽取若干个数据形成一个不连续的序列, 该序列和连续对象近似乎;
</p>

<p>
我们把这些抽出来的数据叫做样本(samples), 样本数量越多, 得到的序列就和连续对象越像.
</p>

<p>
这就是数学里面微分的思想.
</p>
</blockquote>

<p>
然而, <code>OpenGL/WebGL</code> 是如何在只知道顶点的信息的情况下把中间部分的点给补全呢?
</p>

<p>
首先, 在前面的裁剪步骤中已经根据顶点的裁剪坐标计算出屏幕坐标了, 也就是顶点对应的片元坐标;
</p>

<p>
再根据这些片元坐标通过线性插值(interpolation)来补充缺失的片元, 从而构造出由方块组成的近似三角形.
</p>


<div id="org55fdd24" class="figure">
<p><img src="../../../files/trianglerast_f1_joshbeam.png" alt="trianglerast_f1_joshbeam.png">
</p>
<p><span class="figure-number">Figure 2: </span>三个顶点所对应的片元坐标</p>
</div>

<p>
线性插值的原理很简单, 就是 \(y = y_{0} + \frac{y_{1} - y_{0}}{x_{1} - x_{0}} \times t(x_{1} - x_{0}),\ \mathrm{where}\ 0 \le t \le 1\).
</p>

<p>
也可以这么表述: \(y = y_{0} + \frac{y_{1} - y_{0}}{x_{1} - x_{0}} \times (x - x_{0}),\ \mathrm{where}\ \min(x_{0}, x_{1}) \le x \le\ \max(x_{0}, x_{1})\).
</p>

<p>
再换句话说就是找出 \((x_{0}, y_{0})\) 和 \((x_{1}, y_{1})\) 两点线段上的一个点 \((x, y)\), 这个点就是缺失片元的坐标.
</p>

<p>
由于片元是一格一格的, 因此两个相邻的片元必定在 \(x\) 轴/\(y\) 轴/同时在 \(x\) 和 \(y\) 轴方向上相差一个单位.
</p>

<p>
所以我们的插值代码如下:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">/*</span>
<span style="color: #ff7f24;">  i0: int</span>
<span style="color: #ff7f24;">  i1: int</span>

<span style="color: #ff7f24;">  d0: decimal</span>
<span style="color: #ff7f24;">  d1: decimal</span>
<span style="color: #ff7f24;">*/</span>
<span style="color: #00ffff;">function</span> <span style="color: #87cefa;">interpolate</span>(<span style="color: #eedd82;">i0</span>, <span style="color: #eedd82;">d0</span>, <span style="color: #eedd82;">i1</span>, <span style="color: #eedd82;">d1</span>) {
  <span style="color: #00ffff;">if</span> (i0 == i1) {
    <span style="color: #00ffff;">return</span> [d0];
  }

  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">values</span> = [];
  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">a</span> = (d1 - d0) / (i1 - i0);
  <span style="color: #00ffff;">var</span> <span style="color: #eedd82;">d</span> = d0;
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">incrementing i by 1 is because the difference between each two adjacent pixels is 1</span>
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">var</span> <span style="color: #eedd82;">i</span> = i0; i &lt;= i1; i++) {
    values.push(d);
    d += a;
  }

  <span style="color: #00ffff;">return</span> values;
}
</pre>
</div>

<p>
在传参时, 可以选择两个点的 \(x\) 分量来作为 \(i0\) 和 \(i1\), 让 \(y\) 分量作为 \(d0\) 和 \(d1\);
</p>

<p>
也可以选择 \(y\) 分量作为 \(i0\) 和 \(i1\), 让 \(x\) 分量作为 \(d0\) 和 \(d1\).
</p>

<p>
这取决于 \(\left|x1 - x0\right|\) 和 \(\left|y1 - y0\right|\) 两者之间哪个大.
</p>

<p>
观察代码, 如果 \(\left|i1 - i0\right|\) 比 \(\left|d1 - d0\right|\) 要小, 那么 \(\left|a\right|\) 就要大于 1,
</p>

<p>
因为函数 <code>interprolate</code> 的参数是坐标分量, 所以 \(\left|a\right|\) 大于 1 表示这坐标之间相差两个单位, 与相邻片元相差一个单位矛盾.
</p>

<p>
比如, 以 \(x\) 分量作为 \(i0\) 和 \(i1\), 并且 \(a = 2\), 那么 \((10, 20)\) 的下一个插值坐标是 \((11, 22)\);
</p>

<p>
但如果以 \(y\) 作为 \(i0\) 和 \(i1\), 那么 \(a = \frac{1}{2}\), 那么 \((10, 20)\) 的下一个插值坐标是 \((11, \lfloor 20.5 \rfloor)\), 这种情况片元就是相邻的.
</p>

<p>
使用 <code>interpolate</code> 函数很容易就能画出一个三角形边线框.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#38656;&#35201;&#27880;&#24847;&#30340;&#26159;, p0 p1 p2 &#19977;&#20010;&#22352;&#26631;&#30340;&#20998;&#37327;&#26159; decimal &#31867;&#22411;, &#36825;&#26159;&#20174;&#35009;&#21098;&#31354;&#38388;&#36716;&#25442;&#21040;&#23631;&#24149;&#31354;&#38388;&#24471;&#21040;&#30340;&#32467;&#26524;;</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#32780;&#23631;&#24149;&#31354;&#38388;&#19978;&#30340;&#20687;&#32032;&#20998;&#37327;&#26159; int &#31867;&#22411;, &#22240;&#27492;&#25105;&#20204;&#38656;&#35201;&#22312;&#20851;&#38190;&#26102;&#20505;&#23545;&#20998;&#37327;&#36827;&#34892;&#21462;&#25972;,</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22914;&#26524;&#20801;&#35768;&#30340;&#35805;,&#26368;&#22909;&#22312;&#35745;&#31639;&#36807;&#31243;&#30340;&#26368;&#21518;&#19968;&#27493;&#32473;&#35745;&#31639;&#32467;&#26524;&#21462;&#25972;&#26469;&#20445;&#35777;&#32467;&#26524;&#23613;&#37327;&#31934;&#30830;.</span>

<span style="color: #00ffff;">if</span> (Math.abs(p1.x - p0.x) &gt; Math.abs(p1.y - p0.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys01</span> = interpolate(p0.x | 0, p0.y, p1.x | 0, p1.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p0.x; x &lt;= p1.x; x++) {
    putPixel(x | 0, ys01[(x - p0.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs01</span> = interpolate(p0.y | 0, p0.x, p1.y | 0, p1.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p1.y; y++) {
    putPixel(xs01[(y - p0.y) | 0] | 0, y | 0);
  }
}

<span style="color: #00ffff;">if</span> (Math.abs(p2.x - p1.x) &gt; Math.abs(p2.y - p1.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys12</span> = interpolate(p1.x | 0, p1.y, p2.x | 0, p2.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p1.x; x &lt;= p2.x; x++) {
    putPixel(x | 0, ys12[(x - p1.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs12</span> = interpolate(p1.y | 0, p1.x, p2.y | 0, p2.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p1.y; y &lt;= p2.y; y++) {
    putPixel(xs12[(y - p1.y) | 0] | 0, y | 0);
  }
}

<span style="color: #00ffff;">if</span> (Math.abs(p2.x - p0.x) &gt; Math.abs(p2.y - p0.y)) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ys02</span> = interpolate(p0.x | 0, p0.y, p2.x | 0, p2.y);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = p0.x; x &lt;= p2.x; x++) {
    putPixel(x | 0, ys02[(x - p0.x) | 0] | 0);
  }
} <span style="color: #00ffff;">else</span> {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">xs02</span> = interpolate(p0.y | 0, p0.x, p2.y | 0, p2.x);
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
    putPixel(xs02[(y - p0.y) | 0] | 0, y | 0);
  }
}
</pre>
</div>


<div id="org60cdb4e" class="figure">
<p><img src="../../../files/trianglerast_f2_joshbeam.png" alt="trianglerast_f2_joshbeam.png">
</p>
<p><span class="figure-number">Figure 3: </span>三角形线框</p>
</div>

<p>
绘制填充三角形则复杂一点, 不过很好理解, 它 <code>OpenGL/WebGL</code> 绘制图形的重点.
</p>

<p>
可以把一个三角形看作一个由多层横线组成的的图形, 每一层的高度为一个像素;
</p>

<p>
计算出每一层的两个端点, 再根据每层的两端点进行插值绘制出直线, 这些直线构成的就是目标三角形.
</p>


<div id="org9328fd7" class="figure">
<p><img src="../../../files/trianglerast_f3_joshbeam_aux.png" alt="trianglerast_f3_joshbeam_aux.png">
</p>
<p><span class="figure-number">Figure 4: </span>实心三角形</p>
</div>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#39318;&#20808;&#38656;&#35201;&#23545; p0 p1 p2 &#19977;&#20010;&#29255;&#20803;&#22352;&#26631;&#26681;&#25454; $y$ &#20998;&#37327;&#36827;&#34892;&#20132;&#25442;&#25490;&#24207;, &#27604;&#22914;&#20174;&#23567;&#21040;&#22823;&#36827;&#34892;&#25490;&#24207;: p0.y &lt;= p1.y &lt;= p2.y</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36825;&#26679;&#21487;&#20197;&#36991;&#20813;&#35752;&#35770;&#21738;&#20010;&#28857;&#26368;&#39640;,&#21738;&#20010;&#28857;&#26368;&#20302;</span>
<span style="color: #00ffff;">if</span> (p1.y &lt; p0.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p0;
  p0 = p1;
  p1 = temp;
}

<span style="color: #00ffff;">if</span> (p2.y &lt; p0.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p0;
  p0 = p2;
  p2 = temp;
}

<span style="color: #00ffff;">if</span> (p2.y &lt; p1.y) {
  <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">temp</span> = p1;
  p1 = p2;
  p2 = temp;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#19977;&#35282;&#24418;&#26368;&#39640;&#30340;&#19968;&#26465;&#36793;&#30475;&#20316;&#26159;&#19968;&#20010;&#31471;&#28857;&#38598;&#21512;, &#25226;&#21478;&#22806;&#20004;&#26465;&#36793;&#30340;&#38598;&#21512;&#30475;&#20316;&#21478;&#22806;&#19968;&#20010;&#31471;&#28857;&#38598;&#21512;</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#27880;&#24847;, &#36825;&#37324;&#30340;&#26368;&#39640;&#36793;&#26159; p0 &#36830;&#25509; p2 &#30340;&#36793;, &#21478;&#22806;&#20004;&#26465;&#36793;&#20998;&#21035;&#26159; p0 &#36830;&#25509; p1 &#21644; p1 &#36830;&#25509; p2</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312;&#24050;&#30693;&#29255;&#20803;&#30340; y &#20998;&#37327;&#26102;, &#21487;&#20197;&#25554;&#20540;&#20986;&#29255;&#20803;&#23545;&#24212;&#30340; x &#20998;&#37327;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x01</span> = interpolate(p0.y | 0, p0.x, p1.y | 0, p1.x);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x12</span> = interpolate(p1.y | 0, p1.x, p2.y | 0, p2.x);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x02</span> = interpolate(p0.y | 0, p0.x, p2.y | 0, p2.x);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23454;&#38469;&#19978;, p0-p2 &#30340;&#36793;&#39640;&#24230;&#26159;&#19982; p0-p1 + p1-p2 &#30340;&#39640;&#24230;&#26159;&#19968;&#26679;&#30340;, &#21487;&#20197;&#25226; p0-p1-p2 &#21333;&#29420;&#30475;&#20316;&#26159;&#19968;&#26465;&#36793;</span>
x01.pop(); <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">x01 &#30340;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#21644; x12 &#30340;&#31532;&#19968;&#20010;&#20803;&#32032;&#37325;&#22797;&#23454;&#38469;&#19978;&#26159;&#21516;&#19968;&#20010;&#29255;&#20803;&#30340; x &#20998;&#37327;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">x012</span> = x01.concat(x12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25509;&#19979;&#26469;&#21482;&#35201;&#21306;&#20998; p0-p2 &#21644; p0-p1-p2 &#21738;&#20010;&#26159;&#24038;&#36793;&#21738;&#20010;&#26159;&#21491;&#36793;, &#20877;&#36827;&#34892;&#36880;&#34892;&#25554;&#20540;&#23601;&#21487;&#20197;&#32472;&#21046;&#20986;&#19977;&#35282;&#24418;&#20102;</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21306;&#20998;&#24038;&#21491;&#36793;&#30340;&#26041;&#27861;&#24456;&#31616;&#21333;, &#20998;&#21035;&#21462;&#20004;&#36793;&#30340;&#20013;&#38388;&#28857;&#30340; x &#20998;&#37327;&#36827;&#34892;&#23545;&#27604;&#21363;&#21487;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">m</span> = Math.floor(x02.length / 2);
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x_left</span>, <span style="color: #eedd82;">x_right</span>;
<span style="color: #00ffff;">if</span> (x02[m] &lt; x012[m]) {
  x_left = x02;
  x_right = x012;
} <span style="color: #00ffff;">else</span> {
  x_left = x012;
  x_right = x02;
}

<span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];
  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
以上就是 <code>OpenGL/WebGL</code> 绘制实心三角形的大致原理.
</p>

<p>
基于该过程, 还可以插值出之前说的可选数据, 只要在计算 <code>x01/x12/x02</code> 时进行类似插值就可以:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#31446;&#21521;&#36827;&#34892;&#25554;&#20540;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h01</span> = interpolate(p0.y | 0, p0.h, p1.y | 0, p1.h);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h12</span> = interpolate(p1.y | 0, p1.h, p2.y | 0, p2.h);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h02</span> = interpolate(p0.y | 0, p0.h, p2.y | 0, p2.h);
h01.pop();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h012</span> = h01.concat(h12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">h_left</span>, <span style="color: #eedd82;">h_right</span>;
<span style="color: #00ffff;">if</span> (x02[m]  &lt; x012[m]) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
  h_left = h02;
  h_right = h012;
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
  h_left = h012;
  h_right = h02;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];

  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hl</span> = h_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hr</span> = h_right[(y - p0.y) | 0];

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#27178;&#21521;&#36827;&#34892;&#25554;&#20540;</span>
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">hs</span> = interpolate(xl, hl, xr, hr);

  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#33719;&#21462;&#24403;&#21069;&#29255;&#20803;&#25152;&#23545;&#24212;&#30340;&#21487;&#36873;&#25968;&#25454; h, &#29992;&#22312;&#20043;&#21518;&#30340; fragment shader &#38454;&#27573;&#20013;</span>
    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">h</span> = hs[x - xl];
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
到止, 光栅化基本完成, <code>OpenGL/WebGL</code> 会把片元逐个输出到下一个阶段 <b>Fragment Shader</b>.
</p>

<blockquote>
<p>
实际上 <code>GPU</code> 是并行计算架构, 并非逐个片元这样传递, 我们这里只是为了方便理解才这么说是 <b>逐个传递</b> 的.
</p>

<p>
实情是每次以 \(2 \times 2\) 的片元作为单位进行传递的, 也就是一次要同时调用 4 个 <code>Fragment Shaders</code>.
</p>
</blockquote>

<p>
<code>OpenGL/WebGL</code> 会使用一些变量来传递片元数据, 比如 <code>gl_FragCoord</code> 会把片元对应的 \(x\) 和 \(y\) 分量一并传回;
</p>

<p>
<code>gl_FragCoord</code> 的类型是 <code>vec4</code>, 值是 \(\left(x, y, z, 1/w\right)\), 其中 \(x\) 和 \(y\) 就是片元对应的 \(x\) 和 \(y\) 分量,
</p>

<p>
上面的代码没有针对 \(z\) 分量进行插值, 因为它和 \(x\) 和 \(y\) 分量的插值略微不一样, 顶点之间的 \(z\) 分量并不存在线性关系, 无法直接插值,
</p>

<p>
反而是 \(\frac{1}{z}\) 之间成线性关系, 所以根据两个顶点的 \(z\) 分量的倒数 \(\frac{1}{z}\) 进行插值, 最后再倒回去:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#31446;&#21521;&#36827;&#34892;&#25554;&#20540;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz01</span> = interpolate(p0.y | 0, 1 / p0.z, p1.y | 0, 1 / p1.z);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz12</span> = interpolate(p1.y | 0, 1 / p1.z, p2.y | 0, 1 / p2.z);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz02</span> = interpolate(p0.y | 0, 1 / p0.z, p2.y | 0, 1 / p2.z);
iz01.pop();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz012</span> = iz01.concat(iz12);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">iz_left</span>, <span style="color: #eedd82;">iz_right</span>;
<span style="color: #00ffff;">if</span> (x02[m]  &lt; x012[m]) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
  iz_left = iz02;
  iz_right = iz012;
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
  iz_left = iz012;
  iz_right = iz02;
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">...</span>
<span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span> = p0.y; y &lt;= p2.y; y++) {
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xl</span> = x_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">xr</span> = x_right[(y - p0.y) | 0];

  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izl</span> = iz_left[(y - p0.y) | 0];
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izr</span> = iz_right[(y - p0.y) | 0];

  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#23545;&#21487;&#36873;&#25968;&#25454;&#25353;&#29031;&#27178;&#21521;&#36827;&#34892;&#25554;&#20540;</span>
  <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">izs</span> = interpolate(xl, izl, xr, izr);

  <span style="color: #00ffff;">for</span> (<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = xl; x &lt;= xr; x++) {
    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">iz</span> = izs[x - xl];
    <span style="color: #00ffff;">const</span> <span style="color: #eedd82;">z</span> = 1 / iz;
    putPixel(x | 0, y | 0);
  }
}
</pre>
</div>

<p>
同理, \(1/w\) 是根据顶点插值得到的 \(w\) 分量的倒数.
</p>

<p>
<code>gl_FragCoord</code> 这种是 <code>OpenGL/WebGL</code> 的内置变量, 用来传递特定用途的数据, 后面会介绍更多这一类的内置变量, 因为它们可能会在 <code>Shader</code> 程序中用得上.
</p>

<p>
而可选数据 \(h\) 则需要开发人员自定义 <code>varying</code> 类型或 <code>out</code> 类型变量进行传递, 我们马上就知道具体该怎么做.
</p>
</div>
</div>
<div id="outline-container-org8902a27" class="outline-3">
<h3 id="org8902a27">Fragment Shader</h3>
<div class="outline-text-3" id="text-org8902a27">
<p>
在得到片元后, <code>OpenGL/WebGL</code> 就开始对它们进行处理, 这就是 <code>Fragment Shader</code> <b>主要</b> 要做的事情了:
</p>

<p>
每次接受一个片元作为输入, 为片元设置颜色(设置 <code>gl_FragColor</code>), 以此把处理后的片元输出到下一个阶段中.
</p>

<p>
如果该片元最终能够呈现在屏幕上, 那么该颜色就作为像素的颜色.
</p>

<p>
为了了解具体是怎么实现的, 我们来看一个例子(基于 <code>WebGL 1.0/GLSL 1.20</code> 版本).
</p>

<blockquote>
<p>
在下面的绘制三角形的例子里面, <code>Vertex Shader</code> 根据三角形的顶点数据的坐标为它们定义颜色(, 这样每个顶点的颜色就不一样了);
</p>

<p>
<code>Vertex Shader</code> 中的 <code>vColor</code> 则是作为与 <code>gl_Position</code> 关联的可选数据.
</p>

<p>
在光栅化的过程中 <code>OpenGL/WebGL</code> 会根据 <code>Vertex Shader</code> 传递过来的 <code>gl_Position</code> 以及可选数据 <code>vColor</code> 进行插值, 得到片元坐标以及与之相关的可选数据.
</p>

<p>
片元的坐标会被保存在 <code>gl_FragCoord</code> 中; 对于可选数据 <code>vColor</code>, 会被保存到 <code>Fragment Shader</code> 的同名同类型的 <code>vColor</code> 变量上.
</p>

<p>
再次强调, 虽然在 <code>Vertex Shader</code> 和 <code>Fragment Shader</code> 上都有 <code>vColor</code>, 但是它们附属的对象是不一样的,
</p>

<p>
<code>Vertex Shader</code> 的 <code>vColor</code> 是属于顶点的, <code>Fragment Shader</code> 的 <code>vColor</code> 是属于片元的.
</p>

<p>
这样 <code>Fragment Shader</code> 就接受了一个片元以及其相关的可选数据, 根据开发人员的自身要求设置 <code>gl_FragColor</code>.
</p>

<p>
该例子里面的 <code>Fragment Shader</code> 把与片元关联的 <code>vColor</code> 设置为自己的颜色, 最后得到一个颜色渐变的三角形.
</p>

<p>
<iframe style="width: 520px; height: 1060px; border: none;" src="../../../examples/fragment-shader-example.html"></iframe>
</p>
</blockquote>

<p>
<code>Fragment Shader</code> <a href="https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_inputs">输入</a>和<a href="https://www.khronos.org/opengl/wiki/Fragment#Fragment_shader_outputs">输出</a>的片元数据结构是不一样的, 从这里开始我们进行一个约定: 在没有特别声明的情况下, 片元就是指 <code>Fragment Shader</code> 输出的片元.
</p>

<p>
相比于像素而言, 片元除了有 <code>RGBA</code> 格式的色值以外, 还有模板值(stencil value)和<a href="https://blog.darksalt.me/docs/posts/2020/06/graphics-opengl-transformation.html#text-depth-buffer">深度值</a>(depth value)这些信息.
</p>

<p>
需要知道这些数据的含义, 或者说理解片元, 那么得先了解 <code>Fragment Shader</code> 后面的 <code>Per-Sample Processing</code> 阶段做了什么.
</p>
</div>
</div>
<div id="outline-container-org951fb66" class="outline-3">
<h3 id="org951fb66">Fragment Shader 之后 - Per-Sample Processing</h3>
<div class="outline-text-3" id="text-org951fb66">
<p>
该阶段会使用上片元的这些额外值来进行<a href="https://www.khronos.org/opengl/wiki/Per-Sample_Processing">一系列的测试</a>, 来决定是否把该片元的色值输出到屏幕上成为像素,
</p>

<p>
这里就讨论剪裁测试(scissor test), 模板测试(stencil test) 以及深度测试(depth test) 这三个测试(这里是它们的先后顺序).
</p>

<p>
其中剪裁测试以及深度测试都比较好理解, 前者是丢弃剪裁框范围外的片元, 后者是丢弃那些被其它片元挡住的片元, 留下没被遮挡住的片元;
</p>

<p>
而模板测试你可以理解为位屏蔽(bit masking)的类似, 使用一个模板缓冲(stencil buffer)作为遮罩层, 把模板值不符合条件的片元都丢弃,
</p>

<p>
为了更直观地理解, 我直接从 <a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">LearnOpenGL</a> 上把图给扒下来, 来看看模板测试以及模板缓冲是怎么样的:
</p>


<div id="org58d387b" class="figure">
<p><img src="../../../files/stencil_test.png" alt="stencil_test.png">
</p>
<p><span class="figure-number">Figure 5: </span>模板测试</p>
</div>

<p>
可以看到上模板缓冲就是一张模板图片, 该图片每一个像素都是 8 位大小的数据, 也就是每一个像素实际上就是一个从 0 到 255 的值.
</p>

<p>
模板测试就是比较对应位置上的像素数值和片元模板值, 比如像上面图那样, 只有模板值等于 1 的片元才能被保留下来.
</p>

<p>
当然判断方法也有可能是大于等于 1, 判断方法不是唯一的, 其他方法可以看<a href="https://www.khronos.org/opengl/wiki/Stencil_Test#Stencil_test">官方文档</a>.
</p>

<p>
最后 <code>OpenGL/WebGL</code> 再对经过筛选的片元进行一些处理就能输出到屏幕上了.
</p>
</div>
</div>
</div>
<div id="outline-container-orgcf51652" class="outline-2">
<h2 id="orgcf51652">一个简单而完整的 Shader 程序</h2>
<div class="outline-text-2" id="text-orgcf51652">
<p>
我们约定 <code>Shader</code> 代码是运行在 <code>CPU</code> 上的, 而调用 <code>OpenGL/WebGL API</code> 的代码则是运行在 <code>CPU</code> 上的;
</p>

<p>
当提到调用 <code>OpenGL/WebGL API</code> 给 <code>Shader</code> 提供数据的时候, 就说从 <code>CPU</code> 上传数据到 <code>GPU</code>.
</p>

<p>
这部分的内容主要是补充描述 <code>GPU</code> 具体是如何接收来自于 <code>CPU</code> 的数据的.
</p>

<p>
<b>为了不让文章被上下文断断续续的代码扰乱, 这里准备了一个简单的<a href="https://github.com/saltb0rn/saltb0rn.github.io/tree/master/src/examples/learn-webgl-how-to-read-data">例子</a>用于讲解</b>, 效果如下:
</p>

<p>
<iframe width="300" height="300" src="../../../examples/learn-webgl-how-to-read-data/index.html"></iframe>
</p>

<p>
在阅读下面的内容前请 <b>务必</b> 把例子的代码复制到本地, 然后边阅读边对照, 有疑惑可以修改代码查看效果.
</p>

<p>
需要注意的是, 这个例子是基于 <code>WebGL 1.0/GLSL 1.20</code> 的.
</p>
</div>
<div id="outline-container-how-cpu-upload-data" class="outline-3">
<h3 id="how-cpu-upload-data">CPU 如何上传数据给 GPU</h3>
<div class="outline-text-3" id="text-how-cpu-upload-data">
<p>
首先,  <code>GPU</code> 会等 <code>CPU</code> 把数据传送过来, 在接收到数据后, 数据会被储存在缓冲(buffers)上.
</p>

<p>
我们以 <code>WebGL</code> 为例子 (<code>OpenGL</code> 其实也差不了太多), 设现有一个名为 <code>gl</code> 的 <code>WebGL</code> 上下文实例, 要完成上述过程需要进行以下操作:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21578;&#35785; GPU &#21019;&#24314;&#22909;&#32531;&#20914;,&#29992;&#20110;&#21518;&#32493;&#20648;&#23384; CPU &#21457;&#36807;&#26469;&#30340;&#25968;&#25454;</span>
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">buffer</span> = gl.createBuffer();

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35774;&#23450;&#24403;&#21069;&#21487;&#25805;&#20316;&#32531;&#20914;,&#22240;&#20026; GPU &#21487;&#20197;&#26377;&#19981;&#27490;&#19968;&#20010;&#32531;&#20914;,&#25152;&#20197;&#38656;&#35201;&#21578;&#35785; GPU &#25509;&#19979;&#26469;&#35201;&#23545;&#21738;&#20010;&#32531;&#20914;&#36827;&#34892;&#25805;&#20316;</span>
gl.bindBuffer(target, buffer);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#24448;&#24403;&#21069;&#21487;&#25805;&#20316;&#32531;&#20914;&#37324;&#38754;&#22635;&#20805;&#25968;&#25454;,&#36825;&#19968;&#27493;&#25442;&#21477;&#35805;&#35828;&#23601;&#26159;&#20648;&#23384; CPU &#21457;&#36807;&#26469;&#30340;&#25968;&#25454; data &#20102;.</span>
gl.bufferData(target, data, usage);
</pre>
</div>

<p>
这里对应例子的<a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L92">这一部分(80-92行)</a>.
</p>

<p>
由于数据的用途的不同, 缓冲可以分为很多种类型, 在绑定的时候就需要指定了, 也就是上面代码里面的 <code>target</code> 变量.
</p>

<p>
想要知道 <code>target</code> 的值能够是什么, 可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindBuffer">这里</a>, 这些方法的参考说明都可以在<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext">这里</a>找到.
</p>

<blockquote>
<p>
<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml">参考文档</a> <code>usage</code> 变量是用来提示 <code>OpenGL/WebGL</code> 储存数据的使用模式, 使用模式分为两个方面来讨论:
</p>

<p>
<b>数据的访问频率</b> 以及 <b>数据的访问性质</b>.
</p>

<p>
访问频率有以下几种情况:
</p>

<ul class="org-ul">
<li><code>STREAM</code>: 数据只会被修改一次并且偶尔使用几次</li>
<li><code>STATIC</code>: 数据只会被修改一次并且使用多次</li>
<li><code>DYNAMIC</code>: 数据会重复修改并且使用多次</li>
</ul>

<p>
访问性质其实就是在描述数据来源(也就是修改数据的方式)以及用途, 有以下几种情况:
</p>

<ul class="org-ul">
<li><code>DRAW</code>: 数据由 <code>CPU</code> 上传到 <code>GPU</code>, 并且作为绘图命令/图片规范命令的数据源</li>
<li><code>READ</code>: 数据由 <code>GPU</code> 读取到 <code>CPU</code></li>
<li><code>COPY</code>: 数据由 <code>GPU</code> 读取到 <code>GPU</code>, 并且作为绘图命令/图片规范命令的数据源</li>
</ul>

<hr>

<p>
值得注意的是, <code>usage</code> 仅仅是用来 <b>提示</b> 数据的使用模式, 目的是想让 <code>OpenGL/WebGL</code> 对数据的储存进行优化;
</p>

<p>
但 <code>usage</code> 并不一定要匹配实际的使用模式, 比如说可以对 <code>STATIC_DRAW</code> 用途的数据进行多次修改, 并不约束数据的实际使用模式.
</p>
</blockquote>

<p>
在 <code>OpenGL/WebGL</code> 里面, 这些用来作为物体顶点信息的缓冲叫做 <code>Vertex Buffer Object (VBO)</code>,
</p>

<p>
因为 <code>OpenGL/WebGL</code> 里面有不止一种类型的缓冲, 所以个人更喜欢把储存顶点信息的缓冲叫做 <code>VBO</code>,
</p>

<p>
所以在下文提到 <code>VBO</code> 时应该立刻想起 <code>VBO</code> 是通过 <code>gl.createBuffer</code> 方法创建的.
</p>

<p>
一旦有了数据源, 就可以让 <code>GPU</code> 根据利用这些数据来渲染了.
</p>

<p>
<code>VBO</code> 并非只能存顶点数据, 也可以包含一些其它与顶点相关的数据, 我们一般把顶点数据以其关联数据统称为集合数据(<code>Geometry Data</code>).
</p>

<p>
另外, <code>OpenGL/WebGL</code> 也不规定 <code>CPU</code> 上传的数据只能存到缓冲里, 后面会介绍它们.
</p>
</div>
</div>
<div id="outline-container-how-gl-use-data" class="outline-3">
<h3 id="how-gl-use-data">GPU 如何从缓冲读取数据</h3>
<div class="outline-text-3" id="text-how-gl-use-data">
<p>
首先需要提及的一点是, <code>GPU</code> 并非直接使用缓冲来进行渲染, 在说明这点之前, 我们先来明白一个概念.
</p>

<p>
<code>VBO</code> 里面的数据格式不是固定的, 比如渲染一个三角形, 它的顶点数据格式可能是这样的:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, x2, y2, z2, x3, y3, z3 }
</pre>
</div>

<p>
每个顶点只有 \((x,y,z)\) 坐标数据.
</p>

<p>
也可能是这样的:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3 }
</pre>
</div>

<p>
现在每个顶点的坐标数据多了一个 \(w\) 分量.
</p>

<p>
也有可能包含了坐标以外的数据:
</p>

<div class="org-src-container">
<pre class="src src-c">{ x1, y1, z1, w1, r1, g1, b1, a1, x2, y2, z2, w2, r2, g2, b2, a2, x3, y3, z3, w3, r3, g3, b3, a3, }
</pre>
</div>

<p>
总的来说, 每个顶点数据可能会有不同属性(attribute), 而不同属性的格式又不是固定的.
</p>

<p>
那么问题来了, 既然数据格式不一样, <code>GPU</code> 是如何读取这些数据才能渲染出一个三角形的呢?
</p>

<p>
这需要开发人员告诉 <code>GPU</code> 如何读取数据, 调用 <code>gl.vertexAttribPointer(index, size, type, normalized, stride, offset)</code> 这个 API 来生成一个 <code>Vertex Array Object (VAO)</code>,
</p>

<p>
<b>VAO 决定了如何从 VBO 里面读取数据, 并把读取到的数据绑定给变量</b>.
</p>

<p>
它控制读取数据的方式其实很简单, 假设下面这里有另外一种数据格式:
</p>


<div id="orgedc0cf6" class="figure">
<p><img src="../../../files/glVertexAttribPointer-api-overview.png" alt="glVertexAttribPointer-api-overview.png">
</p>
<p><span class="figure-number">Figure 6: </span>vertexAttribPointer</p>
</div>

<p>
这里面的顶数据有三种属性: 顶点坐标(xyz), 颜色(rgb)以及纹理坐标(st).
</p>

<p>
正如前面说所说的, 顶点的信息不是固定的, 实际上还能会存在别的数据, 比如说法线向量, 又或者属性之间的排序不同于上图.
</p>

<p>
这样做的好处是, 顶点的所有相关数据都储存在一个缓冲里面, 只读取其某个属性的话(比如顶点颜色)只需要调用 <code>gl.vertexAttribPointer()</code> 来新建一个指针来读取即可, 不需要重新创建一个缓冲来专门储存颜色数据.
</p>

<p>
<code>gl.vertexAttribPointer</code> 的 <code>index</code> 参数是 <code>Shader</code> 程序(shader program)里面 <code>attribute</code> 类型变量的索引值, 可以手动指定, 也可以通过 <code>gl.getAttribLocation(shaderProgram, attribName)</code> 来获取.
</p>

<p>
<code>attribute</code> 类型变量是 <code>shader</code> 程序里面定义的变量, 用来传递缓冲里面某种数据给 <code>Vertex Shader</code> 中, 后面会讲到.
</p>

<blockquote>
<p>
<code>gl.vertexAttribPointer</code> 其它参数:
</p>

<ul class="org-ul">
<li><code>size</code>: 指定某属性由多少个分量组成, 比如图中的 <code>POSITION</code> 属性是由 3 个分量组成, 如果读取 <code>POSITION</code>, 那么 <code>size</code> 应该是 3.</li>

<li><code>type</code>: 分量的类型, 是整形还是浮点型, 图中的分量类型是浮点型, 浮点型数据大小为 32 位(4 字节), 因此每个分量占了 4 个字节.</li>

<li><code>normalized</code>: 是否对整形分量限定在某个范围内, 该参数对浮点型分量无效.</li>

<li><code>stride</code>: 每一组顶点数据的步进, 就比如图中的每一个顶点的属性有 <code>POSITION/COLOR/TEXTURE</code>, 加起来共 32 字节, 这就是它的步进.</li>

<li><code>offset</code>: 顶点数据的属性偏移, 就比如图中顶点数据的每种属性的偏移分别为: <code>POSITION</code> 为 0 个字节; <code>COLOR</code> 为 12 个字节; <code>TEXTURE</code> 为 24 个字节.</li>
</ul>
</blockquote>

<p>
在 <code>gl.bindBuffer(target, buffer)</code> 之后调用 <code>gl.vertexAttribPointer</code> 就可以把缓冲里的数据填充到指定的 <code>attribute</code> 变量里面.
</p>

<p>
在填充到 <code>attribute</code> 变量后不要忘记通过 <code>gl.enableVertexAttribArray( RET-VAL-OF-vertexAttribPointer )</code> 启用指针.
</p>

<p>
这一段对应例子的<a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L80-L116">这一部分(94-114行)</a>: 往 "aVertexPosition" 变量填充了顶点位置坐标数据, 往 "aVertexColor" 变量填充了顶点颜色数据,
</p>

<p>
其中 <code>aVertexPosition</code> 和 <code>aVertexColor</code> 是 <code>shader</code> 程序的 <a href="https://github.com/saltb0rn/saltb0rn.github.io/blob/master/src/examples/learn-webgl-how-to-read-data/index.js?#L16-L29">Vertex Shader</a> 里面 <b>声明</b> 的 <code>attribute</code> 变量名, 强调这是声明是因为 <code>gl.vertexAttribPointer</code> 的调用实际上就是给这些变量补充定义.
</p>

<p>
此外, 当你对 <code>a_vertexPosition</code> 和 <code>a_vertexColor</code> 两个值进行打印, 你会发现它们的值分别是 0 和 1, 正好对应 <code>attribute</code> 变量声明的顺序.
</p>

<p>
<code>Shader</code> 程序并非只有 <code>attribute</code> 变量, 接下来会对 <code>GLSL</code> 变量修饰符进行介绍, 掌握了这一块才能算是真正的掌握 <code>GLSL</code>.
</p>
</div>
</div>
<div id="outline-container-org44589a6" class="outline-3">
<h3 id="org44589a6">如何使用缓冲的数据进行绘制</h3>
<div class="outline-text-3" id="text-org44589a6">
<p>
当给缓冲填充了数据以及设置好读取方式后, 就可以开始绘制图形了.
</p>

<p>
<code>WebGL</code> 有两个基础绘制命令: <code>gl.drawArrays(mode, first, count)</code> 以及 <code>gl.drawElements(mode, count, type, offset)</code>.
</p>

<p>
例子使用的是前者进行绘制的, <code>mode</code> 是指绘制的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements#mode">图元种类</a>, <code>first</code> 指定读取图元数据源时的起始索引, <code>count</code> 指定图源需要多少个顶点数据;
</p>

<p>
例子里的 <code>gl.drawArrays(gl.TRIANGLE_STRIP, 0, 3);</code> 就是绘制一个三角形, 从绑定的数据源的首个位置开始读取, 需要 3 个顶点数据.
</p>

<p>
<code>gl.drawElements(mode, count, type, offset)</code> 则是 <code>gl.drawArrays</code> 的内存节省版本, 使用顶点数据的索引来进行绘图, 可以有效节省顶点数据的使用空间.
</p>

<p>
具体用法可以参考 <a href="https://webglfundamentals.org/webgl/lessons/webgl-indexed-vertices.html">WebGL Index Vertices</a>.
</p>

<p>
在调用绘图命令时 <code>Shader</code> 就会开始执行了, 这点在第一节里面已经详细讲述了.
</p>
</div>
</div>
<div id="outline-container-glsl-type-qualifier-overview" class="outline-3">
<h3 id="glsl-type-qualifier-overview">GLSL 变量修饰符(Variable Qualifiers / Type Qualifiers)</h3>
<div class="outline-text-3" id="text-glsl-type-qualifier-overview">
<p>
和其他编程语言一样, <code>GLSL</code> 的变量也是一样有修饰符的, 这里的修饰符并非指 <code>int</code>, <code>float</code> 这些 <a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)">数据类型</a>;
</p>

<p>
而是指控制变量的储存以及行为的标识, 这么说可能有点不太好理解, 举个例子 "禁止变量在声明后被修改" 的 <code>const</code> 就是其中一个修饰符.
</p>

<p>
这种表示被叫做 <a href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)">类型限定符</a>.
</p>

<p>
我们都知道 <code>GLSL</code> 的工作内容并不完全像其他编程语言一样, 它的任务是控制图形渲染的, 而这项任务的流程是分成好几个阶段的,
</p>

<p>
有些数据可以在所有阶段中都能访问到, 而有些数据只能在特定阶段中访问, 还有一些数据能够从这个阶段输出到下一个阶段.
</p>

<p>
为了标识变量能够在哪些阶段使用, 就需要使用类型表示符来进行声明, 最常用的有两个: <code>attribute</code> 以及 <code>uniform</code>.
</p>

<p>
一个 <code>shader</code> 变量可以使用多种限定符的组合进行声明, 但要注意遵守<a href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)#Qualifier_order">顺序</a>.
</p>
</div>
<div id="outline-container-org0eec349" class="outline-4">
<h4 id="org0eec349">attribute</h4>
<div class="outline-text-4" id="text-org0eec349">
<p>
它在这篇文章里面第一个被介绍的修饰符, 它属于存储修饰符, 被它修饰后的变量可以简单理解为 <code>Vertex Shader</code> 的输入,
</p>

<p>
这种变量不能在 <code>Vertex Shader</code> 以外的阶段被使用, 同样也不能用在接口块(<a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)">interface block</a>)里面, 并且这种变量是只读的(read-only).
</p>

<p>
作为 <code>Vertex Shader</code> 的输入, 也就是说 <code>attribute</code> 变量接收的数据是从缓冲里面读取的.
</p>
</div>
</div>
<div id="outline-container-orge6b5e05" class="outline-4">
<h4 id="orge6b5e05">uniform</h4>
<div class="outline-text-4" id="text-orge6b5e05">
<p>
例子里面传入了两个 <code>uniform</code> 变量, 这种变量是全局的, 它可以在整个图元处理过程中被访问到,
</p>

<p>
可以在 <code>Vertex Shader</code> 以及 <code>Fragment Shader</code> 访问这些变量, 同样也不能在接口块里面使用. 这种变量是只读的(read-only).
</p>

<p>
<code>uniform</code> 是我们前面提到的存到缓冲以外的数据.
</p>

<p>
在 <code>GLSL 1.10</code> 中, 当 <code>Shader</code> 程序成功编译链接后, 所有的 <code>uniform</code> 变量都会被赋予 0 作为默认值.
</p>

<p>
在 <code>GLSL 1.20</code> 中, 除了 <code>sampler2D/samplerCube</code> 外的所有 <code>uniform</code> 变量都支持使用初始化器:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">vec3</span> color = <span style="color: #98fb98;">vec3</span>(0.7, 0.7, 0.2);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org00ef420" class="outline-3">
<h3 id="org00ef420">GLSL 内置变量</h3>
<div class="outline-text-3" id="text-org00ef420">
<p>
这里着重介绍几个稍微重要一点的并且不能被 <code>Shader</code> 修改的内置数据.
</p>

<ul class="org-ul">
<li><p>
<code>gl_VertexID</code>
</p>

<p>
支持 <code>GLSL 1.30</code> 以及之后的版本, 只支持在 <code>Vertex Shader</code> 中访问.
</p>

<p>
<code>gl_VertexID</code> 就是当前被处理的顶点 <code>ID</code> (<code>Vertex ID</code>).
</p>

<p>
比如绘制 20 个顶点: <code>gl.drawArrays(gl.POINTS, 0, 20)</code>, 那么第一个顶点的 <code>ID</code> 就是 \(first + i,\ \mathrm{where}\ i = 0\),
</p>

<p>
\(first\) 是绘图命令 <code>gl.drawArrays(mode, first, count)</code> 的第二个参数, \(i\) 是由当前处理的第 \(i+1\) 个顶点的索引.
</p>

<p>
这是对于每次像 <code>gl.drawArrays</code> 这样的绘图命令来讲的, 也就是说如果进行第二次调用 <code>gl.drawArrays(gl.POINTS, 0, 20)</code> 的话,
</p>

<p>
第二次绘制中第一个顶点的 <code>ID</code> 必定也是 \(first + 0\), 而不是 \(first + 20\).
</p></li>

<li><p>
<code>gl_PointCoord</code>
</p>

<p>
支持 <code>GLSL 1.10</code> 以及之后的版本, 支持在 <code>Fragment Shader</code> 中访问.
</p>

<p>
<code>gl_PointCoord</code> 是点在像素块内的相对坐标, 分量 \(x\) 和 \(y\) 的范围是 \(\left[0, 1\right]\).
</p>

<p>
比如在前面的图片 <code>实心三角形</code> 中, 点 <code>p0</code> 在它所处的片元正中心, 那么该片元的 <code>gl_PointCoord</code> 的值就是 \((0.5, 0.5)\),
</p>

<p>
如果它处于片元的左上角, 那么值就是 \((0, 0)\).
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org492c943" class="outline-3">
<h3 id="org492c943">其它常见问题</h3>
<div class="outline-text-3" id="text-org492c943">
<ul class="org-ul">
<li><p>
<code>GLSL</code> 的矩阵是行优先(row major)还是列优先(column major)?
</p>

<p>
默认是列优先, 可以通过 <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">Layout Qualifier</a> 去修改.
</p></li>

<li><p>
为什么看到别人代码的向量的同一个位置的分量会不同, 比如 <code>vec4</code> 类型的变量会写 <code>v4.rgba</code>, 又有时候会写 <code>v4.xyzw</code>, 又有时候会写 <code>v4.stpq</code>?
</p>

<p>
这几种写法其实都是同一个东西, 比如第一个分量 <code>r/x/s</code> 都是同一个东西, 只不过在语义上有所区别.
</p>

<p>
如果分量用来表示颜色, 那么就建议用 <code>rgba</code>; 如果表示位置坐标, 那么建议用 <code>xyzw</code>; 如果表示纹理坐标, 那么建议用 <code>stpq</code>;
</p>

<p>
但是不能混着用, 比如 <code>xgba</code> 这样.
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org58a2ac2" class="outline-2">
<h2 id="org58a2ac2">WebGL 的 API 概览</h2>
<div class="outline-text-2" id="text-org58a2ac2">
<p>
<code>WebGL</code> 的很多 <code>API</code> 名字都看着差不多且令人迷惑, 比如: <code>gl.createBuffer</code>, <code>gl.createFramebuffer</code>, <code>gl.createRemderbuffer</code>.
</p>

<p>
令人迷惑主要是源于它们背后所对应的概念. 比如什么是 <code>Buffer</code>, 什么是 <code>Framebuffer</code> 以及什么是 <code>Renderbuffer</code>, 以及他们之间有什么区别.
</p>

<p>
所以这一章节主要是借着介绍 <code>API</code> 的机会学习这些概念.
</p>
</div>
<div id="outline-container-orgd9f989b" class="outline-3">
<h3 id="orgd9f989b">缓冲 (Buffer)</h3>
<div class="outline-text-3" id="text-orgd9f989b">
<p>
<code>Buffer</code> 就是专门用来储存几何数据的缓冲, 使用 <code>gl.createBuffer</code> 进行创建.
</p>

<p>
<code>Buffer</code> 这个词语的字面含义过于普遍了: 任何种类的缓冲都是缓冲.
</p>

<p>
但是在 <code>OpenGL/WebGL</code> 中 <code>buffer</code> 这个对象并不能指代所有缓冲, 所以个人偏向使用 <code>Vertex Buffer Objects</code> 或 <code>VBO</code> 来指代它.
</p>

<p>
<code>VBO</code> 的使用在前面就介绍过了, 这里就不再赘述.
</p>
</div>
</div>
<div id="outline-container-org5509707" class="outline-3">
<h3 id="org5509707">贴图 (Texture)</h3>
<div class="outline-text-3" id="text-org5509707">
<p>
贴图本质上就是一个图片对象, 为顶点/片元提供可选数据, 同时贴图也提供了一些针对图片的基本操作.
</p>

<p>
在 <code>OpenGL/WebGL</code> 中使用贴图需要理解一些前置知识.
</p>

<p>
<code>OpenGL/WebGL</code> 至少有 8 个贴图插槽, 每个插槽可以绑定一个贴图对象, 最后可以往贴图对象写入图片数据.
</p>

<p>
在绑定贴图之前需要说明操作哪个插槽, 这个可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/activeTexture">gl.activeTexture(texture)</a> 方法来完成,
</p>

<p>
参数 <code>texture</code> 是一个枚举变量: \(\mathrm{gl.TEXTUREI} \in \{ \mathrm{gl.TEXTURE0}, \mathrm{gl.TEXTURE1}, \mathrm{gl.TEXTURE2}, ... \mathrm{gl.TEXTURE7}, ... \}\).
</p>

<p>
指定插槽后需要说明插槽绑定的贴图类型以及贴图对象, 这则是通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindTexture">gl.bindTexture(target, texture)</a> 方法来完成,
</p>

<p>
<code>target</code> 是贴图类型, 可选值为 <code>gl.TEXTURE_2D</code> 和 <code>gl.TEXTURE_CUBE_MAP</code>;
</p>

<p>
<code>texture</code> 是贴图对象的 <code>ID</code>, 这个 <code>ID</code> 是由 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createTexture">gl.createTexture()</a> 方法返回的.
</p>

<p>
<code>gl.createTexture()</code> 方法的作用是初始化一个贴图对象, 在绑定绑定贴图后, 后续的一系列贴图操作都是在绑定贴图上发生,
</p>

<p>
比如使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei">gl.pixelStorei(pname, param)</a> 指定贴图的图片数据的字节如何对齐,
</p>

<p>
使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter">gl.texParameter[fi](target, pname, param)</a> 指定贴图的一些参数,
</p>

<p>
使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D">gl.texImage2D</a> 往贴图对象里面填充贴图数据.
</p>

<p>
这些函数都不要求传入贴图对象的 <code>ID</code> 作为参数来说明对哪个贴图对象进行操作,
</p>

<p>
因为之前的 <code>gl.activeTexture</code> 已经在内部设置好了状态: 指定了操作的贴图插槽,
</p>

<p>
<code>OpenGL/WebGL</code> 本质上就是一个状态机, 后续的一切贴图操作都是基于这个状态进行.
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">WebGL &#40664;&#35748;&#25351;&#23450; gl.TEXTURE0 &#20026;&#24403;&#21069;&#25554;&#27133;, &#26377;&#20123;&#31243;&#24207;&#21482;&#20351;&#29992;&#19968;&#20010;&#25554;&#27133;, &#36825;&#31181;&#24773;&#20917;&#19979;&#36825;&#19968;&#21477;&#22522;&#26412;&#20250;&#34987;&#24573;&#30053;&#25481;</span>
gl.activeTexture(gl.TEXTURE0);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21019;&#24314;&#36148;&#22270;&#23545;&#35937;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">texture</span> = gl.createTexture();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#36148;&#22270;&#32465;&#23450;&#21040;&#25554;&#27133;&#19978;</span>
gl.bindTexture(gl.TEXTURE_2D, texture);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25351;&#23450;&#36148;&#22270;&#25968;&#25454;&#30340;&#20648;&#23384;</span>
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20026;&#36148;&#22270;&#35774;&#23450;&#21442;&#25968;</span>
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20026;&#36148;&#22270;&#20998;&#37197;&#31354;&#38388;, &#21442;&#25968; pixels &#20026; null, &#24847;&#21619;&#30528;&#19981;&#25552;&#20379;&#25968;&#25454;, &#36825;&#31181;&#31354;&#30333;&#36148;&#22270;&#19968;&#33324;&#26377;&#29305;&#27530;&#29992;&#36884;</span>
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, <span style="color: #7fffd4;">null</span>);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30452;&#25509; img &#20803;&#32032;&#20316;&#20026;&#36148;&#22270;&#30340;&#25968;&#25454;&#26469;&#28304;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">image</span> = document.getElementById(<span style="color: #ffa07a;">'image-element'</span>);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);

<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">isPowerOf2</span> = (value) =&gt; value &amp; (value - 1) === 0;

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#26816;&#26597;&#22270;&#29255;&#30340;&#23610;&#23544;&#26159;&#21542;&#20026; 2 &#30340;&#24130;&#27425;&#26041;</span>
<span style="color: #00ffff;">if</span> (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#29983;&#25104;&#22810;&#32423;&#32441;&#29702;</span>
  gl.generateMipmap(gl.TEXTURE_2D);
} <span style="color: #00ffff;">else</span> {
  <span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#19981;&#26159; 2 &#30340;&#24130;&#27425;&#26041;, &#36890;&#36807;&#35774;&#32622; gl.TEXTURE_MIN_FILTER &#20026; gl.LINEAR &#25110; gl.NEARST &#26469;&#20851;&#38381;&#22810;&#32423;&#32441;&#29702;&#29983;&#25104;,</span>

<span style="color: #ff7f24;">     &#30001;&#20110;&#20851;&#38381;&#22810;&#32423;&#32441;&#29702;&#21518;, &#36828;&#36317;&#31163;&#30340;&#32441;&#29702;&#21487;&#33021;&#22240;&#20026;&#32553;&#23567;&#32780;&#20986;&#29616;&#38191;&#40831;, &#25152;&#20197;&#20351;&#29992; gl.LINEAR &#26368;&#22909;.</span>

<span style="color: #ff7f24;">     &#22810;&#32423;&#32441;&#29702;&#19981;&#24433;&#21709;&#25918;&#22823;, &#25152;&#20197; gl.TEXTURE_MAG_FILTER &#21487;&#20197;&#19981;&#29992;&#35774;&#32622;.</span>
<span style="color: #ff7f24;">   */</span>
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  <span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#36148;&#22270;&#30340;&#29615;&#32469;&#27169;&#24335;&#35774;&#32622;&#20026; gl.CLAMP_TO_EDGE</span>
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#36890;&#36807; uniform &#21464;&#37327;&#20026; Shader &#25552;&#20379;&#36148;&#22270;&#25968;&#25454;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">textureLocation</span> = gl.getUniformLocation(shaderProgram, <span style="color: #ffa07a;">"u_texture"</span>);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">0 &#34920;&#31034;&#20351;&#29992; gl.TEXTURE0 &#25554;&#27133;&#19978;&#30340;&#36148;&#22270;, &#22914;&#27492;&#31867;&#25512;, 1 &#34920;&#31034;&#20351;&#29992; gl.TEXTURE1 &#19978;&#30340;&#36148;&#22270;</span>
gl.uniform1i(textureLocation, 0);
</pre>
</div>

<p>
想在 <code>Shader</code> 程序中使用贴图, 那么需要使用 <code>sampler2D</code> 类型的 <code>uniform</code> 变量传递数据:
</p>

<div class="org-src-container">
<pre class="src src-glsl"><span style="color: #00ffff;">uniform</span> <span style="color: #98fb98;">sampler2D</span> u_texture;
</pre>
</div>

<p>
如果贴图类型是 <code>gl.TEXTURE_CUBE_MAP</code>, 那么应该使用 <code>samplerCube</code> 类型的 <code>uniform</code> 变量.
</p>

<p>
更多贴图相关的内容可以阅读 <a href="https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html">WebGL Textures</a>.
</p>

<blockquote>
<p>
如果有对比 <code>VBO</code> 的使用模式, 你会发现他们的 <code>API</code> 的设计十分类似.
</p>

<p>
基本上都是先调用 <code>gl.create*</code> 方法创建对象, 再调用 <code>gl.bind*</code> 方法绑定操作对象, 最后根据对象提供的 <code>API</code> 对绑定的对象进行操作.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org6b42b40" class="outline-3">
<h3 id="org6b42b40">帧缓冲 (FrameBuffer)</h3>
<div class="outline-text-3" id="text-org6b42b40">
<p>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindFramebuffer">gl.bindFramebuffer(target, framebuffer)</a> 用来指定渲染结果输出 <code>framebuffer</code> 上, 如果 <code>framebuffer</code> 是 <code>null</code>, 那么渲染结果输出到画布上.
</p>

<p>
帧缓冲是一个缓冲集合, 该集合包含若干个渲染数据, 所谓渲染数据就是渲染结果的拆分:
</p>

<p>
颜色缓冲(<code>color buffer</code>), 深度缓冲(<code>depth buffer</code>) 以及模板缓冲(<code>stencil buffer</code>).
</p>

<p>
新创建的帧缓冲是一个空集, 开发者需要把渲染数据关联到附件(<code>attachments</code>)上, 没关联一个附件, 集合里面就多出一元素,
</p>

<p>
在调用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays">gl.drawArrays(mode, first, count)</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements">gl.drawElements(mode, count, type, offset)</a> 时, <code>OpenGL/WebGL</code> 会把渲染结果输出到帧缓冲上,
</p>

<p>
然而只有当 <code>OpenGL/WebGL</code> 发现渲染数据被关联了附件时, 输出的渲染数据才能被"接住".
</p>

<p>
在帧缓冲里面, 渲染管线的任意一个步骤都不会被遗漏, 如果帧缓冲里面有储存深度缓冲和模板缓冲的附件, 那么深度测试和模板测试依然会进行.
</p>

<blockquote>
<p>
<a href="https://webglfundamentals.org/webgl/lessons/webgl-framebuffers.html">WebGLFundamentals - FrameBuffers</a> 里面用伪代码的形式把这个过程解释得非常清楚, 推荐阅读.
</p>
</blockquote>

<p>
储存缓冲数据的附件可以是贴图, 也可以是渲染缓冲(<code>RenderBuffer</code>), 这两者在用法上存在一些区别.
</p>

<p>
贴图前面已经有介绍了, 它可以给 <code>Shader</code> 程序提供数据从而输出到画面上,
</p>

<p>
而 <code>OpenGL/WebGL</code> 并没有提供任何 <code>API</code> 来读取渲染缓冲上的数据, 因此也无法把它的数据输出到画面上.
</p>

<p>
如果需要把渲染数据用在 <code>Shader</code> 程序中或者用在成像画面上, 那么应该选择贴图作为附件,
</p>

<p>
渲染缓冲适合用与储存深度缓冲和模板缓冲, 进行深度测试和模板测试.
</p>

<p>
以下代码片段演示了帧缓冲的最基本用法:
</p>

<div class="org-src-container">
<pre class="src src-js">gl.enable(gl.DEPTH_TEST);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#22312;&#25226;&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#21040; fbo &#19978;&#20043;&#21069;&#35774;&#32622;&#28210;&#26579;&#23610;&#23544;</span>
gl.viewport(0, 0, textureWidth, textureHeight);
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">fbo</span> = gl.createFramebuffer();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#21040; fbo &#19978;</span>
gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#39068;&#33394;&#32531;&#20914;&#36755;&#20986;&#21040;&#36148;&#22270;&#20013;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">texture</span> = gl.createTexture();
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">level</span> = 0;
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#20351;&#29992;&#36148;&#22270;&#20316;&#20026;&#38468;&#20214;&#20648;&#23384;&#39068;&#33394;&#32531;&#20914;, &#24182;&#28155;&#21152;&#21040;&#24103;&#32531;&#20914;&#20013;</span>
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, level);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#39068;&#33394;&#32531;&#20914;&#36755;&#20986;&#21040;&#36148;&#22270;&#20013;: end</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#21040; renderbuffer &#20013;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">rbo</span> = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.FRAMEBUFFER, rbo);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35753;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#30340;&#23610;&#23544;&#21644;&#36148;&#22270;&#30340;&#19968;&#26679;</span>
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureWidth, textureHeight);
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#28145;&#24230;&#32531;&#20914;&#36755;&#20986;&#21040; renderbuffer &#20013;: end</span>

gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#19968;&#20010;&#35843;&#29992;&#20102; gl.drawArrays/gl.drawEelements &#26041;&#27861;&#30340;&#20989;&#25968;</span>
renderScene();
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#30446;&#21069;&#20026;&#27490;, &#33719;&#24471;&#20102;&#19968;&#20010;&#32463;&#36807;&#28145;&#24230;&#27979;&#35797;&#30340;&#36148;&#22270; texture, &#21487;&#29992;&#22312; Shader &#31243;&#24207;&#20013;</span>

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#21487;&#20197;&#29992;&#22312;&#25226;&#36148;&#22270;&#19978;&#30340;&#25968;&#25454;&#35835;&#21462;&#20986;&#26469;, &#22312; Shader &#31243;&#24207;&#20197;&#22806;&#30340;&#22320;&#26041;&#20351;&#29992;</span>
<span style="color: #00ffff;">const</span> <span style="color: #eedd82;">pixels</span> = <span style="color: #00ffff;">new</span> <span style="color: #98fb98;">Uint8Array</span>(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
<span style="color: #ff7f24;">/* </span><span style="color: #ff7f24;">&#27599;&#27425;&#24448; framebuffer &#20013;&#20889;&#20837;&#25968;&#25454;, gl.drawingBufferWidth &#37117;&#20250;&#34987;&#35774;&#32622;&#20026; textureWidth,</span>
<span style="color: #ff7f24;">   gl.drawingBufferHeight &#21017;&#34987;&#35774;&#32622;&#20026; textureHeight</span><span style="color: #ff7f24;"> */</span>
gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#25226;&#21518;&#32493;&#30340;&#28210;&#26579;&#32467;&#26524;&#36755;&#20986;&#22238;&#30011;&#24067;&#19978;</span>
gl.bindFramebuffer(gl.FRAMEBUFFER, <span style="color: #7fffd4;">null</span>);
<span style="color: #ff7f24;">// </span><span style="color: #ff7f24;">&#35774;&#32622;&#22238;&#30011;&#24067;&#30340;&#28210;&#26579;&#23610;&#23544;</span>
gl.viewport(0, 0, canvasWidt, canvasHeight);
renderScene();
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf85c7ed" class="outline-2">
<h2 id="orgf85c7ed">搭建自己的 Shadertoy</h2>
<div class="outline-text-2" id="text-orgf85c7ed">
<p>
如果想在编写 <code>shader</code> 这条路上走得远, 那么必须得掌握必要的数学基础, 读懂别人 <code>shader</code> 并从中学习, 自己还要动手实践.
</p>

<p>
有一个叫做 <a href="https://www.shadertoy.com/">Shadertoy</a> 网站, 上面有好多高人分享自己的 <code>shaders</code> (运行于 <code>WebGL 2.0</code> / <a href="https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL 300 ES</a>), 是一个庞大的学习资源库.
</p>

<p>
关于阅读代码, 我是始终坚持一个观点, 那就是读源码的第一点是要读得懂, 否者不可能有所收获;
</p>

<p>
这里的"读得懂"并非说掌握代码所使用得语言, 而是知道源代码里面这么写是为什么, 这个为什么的答案终点就是用了什么算法或者技巧.
</p>

<p>
这一点在 <code>shader code</code> 里面是非常好理解的, 在这个 <code>shader</code> 里面,为了实现这个效果使用了哪些数学公式或者概念.
</p>

<p>
当做到了这一点我们就能够达到入门水平了, 反过来知道用哪些数学公式或者概念去实现这个效果了;
</p>

<p>
如果后面能够深入理解掌握的数学公式或者概念, 就能知道它们能够解决什么问题以及用于实现那些自己以前没有实现过的效果了.
</p>

<p>
说了这么多好像, 跟这篇文章的内容无关啊?
</p>

<p>
其实不然, 我这里一直都在强调"学习别人要先保证自己学得懂"这个观点, 学不懂是因为你有一些前置条件没达到,
</p>

<p>
读得懂 <code>Shadertoy</code> 上的源代码要先知道要理解 <code>Shadertoy</code> 是如何工作, 它上面的 <code>shader</code> 都有 <code>Shadertoy</code> 内置的一些变量,
</p>

<p>
清楚这些内置变量的定义是不可缺的, 而要理解清楚它们的定义就得知道在 <code>OpenGL/WebGL</code> 中如何 <code>GPU</code> 传入数据, 如何在 <code>GPU</code> 里面操作数据,
</p>

<p>
这不正好是文章的内容吗?
</p>

<p>
理解一件事物的最好方式就是把它构造出来, 正好 <code>WebGL Fundamentals</code> 以及 <code>WebGL2 Fundamentals</code> 都提供了教程告诉读者如何从 <code>Shadertoy</code> 扒代码,
</p>

<p>
或者如何在 <code>Shadertoy</code> 上面分享代码, 说简单点就是如何搭建自己的 <code>Shadertoy</code>:
</p>

<ul class="org-ul">
<li><code>WebGL Fundamentals</code> 的 <a href="https://webglfundamentals.org/webgl/lessons/webgl-shadertoy.html">Shadertoy 搭建教程</a></li>

<li><code>WebGL2 Fundamentals</code> 的 <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-shadertoy.html">Shadertoy 搭建教程</a></li>
</ul>


<blockquote>
<p>
在知道 <code>Shadertoy</code> 是如何搭建后, 也可以尝用其他同类型的工具.
</p>

<p>
个人推荐 <a href="https://github.com/patriciogonzalezvivo/glslViewer?tab=readme-ov-file">glslViewer</a>, 可以在这里找到它的<a href="https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-UNIFORMS">内置变量</a>说明, 再配合 <a href="https://github.com/patriciogonzalezvivo/glslViewer/tree/main/examples">官方例子</a> 来快速上手, 至于如何使用这些例子请看官方例子目录下的 <a href="https://github.com/patriciogonzalezvivo/glslViewer/blob/main/examples/Makefile">Makefile</a>.
</p>

<p>
推荐理由正是由于它的自带例子, 这份例子新手在习惯 <code>Shader</code> 方面而言做的相当友好, 比起一上来在 <code>Shadertoy</code> 上面乱找别人的代码来阅读要好, 主打一个循序渐进.
</p>

<p>
另外, <code>Lewis Lepton</code> 使用 <code>glslViewer</code> 作为演示工具来做了一系列入门短视频 <a href="https://www.youtube.com/watch?v=HIvNePu7UEE&amp;list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7">Shader Tutorial Series</a>, 每个视频 4 分钟左右, 是一套不错的教程, 理解教程里面的代码能够让你快速熟悉 <code>Shader</code> 编程.
</p>

<p>
除了 <code>glslViewer</code> 的教程外, 还有一个 <code>Shadertoy Tutorial</code> 系列的教程也相当不错:
</p>

<p>
<a href="https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1">Shadertoy Tutorial Part 1 - Intro</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/48-shadertoy-tutorial-part-2">Shadertoy Tutorial Part 2 - Circles and Animation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/49-shadertoy-tutorial-part-3">Shadertoy Tutorial Part 3 - Squares and Rotation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/50-shadertoy-tutorial-part-4">Shadertoy Tutorial Part 4 - Multiple 2D Shapes and Mixing</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/51-shadertoy-tutorial-part-5">Shadertoy Tutorial Part 5 - 2D SDF Operations and More 2D Shapes</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6">Shadertoy Tutorial Part 6 - 3D Scenes with Ray Marching</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7">Shadertoy Tutorial Part 7 - Unique Colors and Multiple 3D Objects</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8">Shadertoy Tutorial Part 8 - 3D Rotation</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/55-shadertoy-tutorial-part-9">Shadertoy Tutorial Part 9 - Camera Movement</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/56-shadertoy-tutorial-part-10">Shadertoy Tutorial Part 10 - Camera Model with a Lookat Point</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11">Shadertoy Tutorial Part 11 - Phong Reflection Model</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/58-shadertoy-tutorial-part-12">Shadertoy Tutorial Part 12 - Fresnel and Rim Lighting</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/59-shadertoy-tutorial-part-13">Shadertoy Tutorial Part 13 - Shadows</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14">Shadertoy Tutorial Part 14 - SDF Operations</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/61-snowman-shader-in-shadertoy">Snowman Shader in Shadertoy</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/62-shadertoy-tutorial-part-15">Shadertoy Tutorial Part 15 - Channels, Textures, and Buffers</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16">Shadertoy Tutorial Part 16 - Cubemaps and Reflections</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/64-shader-resources">Shader Resources</a>
</p>

<p>
<a href="https://inspirnathan.com/posts/65-glow-shader-in-shadertoy">Glow Shader in Shadertoy</a>
</p>

<hr>

<p>
另外, 上手 <code>GLSL</code> 的时候遇到一些内置函数难免会不清楚文档里面的描述的, 所以 <code>Shadertoy</code> 的作者 <a href="https://iquilezles.org/">Inigo Quilez</a> 贴心地开发了一个 <a href="https://graphtoy.com/">Graphtoy</a> 可视化这些函数.
</p>

<p>
PS: 这位大佬除了很多教程文章和视频, 都是非常不错的进阶资源.
</p>

<p>
还有如果你不了解<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/index.php">文档</a>上 <code>Gen*Type</code> 这个词语是什么意思, 你可以去看 <code>GLSL</code> 的语言规范, 我这里可以告诉你的是它的全称是 <code>Generic * Types</code>, 中间的 <code>*</code> 是做进一步限定的,
</p>

<p>
比如 <code>genType</code> 是 <code>float/vec2/vec3/vec4</code>, <code>genIType</code> 可以是 <code>int/ivec2/ivec3/ivec4</code>.
</p>

<p>
并且如果一个函数是这么写的话: <code>genType func(genType x, genType y)</code>, 那么 <code>genType</code> 的值必定是统一的, 只能一起是 <code>float</code>, 或者一起是 <code>vec2</code>, 如此类推.
</p>

<p>
不可能出现像 <code>vec2 func(float x, float y)</code> 这种不统一的情况, 这种是错误用法.
</p>
</blockquote>

<p>
<br>
</p>

<p>
其实这两个教程就是使用的 <code>WebGL</code> 的版本不太一样而已, 选用你喜欢的就好,
</p>

<p>
<code>Shadertoy</code> 上的代码基本上都是只用 <code>Fragment Shader</code> 实现效果的, 但是还存在这么一个网站, 它包含了各种只使用 <code>Vertex Shader</code> 但不使用任何几何输入来实现各种效果的 <code>Shader</code> 程序, 它就是 <a href="https://www.vertexshaderart.com/">VertexShaderArt</a>.
</p>

<p>
<code>WebGL Fundamentals</code> 以及 <code>WebGL2 Fundamentals</code> 在提供 "Shadertoy 搭建教程" 前提供了对应的教程:
</p>

<ul class="org-ul">
<li><code>WebGL Fundamentals</code> 的 <a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-without-data.html">不使用几何数据作图教程</a></li>

<li><code>WebGL2 Fundamentals</code> 的 <a href="https://webgl2fundamentals.org/webgl/lessons/webgl-drawing-without-data.html">不适用几何数据作图教程</a></li>
</ul>


<p>
<br>
</p>

<p>
从热度上来看, <code>Shadertoy</code> 比 <code>VertexShaderArt</code> 更高, 这是不是意味着 <code>Vertex Shader</code> 不重要呢?
</p>

<p>
不管是 <code>Vertex Shader</code> 还是 <code>Fragment Shader</code>, 都需要开发者掌握名为数学的画笔工具, 并且都是一样的数学知识点, 讨论谁重要毫无意义.
</p>

<p>
<code>Shadertoy</code> 热度高纯粹是因为大部分情况下只需操作像素就能绘制一幅画, 所以使用 <code>Fragment Shader</code> 便足以.
</p>

<p>
而 <code>Vertex Shader</code> 是不能直接控制像素的, 它更倾向于用来控制几何物体的形状, 最典型的例子就是 <a href="https://developer.nvidia.com/gpugems/gpugems/contributors">GPU Gems</a> 中第一章的 <a href="https://developer.nvidia.com/gpugems/gpugems/contributors">波浪模拟</a>, BabylonJS 官方也演示了<a href="https://www.youtube.com/watch?v=JqMxTZ2q4Nw&amp;list=PLsaE__vWcRam5eDcUlGHvylTaATXCAQnC">这一块</a>.
</p>

<p>
如果纵眼望去 <code>ShaderToy</code> 和 <code>VertexShaderArt</code> 上的例子, 可以发现 <code>Vertex Shader</code> 比起 <code>Fragment Shader</code> 更加偏向线性代数(比如这个<a href="https://www.vertexshaderart.com/art/R2FYLbHWTcCWh5PiE">例子</a>, 满满都是矩阵), 两者都涉及微积分的内容.
</p>

<p>
不管怎么说, 如果想要在游戏视觉特效的开发上得心应手, 那么它们两者都很重要.
</p>

<blockquote>
<p>
你可能会听到有人说 <code>ShaderToy</code> 的例子有点太过"邪道", 对游戏开发来说用处不大.
</p>

<p>
但我想说的是 "放屁", 就我见过的一些游戏 <code>Demo</code>, 有好几个用了 <code>SDF</code> 替代粒子系统从而大大地节省了画面上的开销.
</p>

<p>
再说难道游戏里面用到的噪声算法在 <code>ShaderToy</code> 里面看不到吗? 退一步讲, 难道里面的各种数学知识用不上?
</p>
</blockquote>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: saltb0rn (<a href="mailto:asche34@outlook.com">asche34@outlook.com</a>)</p>
<p class="date">Date: 2022-02-11</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.1 (<a href="https://orgmode.org">Org</a> mode 9.7.11)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
